(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __markAsModule = (target) => __defProp(target, '__esModule', {value: true});
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };
  var __exportStar = (target, module, desc) => {
    if (module && typeof module === 'object' || typeof module === 'function') {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== 'default')
          __defProp(target, key, {
            get: () => module[key],
            enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable
          });
    }
    return target;
  };
  var __toModule = (module) => {
    if (module && module.__esModule) return module;
    return __exportStar(
        __markAsModule(__defProp(
            module != null ? __create(__getProtoOf(module)) : {}, 'default',
            {value: module, enumerable: true})),
        module);
  };

  // external/npm/node_modules/ngx-markdown/node_modules/marked/lib/marked.js
  var require_marked = __commonJS((exports, module) => {
    (function(global2, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ?
          module.exports = factory() :
          typeof define === 'function' && define.amd ?
          define(factory) :
          (global2 = typeof globalThis !== 'undefined' ? globalThis : global2 || self,
           global2.marked = factory());
    })(exports, function() {
      'use strict';
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ('value' in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === 'string') return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === 'Object' && o.constructor) n = o.constructor.name;
        if (n === 'Map' || n === 'Set') return Array.from(o);
        if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var it;
        if (typeof Symbol === 'undefined' || o[Symbol.iterator] == null) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) ||
              allowArrayLike && o && typeof o.length === 'number') {
            if (it) o = it;
            var i = 0;
            return function() {
              if (i >= o.length) return {done: true};
              return {done: false, value: o[i++]};
            };
          }
          throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');
        }
        it = o[Symbol.iterator]();
        return it.next.bind(it);
      }
      function createCommonjsModule(fn) {
        var module2 = {exports: {}};
        return fn(module2, module2.exports), module2.exports;
      }
      var defaults = createCommonjsModule(function(module2) {
        function getDefaults2() {
          return {
            baseUrl: null,
            breaks: false,
            gfm: true,
            headerIds: true,
            headerPrefix: '',
            highlight: null,
            langPrefix: 'language-',
            mangle: true,
            pedantic: false,
            renderer: null,
            sanitize: false,
            sanitizer: null,
            silent: false,
            smartLists: false,
            smartypants: false,
            tokenizer: null,
            walkTokens: null,
            xhtml: false
          };
        }
        function changeDefaults2(newDefaults) {
          module2.exports.defaults = newDefaults;
        }
        module2.exports = {
          defaults: getDefaults2(),
          getDefaults: getDefaults2,
          changeDefaults: changeDefaults2
        };
      });
      var escapeTest = /[&<>"']/;
      var escapeReplace = /[&<>"']/g;
      var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
      var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
      var escapeReplacements =
          {'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;'};
      var getEscapeReplacement = function getEscapeReplacement2(ch) {
        return escapeReplacements[ch];
      };
      function escape(html, encode) {
        if (encode) {
          if (escapeTest.test(html)) {
            return html.replace(escapeReplace, getEscapeReplacement);
          }
        } else {
          if (escapeTestNoEncode.test(html)) {
            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
          }
        }
        return html;
      }
      var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
      function unescape(html) {
        return html.replace(unescapeTest, function(_, n) {
          n = n.toLowerCase();
          if (n === 'colon') return ':';
          if (n.charAt(0) === '#') {
            return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) :
                                         String.fromCharCode(+n.substring(1));
          }
          return '';
        });
      }
      var caret = /(^|[^\[])\^/g;
      function edit(regex, opt) {
        regex = regex.source || regex;
        opt = opt || '';
        var obj = {
          replace: function replace(name, val) {
            val = val.source || val;
            val = val.replace(caret, '$1');
            regex = regex.replace(name, val);
            return obj;
          },
          getRegex: function getRegex() {
            return new RegExp(regex, opt);
          }
        };
        return obj;
      }
      var nonWordAndColonTest = /[^\w:]/g;
      var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
      function cleanUrl(sanitize, base, href) {
        if (sanitize) {
          var prot;
          try {
            prot =
                decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, '').toLowerCase();
          } catch (e) {
            return null;
          }
          if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 ||
              prot.indexOf('data:') === 0) {
            return null;
          }
        }
        if (base && !originIndependentUrl.test(href)) {
          href = resolveUrl(base, href);
        }
        try {
          href = encodeURI(href).replace(/%25/g, '%');
        } catch (e) {
          return null;
        }
        return href;
      }
      var baseUrls = {};
      var justDomain = /^[^:]+:\/*[^/]*$/;
      var protocol = /^([^:]+:)[\s\S]*$/;
      var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
      function resolveUrl(base, href) {
        if (!baseUrls[' ' + base]) {
          if (justDomain.test(base)) {
            baseUrls[' ' + base] = base + '/';
          } else {
            baseUrls[' ' + base] = rtrim(base, '/', true);
          }
        }
        base = baseUrls[' ' + base];
        var relativeBase = base.indexOf(':') === -1;
        if (href.substring(0, 2) === '//') {
          if (relativeBase) {
            return href;
          }
          return base.replace(protocol, '$1') + href;
        } else if (href.charAt(0) === '/') {
          if (relativeBase) {
            return href;
          }
          return base.replace(domain, '$1') + href;
        } else {
          return base + href;
        }
      }
      var noopTest = {exec: function noopTest2() {}};
      function merge4(obj) {
        var i = 1, target, key;
        for (; i < arguments.length; i++) {
          target = arguments[i];
          for (key in target) {
            if (Object.prototype.hasOwnProperty.call(target, key)) {
              obj[key] = target[key];
            }
          }
        }
        return obj;
      }
      function splitCells(tableRow, count2) {
        var row = tableRow.replace(/\|/g, function(match2, offset, str) {
          var escaped = false, curr = offset;
          while (--curr >= 0 && str[curr] === '\\') {
            escaped = !escaped;
          }
          if (escaped) {
            return '|';
          } else {
            return ' |';
          }
        }), cells = row.split(/ \|/);
        var i = 0;
        if (cells.length > count2) {
          cells.splice(count2);
        } else {
          while (cells.length < count2) {
            cells.push('');
          }
        }
        for (; i < cells.length; i++) {
          cells[i] = cells[i].trim().replace(/\\\|/g, '|');
        }
        return cells;
      }
      function rtrim(str, c, invert) {
        var l = str.length;
        if (l === 0) {
          return '';
        }
        var suffLen = 0;
        while (suffLen < l) {
          var currChar = str.charAt(l - suffLen - 1);
          if (currChar === c && !invert) {
            suffLen++;
          } else if (currChar !== c && invert) {
            suffLen++;
          } else {
            break;
          }
        }
        return str.substr(0, l - suffLen);
      }
      function findClosingBracket(str, b) {
        if (str.indexOf(b[1]) === -1) {
          return -1;
        }
        var l = str.length;
        var level = 0, i = 0;
        for (; i < l; i++) {
          if (str[i] === '\\') {
            i++;
          } else if (str[i] === b[0]) {
            level++;
          } else if (str[i] === b[1]) {
            level--;
            if (level < 0) {
              return i;
            }
          }
        }
        return -1;
      }
      function checkSanitizeDeprecation(opt) {
        if (opt && opt.sanitize && !opt.silent) {
          console.warn(
              'marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
        }
      }
      function repeatString(pattern, count2) {
        if (count2 < 1) {
          return '';
        }
        var result = '';
        while (count2 > 1) {
          if (count2 & 1) {
            result += pattern;
          }
          count2 >>= 1;
          pattern += pattern;
        }
        return result + pattern;
      }
      var helpers = {
        escape,
        unescape,
        edit,
        cleanUrl,
        resolveUrl,
        noopTest,
        merge: merge4,
        splitCells,
        rtrim,
        findClosingBracket,
        checkSanitizeDeprecation,
        repeatString
      };
      var defaults$1 = defaults.defaults;
      var rtrim$1 = helpers.rtrim, splitCells$1 = helpers.splitCells, _escape = helpers.escape,
          findClosingBracket$1 = helpers.findClosingBracket;
      function outputLink(cap, link, raw) {
        var href = link.href;
        var title = link.title ? _escape(link.title) : null;
        var text = cap[1].replace(/\\([\[\]])/g, '$1');
        if (cap[0].charAt(0) !== '!') {
          return {type: 'link', raw, href, title, text};
        } else {
          return {type: 'image', raw, href, title, text: _escape(text)};
        }
      }
      function indentCodeCompensation(raw, text) {
        var matchIndentToCode = raw.match(/^(\s+)(?:```)/);
        if (matchIndentToCode === null) {
          return text;
        }
        var indentToCode = matchIndentToCode[1];
        return text.split('\n')
            .map(function(node) {
              var matchIndentInNode = node.match(/^\s+/);
              if (matchIndentInNode === null) {
                return node;
              }
              var indentInNode = matchIndentInNode[0];
              if (indentInNode.length >= indentToCode.length) {
                return node.slice(indentToCode.length);
              }
              return node;
            })
            .join('\n');
      }
      var Tokenizer_1 = function() {
        function Tokenizer(options) {
          this.options = options || defaults$1;
        }
        var _proto = Tokenizer.prototype;
        _proto.space = function space(src) {
          var cap = this.rules.block.newline.exec(src);
          if (cap) {
            if (cap[0].length > 1) {
              return {type: 'space', raw: cap[0]};
            }
            return {raw: '\n'};
          }
        };
        _proto.code = function code(src, tokens) {
          var cap = this.rules.block.code.exec(src);
          if (cap) {
            var lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === 'paragraph') {
              return {raw: cap[0], text: cap[0].trimRight()};
            }
            var text = cap[0].replace(/^ {1,4}/gm, '');
            return {
              type: 'code',
              raw: cap[0],
              codeBlockStyle: 'indented',
              text: !this.options.pedantic ? rtrim$1(text, '\n') : text
            };
          }
        };
        _proto.fences = function fences(src) {
          var cap = this.rules.block.fences.exec(src);
          if (cap) {
            var raw = cap[0];
            var text = indentCodeCompensation(raw, cap[3] || '');
            return {type: 'code', raw, lang: cap[2] ? cap[2].trim() : cap[2], text};
          }
        };
        _proto.heading = function heading(src) {
          var cap = this.rules.block.heading.exec(src);
          if (cap) {
            var text = cap[2].trim();
            if (/#$/.test(text)) {
              var trimmed = rtrim$1(text, '#');
              if (this.options.pedantic) {
                text = trimmed.trim();
              } else if (!trimmed || / $/.test(trimmed)) {
                text = trimmed.trim();
              }
            }
            return {type: 'heading', raw: cap[0], depth: cap[1].length, text};
          }
        };
        _proto.nptable = function nptable(src) {
          var cap = this.rules.block.nptable.exec(src);
          if (cap) {
            var item = {
              type: 'table',
              header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
              align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
              cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : [],
              raw: cap[0]
            };
            if (item.header.length === item.align.length) {
              var l = item.align.length;
              var i;
              for (i = 0; i < l; i++) {
                if (/^ *-+: *$/.test(item.align[i])) {
                  item.align[i] = 'right';
                } else if (/^ *:-+: *$/.test(item.align[i])) {
                  item.align[i] = 'center';
                } else if (/^ *:-+ *$/.test(item.align[i])) {
                  item.align[i] = 'left';
                } else {
                  item.align[i] = null;
                }
              }
              l = item.cells.length;
              for (i = 0; i < l; i++) {
                item.cells[i] = splitCells$1(item.cells[i], item.header.length);
              }
              return item;
            }
          }
        };
        _proto.hr = function hr(src) {
          var cap = this.rules.block.hr.exec(src);
          if (cap) {
            return {type: 'hr', raw: cap[0]};
          }
        };
        _proto.blockquote = function blockquote(src) {
          var cap = this.rules.block.blockquote.exec(src);
          if (cap) {
            var text = cap[0].replace(/^ *> ?/gm, '');
            return {type: 'blockquote', raw: cap[0], text};
          }
        };
        _proto.list = function list(src) {
          var cap = this.rules.block.list.exec(src);
          if (cap) {
            var raw = cap[0];
            var bull = cap[2];
            var isordered = bull.length > 1;
            var list2 = {
              type: 'list',
              raw,
              ordered: isordered,
              start: isordered ? +bull.slice(0, -1) : '',
              loose: false,
              items: []
            };
            var itemMatch = cap[0].match(this.rules.block.item);
            var next = false, item, space, bcurr, bnext, addBack, loose, istask, ischecked;
            var l = itemMatch.length;
            bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);
            for (var i = 0; i < l; i++) {
              item = itemMatch[i];
              raw = item;
              if (i !== l - 1) {
                bnext = this.rules.block.listItemStart.exec(itemMatch[i + 1]);
                if (!this.options.pedantic ?
                        bnext[1].length > bcurr[0].length || bnext[1].length > 3 :
                        bnext[1].length > bcurr[1].length) {
                  itemMatch.splice(i, 2, itemMatch[i] + '\n' + itemMatch[i + 1]);
                  i--;
                  l--;
                  continue;
                } else {
                  if (!this.options.pedantic || this.options.smartLists ?
                          bnext[2][bnext[2].length - 1] !== bull[bull.length - 1] :
                          isordered === (bnext[2].length === 1)) {
                    addBack = itemMatch.slice(i + 1).join('\n');
                    list2.raw = list2.raw.substring(0, list2.raw.length - addBack.length);
                    i = l - 1;
                  }
                }
                bcurr = bnext;
              }
              space = item.length;
              item = item.replace(/^ *([*+-]|\d+[.)]) ?/, '');
              if (~item.indexOf('\n ')) {
                space -= item.length;
                item = !this.options.pedantic ?
                    item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') :
                    item.replace(/^ {1,4}/gm, '');
              }
              loose = next || /\n\n(?!\s*$)/.test(item);
              if (i !== l - 1) {
                next = item.charAt(item.length - 1) === '\n';
                if (!loose) loose = next;
              }
              if (loose) {
                list2.loose = true;
              }
              if (this.options.gfm) {
                istask = /^\[[ xX]\] /.test(item);
                ischecked = void 0;
                if (istask) {
                  ischecked = item[1] !== ' ';
                  item = item.replace(/^\[[ xX]\] +/, '');
                }
              }
              list2.items.push(
                  {type: 'list_item', raw, task: istask, checked: ischecked, loose, text: item});
            }
            return list2;
          }
        };
        _proto.html = function html(src) {
          var cap = this.rules.block.html.exec(src);
          if (cap) {
            return {
              type: this.options.sanitize ? 'paragraph' : 'html',
              raw: cap[0],
              pre: !this.options.sanitizer &&
                  (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
              text: this.options.sanitize ?
                  this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) :
                  cap[0]
            };
          }
        };
        _proto.def = function def(src) {
          var cap = this.rules.block.def.exec(src);
          if (cap) {
            if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
            var tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
            return {tag, raw: cap[0], href: cap[2], title: cap[3]};
          }
        };
        _proto.table = function table(src) {
          var cap = this.rules.block.table.exec(src);
          if (cap) {
            var item = {
              type: 'table',
              header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
              align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
              cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
            };
            if (item.header.length === item.align.length) {
              item.raw = cap[0];
              var l = item.align.length;
              var i;
              for (i = 0; i < l; i++) {
                if (/^ *-+: *$/.test(item.align[i])) {
                  item.align[i] = 'right';
                } else if (/^ *:-+: *$/.test(item.align[i])) {
                  item.align[i] = 'center';
                } else if (/^ *:-+ *$/.test(item.align[i])) {
                  item.align[i] = 'left';
                } else {
                  item.align[i] = null;
                }
              }
              l = item.cells.length;
              for (i = 0; i < l; i++) {
                item.cells[i] =
                    splitCells$1(item.cells[i].replace(/^ *\| *| *\| *$/g, ''), item.header.length);
              }
              return item;
            }
          }
        };
        _proto.lheading = function lheading(src) {
          var cap = this.rules.block.lheading.exec(src);
          if (cap) {
            return {
              type: 'heading',
              raw: cap[0],
              depth: cap[2].charAt(0) === '=' ? 1 : 2,
              text: cap[1]
            };
          }
        };
        _proto.paragraph = function paragraph(src) {
          var cap = this.rules.block.paragraph.exec(src);
          if (cap) {
            return {
              type: 'paragraph',
              raw: cap[0],
              text: cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1]
            };
          }
        };
        _proto.text = function text(src, tokens) {
          var cap = this.rules.block.text.exec(src);
          if (cap) {
            var lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === 'text') {
              return {raw: cap[0], text: cap[0]};
            }
            return {type: 'text', raw: cap[0], text: cap[0]};
          }
        };
        _proto.escape = function escape2(src) {
          var cap = this.rules.inline.escape.exec(src);
          if (cap) {
            return {type: 'escape', raw: cap[0], text: _escape(cap[1])};
          }
        };
        _proto.tag = function tag(src, inLink, inRawBlock) {
          var cap = this.rules.inline.tag.exec(src);
          if (cap) {
            if (!inLink && /^<a /i.test(cap[0])) {
              inLink = true;
            } else if (inLink && /^<\/a>/i.test(cap[0])) {
              inLink = false;
            }
            if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
              inRawBlock = true;
            } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
              inRawBlock = false;
            }
            return {
              type: this.options.sanitize ? 'text' : 'html',
              raw: cap[0],
              inLink,
              inRawBlock,
              text: this.options.sanitize ?
                  this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) :
                  cap[0]
            };
          }
        };
        _proto.link = function link(src) {
          var cap = this.rules.inline.link.exec(src);
          if (cap) {
            var trimmedUrl = cap[2].trim();
            if (!this.options.pedantic && /^</.test(trimmedUrl)) {
              if (!/>$/.test(trimmedUrl)) {
                return;
              }
              var rtrimSlash = rtrim$1(trimmedUrl.slice(0, -1), '\\');
              if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                return;
              }
            } else {
              var lastParenIndex = findClosingBracket$1(cap[2], '()');
              if (lastParenIndex > -1) {
                var start = cap[0].indexOf('!') === 0 ? 5 : 4;
                var linkLen = start + cap[1].length + lastParenIndex;
                cap[2] = cap[2].substring(0, lastParenIndex);
                cap[0] = cap[0].substring(0, linkLen).trim();
                cap[3] = '';
              }
            }
            var href = cap[2];
            var title = '';
            if (this.options.pedantic) {
              var link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
              if (link2) {
                href = link2[1];
                title = link2[3];
              }
            } else {
              title = cap[3] ? cap[3].slice(1, -1) : '';
            }
            href = href.trim();
            if (/^</.test(href)) {
              if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
                href = href.slice(1);
              } else {
                href = href.slice(1, -1);
              }
            }
            return outputLink(
                cap, {
                  href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
                  title: title ? title.replace(this.rules.inline._escapes, '$1') : title
                },
                cap[0]);
          }
        };
        _proto.reflink = function reflink(src, links) {
          var cap;
          if ((cap = this.rules.inline.reflink.exec(src)) ||
              (cap = this.rules.inline.nolink.exec(src))) {
            var link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
            link = links[link.toLowerCase()];
            if (!link || !link.href) {
              var text = cap[0].charAt(0);
              return {type: 'text', raw: text, text};
            }
            return outputLink(cap, link, cap[0]);
          }
        };
        _proto.strong = function strong(src, maskedSrc, prevChar) {
          if (prevChar === void 0) {
            prevChar = '';
          }
          var match2 = this.rules.inline.strong.start.exec(src);
          if (match2 &&
              (!match2[1] ||
               match2[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {
            maskedSrc = maskedSrc.slice(-1 * src.length);
            var endReg = match2[0] === '**' ? this.rules.inline.strong.endAst :
                                              this.rules.inline.strong.endUnd;
            endReg.lastIndex = 0;
            var cap;
            while ((match2 = endReg.exec(maskedSrc)) != null) {
              cap = this.rules.inline.strong.middle.exec(maskedSrc.slice(0, match2.index + 3));
              if (cap) {
                return {
                  type: 'strong',
                  raw: src.slice(0, cap[0].length),
                  text: src.slice(2, cap[0].length - 2)
                };
              }
            }
          }
        };
        _proto.em = function em(src, maskedSrc, prevChar) {
          if (prevChar === void 0) {
            prevChar = '';
          }
          var match2 = this.rules.inline.em.start.exec(src);
          if (match2 &&
              (!match2[1] ||
               match2[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {
            maskedSrc = maskedSrc.slice(-1 * src.length);
            var endReg =
                match2[0] === '*' ? this.rules.inline.em.endAst : this.rules.inline.em.endUnd;
            endReg.lastIndex = 0;
            var cap;
            while ((match2 = endReg.exec(maskedSrc)) != null) {
              cap = this.rules.inline.em.middle.exec(maskedSrc.slice(0, match2.index + 2));
              if (cap) {
                return {
                  type: 'em',
                  raw: src.slice(0, cap[0].length),
                  text: src.slice(1, cap[0].length - 1)
                };
              }
            }
          }
        };
        _proto.codespan = function codespan(src) {
          var cap = this.rules.inline.code.exec(src);
          if (cap) {
            var text = cap[2].replace(/\n/g, ' ');
            var hasNonSpaceChars = /[^ ]/.test(text);
            var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
              text = text.substring(1, text.length - 1);
            }
            text = _escape(text, true);
            return {type: 'codespan', raw: cap[0], text};
          }
        };
        _proto.br = function br(src) {
          var cap = this.rules.inline.br.exec(src);
          if (cap) {
            return {type: 'br', raw: cap[0]};
          }
        };
        _proto.del = function del(src) {
          var cap = this.rules.inline.del.exec(src);
          if (cap) {
            return {type: 'del', raw: cap[0], text: cap[2]};
          }
        };
        _proto.autolink = function autolink(src, mangle2) {
          var cap = this.rules.inline.autolink.exec(src);
          if (cap) {
            var text, href;
            if (cap[2] === '@') {
              text = _escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
              href = 'mailto:' + text;
            } else {
              text = _escape(cap[1]);
              href = text;
            }
            return {
              type: 'link',
              raw: cap[0],
              text,
              href,
              tokens: [{type: 'text', raw: text, text}]
            };
          }
        };
        _proto.url = function url(src, mangle2) {
          var cap;
          if (cap = this.rules.inline.url.exec(src)) {
            var text, href;
            if (cap[2] === '@') {
              text = _escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
              href = 'mailto:' + text;
            } else {
              var prevCapZero;
              do {
                prevCapZero = cap[0];
                cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
              } while (prevCapZero !== cap[0]);
              text = _escape(cap[0]);
              if (cap[1] === 'www.') {
                href = 'http://' + text;
              } else {
                href = text;
              }
            }
            return {
              type: 'link',
              raw: cap[0],
              text,
              href,
              tokens: [{type: 'text', raw: text, text}]
            };
          }
        };
        _proto.inlineText = function inlineText(src, inRawBlock, smartypants2) {
          var cap = this.rules.inline.text.exec(src);
          if (cap) {
            var text;
            if (inRawBlock) {
              text = this.options.sanitize ?
                  this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) :
                  cap[0];
            } else {
              text = _escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
            }
            return {type: 'text', raw: cap[0], text};
          }
        };
        return Tokenizer;
      }();
      var noopTest$1 = helpers.noopTest, edit$1 = helpers.edit, merge$1 = helpers.merge;
      var block = {
        newline: /^(?: *(?:\n|$))+/,
        code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
        fences:
            /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
        hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
        heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
        blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
        list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?! {0,3}bull )\n*|\s*$)/,
        html:
            '^ {0,3}(?:<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$))',
        def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
        nptable: noopTest$1,
        table: noopTest$1,
        lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
        _paragraph:
            /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html| +\n)[^\n]+)*)/,
        text: /^[^\n]+/
      };
      block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
      block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
      block.def = edit$1(block.def)
                      .replace('label', block._label)
                      .replace('title', block._title)
                      .getRegex();
      block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
      block.item = /^( *)(bull) ?[^\n]*(?:\n(?! *bull ?)[^\n]*)*/;
      block.item = edit$1(block.item, 'gm').replace(/bull/g, block.bullet).getRegex();
      block.listItemStart = edit$1(/^( *)(bull)/).replace('bull', block.bullet).getRegex();
      block.list =
          edit$1(block.list)
              .replace(/bull/g, block.bullet)
              .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
              .replace('def', '\\n+(?=' + block.def.source + ')')
              .getRegex();
      block._tag =
          'address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul';
      block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
      block.html =
          edit$1(block.html, 'i')
              .replace('comment', block._comment)
              .replace('tag', block._tag)
              .replace(
                  'attribute',
                  / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
              .getRegex();
      block.paragraph = edit$1(block._paragraph)
                            .replace('hr', block.hr)
                            .replace('heading', ' {0,3}#{1,6} ')
                            .replace('|lheading', '')
                            .replace('blockquote', ' {0,3}>')
                            .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
                            .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
                            .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
                            .replace('tag', block._tag)
                            .getRegex();
      block.blockquote = edit$1(block.blockquote).replace('paragraph', block.paragraph).getRegex();
      block.normal = merge$1({}, block);
      block.gfm = merge$1({}, block.normal, {
        nptable:
            '^ *([^|\\n ].*\\|.*)\\n {0,3}([-:]+ *\\|[-| :]*)(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)',
        table:
            '^ *\\|(.+)\\n {0,3}\\|?( *[-:]+[-| :]*)(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)'
      });
      block.gfm.nptable = edit$1(block.gfm.nptable)
                              .replace('hr', block.hr)
                              .replace('heading', ' {0,3}#{1,6} ')
                              .replace('blockquote', ' {0,3}>')
                              .replace('code', ' {4}[^\\n]')
                              .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
                              .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
                              .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
                              .replace('tag', block._tag)
                              .getRegex();
      block.gfm.table = edit$1(block.gfm.table)
                            .replace('hr', block.hr)
                            .replace('heading', ' {0,3}#{1,6} ')
                            .replace('blockquote', ' {0,3}>')
                            .replace('code', ' {4}[^\\n]')
                            .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
                            .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
                            .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
                            .replace('tag', block._tag)
                            .getRegex();
      block.pedantic = merge$1({}, block.normal, {
        html:
            edit$1(
                `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`)
                .replace('comment', block._comment)
                .replace(
                    /tag/g,
                    '(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
                .getRegex(),
        def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
        heading: /^(#{1,6})(.*)(?:\n+|$)/,
        fences: noopTest$1,
        paragraph: edit$1(block.normal._paragraph)
                       .replace('hr', block.hr)
                       .replace('heading', ' *#{1,6} *[^\n]')
                       .replace('lheading', block.lheading)
                       .replace('blockquote', ' {0,3}>')
                       .replace('|fences', '')
                       .replace('|list', '')
                       .replace('|html', '')
                       .getRegex()
      });
      var inline = {
        escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
        autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
        url: noopTest$1,
        tag:
            '^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
        link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
        reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
        nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
        reflinkSearch: 'reflink|nolink(?!\\()',
        strong: {
          start: /^(?:(\*\*(?=[*punctuation]))|\*\*)(?![\s])|__/,
          middle:
              /^\*\*(?:(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)|\*(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)*?\*)+?\*\*$|^__(?![\s])((?:(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)*?_)+?)__$/,
          endAst: /[^punctuation\s]\*\*(?!\*)|[punctuation]\*\*(?!\*)(?:(?=[punctuation_\s]|$))/,
          endUnd: /[^\s]__(?!_)(?:(?=[punctuation*\s])|$)/
        },
        em: {
          start: /^(?:(\*(?=[punctuation]))|\*)(?![*\s])|_/,
          middle:
              /^\*(?:(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)|\*(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)*?\*)+?\*$|^_(?![_\s])(?:(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)*?_)+?_$/,
          endAst: /[^punctuation\s]\*(?!\*)|[punctuation]\*(?!\*)(?:(?=[punctuation_\s]|$))/,
          endUnd: /[^\s]_(?!_)(?:(?=[punctuation*\s])|$)/
        },
        code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
        br: /^( {2,}|\\)\n(?!\s*$)/,
        del: noopTest$1,
        text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n)))/,
        punctuation: /^([\s*punctuation])/
      };
      inline._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
      inline.punctuation =
          edit$1(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
      inline._blockSkip = '\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>';
      inline._overlapSkip = '__[^_]*?__|\\*\\*\\[^\\*\\]*?\\*\\*';
      inline._comment = edit$1(block._comment).replace('(?:-->|$)', '-->').getRegex();
      inline.em.start =
          edit$1(inline.em.start).replace(/punctuation/g, inline._punctuation).getRegex();
      inline.em.middle = edit$1(inline.em.middle)
                             .replace(/punctuation/g, inline._punctuation)
                             .replace(/overlapSkip/g, inline._overlapSkip)
                             .getRegex();
      inline.em.endAst =
          edit$1(inline.em.endAst, 'g').replace(/punctuation/g, inline._punctuation).getRegex();
      inline.em.endUnd =
          edit$1(inline.em.endUnd, 'g').replace(/punctuation/g, inline._punctuation).getRegex();
      inline.strong.start =
          edit$1(inline.strong.start).replace(/punctuation/g, inline._punctuation).getRegex();
      inline.strong.middle = edit$1(inline.strong.middle)
                                 .replace(/punctuation/g, inline._punctuation)
                                 .replace(/overlapSkip/g, inline._overlapSkip)
                                 .getRegex();
      inline.strong.endAst =
          edit$1(inline.strong.endAst, 'g').replace(/punctuation/g, inline._punctuation).getRegex();
      inline.strong.endUnd =
          edit$1(inline.strong.endUnd, 'g').replace(/punctuation/g, inline._punctuation).getRegex();
      inline.blockSkip = edit$1(inline._blockSkip, 'g').getRegex();
      inline.overlapSkip = edit$1(inline._overlapSkip, 'g').getRegex();
      inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
      inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
      inline._email =
          /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
      inline.autolink = edit$1(inline.autolink)
                            .replace('scheme', inline._scheme)
                            .replace('email', inline._email)
                            .getRegex();
      inline._attribute =
          /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
      inline.tag = edit$1(inline.tag)
                       .replace('comment', inline._comment)
                       .replace('attribute', inline._attribute)
                       .getRegex();
      inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
      inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
      inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
      inline.link = edit$1(inline.link)
                        .replace('label', inline._label)
                        .replace('href', inline._href)
                        .replace('title', inline._title)
                        .getRegex();
      inline.reflink = edit$1(inline.reflink).replace('label', inline._label).getRegex();
      inline.reflinkSearch = edit$1(inline.reflinkSearch, 'g')
                                 .replace('reflink', inline.reflink)
                                 .replace('nolink', inline.nolink)
                                 .getRegex();
      inline.normal = merge$1({}, inline);
      inline.pedantic = merge$1({}, inline.normal, {
        strong: {
          start: /^__|\*\*/,
          middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
          endAst: /\*\*(?!\*)/g,
          endUnd: /__(?!_)/g
        },
        em: {
          start: /^_|\*/,
          middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
          endAst: /\*(?!\*)/g,
          endUnd: /_(?!_)/g
        },
        link: edit$1(/^!?\[(label)\]\((.*?)\)/).replace('label', inline._label).getRegex(),
        reflink: edit$1(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', inline._label).getRegex()
      });
      inline.gfm = merge$1({}, inline.normal, {
        escape: edit$1(inline.escape).replace('])', '~|])').getRegex(),
        _extended_email:
            /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
        url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
        _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
        del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
        text:
            /^([`~]+|[^`~])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
      });
      inline.gfm.url =
          edit$1(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();
      inline.breaks = merge$1({}, inline.gfm, {
        br: edit$1(inline.br).replace('{2,}', '*').getRegex(),
        text: edit$1(inline.gfm.text)
                  .replace('\\b_', '\\b_| {2,}\\n')
                  .replace(/\{2,\}/g, '*')
                  .getRegex()
      });
      var rules = {block, inline};
      var defaults$2 = defaults.defaults;
      var block$1 = rules.block, inline$1 = rules.inline;
      var repeatString$1 = helpers.repeatString;
      function smartypants(text) {
        return text.replace(/---/g, '\u2014')
            .replace(/--/g, '\u2013')
            .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
            .replace(/'/g, '\u2019')
            .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201C')
            .replace(/"/g, '\u201D')
            .replace(/\.{3}/g, '\u2026');
      }
      function mangle(text) {
        var out = '', i, ch;
        var l = text.length;
        for (i = 0; i < l; i++) {
          ch = text.charCodeAt(i);
          if (Math.random() > 0.5) {
            ch = 'x' + ch.toString(16);
          }
          out += '&#' + ch + ';';
        }
        return out;
      }
      var Lexer_1 = function() {
        function Lexer(options) {
          this.tokens = [];
          this.tokens.links = Object.create(null);
          this.options = options || defaults$2;
          this.options.tokenizer = this.options.tokenizer || new Tokenizer_1();
          this.tokenizer = this.options.tokenizer;
          this.tokenizer.options = this.options;
          var rules2 = {block: block$1.normal, inline: inline$1.normal};
          if (this.options.pedantic) {
            rules2.block = block$1.pedantic;
            rules2.inline = inline$1.pedantic;
          } else if (this.options.gfm) {
            rules2.block = block$1.gfm;
            if (this.options.breaks) {
              rules2.inline = inline$1.breaks;
            } else {
              rules2.inline = inline$1.gfm;
            }
          }
          this.tokenizer.rules = rules2;
        }
        Lexer.lex = function lex(src, options) {
          var lexer = new Lexer(options);
          return lexer.lex(src);
        };
        Lexer.lexInline = function lexInline(src, options) {
          var lexer = new Lexer(options);
          return lexer.inlineTokens(src);
        };
        var _proto = Lexer.prototype;
        _proto.lex = function lex(src) {
          src = src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ');
          this.blockTokens(src, this.tokens, true);
          this.inline(this.tokens);
          return this.tokens;
        };
        _proto.blockTokens = function blockTokens(src, tokens, top) {
          if (tokens === void 0) {
            tokens = [];
          }
          if (top === void 0) {
            top = true;
          }
          if (this.options.pedantic) {
            src = src.replace(/^ +$/gm, '');
          }
          var token, i, l, lastToken;
          while (src) {
            if (token = this.tokenizer.space(src)) {
              src = src.substring(token.raw.length);
              if (token.type) {
                tokens.push(token);
              }
              continue;
            }
            if (token = this.tokenizer.code(src, tokens)) {
              src = src.substring(token.raw.length);
              if (token.type) {
                tokens.push(token);
              } else {
                lastToken = tokens[tokens.length - 1];
                lastToken.raw += '\n' + token.raw;
                lastToken.text += '\n' + token.text;
              }
              continue;
            }
            if (token = this.tokenizer.fences(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.heading(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.nptable(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.hr(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.blockquote(src)) {
              src = src.substring(token.raw.length);
              token.tokens = this.blockTokens(token.text, [], top);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.list(src)) {
              src = src.substring(token.raw.length);
              l = token.items.length;
              for (i = 0; i < l; i++) {
                token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);
              }
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.html(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (top && (token = this.tokenizer.def(src))) {
              src = src.substring(token.raw.length);
              if (!this.tokens.links[token.tag]) {
                this.tokens.links[token.tag] = {href: token.href, title: token.title};
              }
              continue;
            }
            if (token = this.tokenizer.table(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.lheading(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (top && (token = this.tokenizer.paragraph(src))) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.text(src, tokens)) {
              src = src.substring(token.raw.length);
              if (token.type) {
                tokens.push(token);
              } else {
                lastToken = tokens[tokens.length - 1];
                lastToken.raw += '\n' + token.raw;
                lastToken.text += '\n' + token.text;
              }
              continue;
            }
            if (src) {
              var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
              if (this.options.silent) {
                console.error(errMsg);
                break;
              } else {
                throw new Error(errMsg);
              }
            }
          }
          return tokens;
        };
        _proto.inline = function inline2(tokens) {
          var i, j, k, l2, row, token;
          var l = tokens.length;
          for (i = 0; i < l; i++) {
            token = tokens[i];
            switch (token.type) {
              case 'paragraph':
              case 'text':
              case 'heading': {
                token.tokens = [];
                this.inlineTokens(token.text, token.tokens);
                break;
              }
              case 'table': {
                token.tokens = {header: [], cells: []};
                l2 = token.header.length;
                for (j = 0; j < l2; j++) {
                  token.tokens.header[j] = [];
                  this.inlineTokens(token.header[j], token.tokens.header[j]);
                }
                l2 = token.cells.length;
                for (j = 0; j < l2; j++) {
                  row = token.cells[j];
                  token.tokens.cells[j] = [];
                  for (k = 0; k < row.length; k++) {
                    token.tokens.cells[j][k] = [];
                    this.inlineTokens(row[k], token.tokens.cells[j][k]);
                  }
                }
                break;
              }
              case 'blockquote': {
                this.inline(token.tokens);
                break;
              }
              case 'list': {
                l2 = token.items.length;
                for (j = 0; j < l2; j++) {
                  this.inline(token.items[j].tokens);
                }
                break;
              }
            }
          }
          return tokens;
        };
        _proto.inlineTokens = function inlineTokens(src, tokens, inLink, inRawBlock) {
          if (tokens === void 0) {
            tokens = [];
          }
          if (inLink === void 0) {
            inLink = false;
          }
          if (inRawBlock === void 0) {
            inRawBlock = false;
          }
          var token;
          var maskedSrc = src;
          var match2;
          var keepPrevChar, prevChar;
          if (this.tokens.links) {
            var links = Object.keys(this.tokens.links);
            if (links.length > 0) {
              while ((match2 = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
                if (links.includes(match2[0].slice(match2[0].lastIndexOf('[') + 1, -1))) {
                  maskedSrc = maskedSrc.slice(0, match2.index) + '[' +
                      repeatString$1('a', match2[0].length - 2) + ']' +
                      maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
                }
              }
            }
          }
          while ((match2 = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
            maskedSrc = maskedSrc.slice(0, match2.index) + '[' +
                repeatString$1('a', match2[0].length - 2) + ']' +
                maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
          }
          while (src) {
            if (!keepPrevChar) {
              prevChar = '';
            }
            keepPrevChar = false;
            if (token = this.tokenizer.escape(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {
              src = src.substring(token.raw.length);
              inLink = token.inLink;
              inRawBlock = token.inRawBlock;
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.link(src)) {
              src = src.substring(token.raw.length);
              if (token.type === 'link') {
                token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
              }
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.reflink(src, this.tokens.links)) {
              src = src.substring(token.raw.length);
              if (token.type === 'link') {
                token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
              }
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.strong(src, maskedSrc, prevChar)) {
              src = src.substring(token.raw.length);
              token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.em(src, maskedSrc, prevChar)) {
              src = src.substring(token.raw.length);
              token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.codespan(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.br(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.del(src)) {
              src = src.substring(token.raw.length);
              token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.autolink(src, mangle)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (!inLink && (token = this.tokenizer.url(src, mangle))) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {
              src = src.substring(token.raw.length);
              prevChar = token.raw.slice(-1);
              keepPrevChar = true;
              tokens.push(token);
              continue;
            }
            if (src) {
              var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
              if (this.options.silent) {
                console.error(errMsg);
                break;
              } else {
                throw new Error(errMsg);
              }
            }
          }
          return tokens;
        };
        _createClass(Lexer, null, [{
                       key: 'rules',
                       get: function get() {
                         return {block: block$1, inline: inline$1};
                       }
                     }]);
        return Lexer;
      }();
      var defaults$3 = defaults.defaults;
      var cleanUrl$1 = helpers.cleanUrl, escape$1 = helpers.escape;
      var Renderer_1 = function() {
        function Renderer4(options) {
          this.options = options || defaults$3;
        }
        var _proto = Renderer4.prototype;
        _proto.code = function code(_code, infostring, escaped) {
          var lang = (infostring || '').match(/\S*/)[0];
          if (this.options.highlight) {
            var out = this.options.highlight(_code, lang);
            if (out != null && out !== _code) {
              escaped = true;
              _code = out;
            }
          }
          _code = _code.replace(/\n$/, '') + '\n';
          if (!lang) {
            return '<pre><code>' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\n';
          }
          return '<pre><code class="' + this.options.langPrefix + escape$1(lang, true) + '">' +
              (escaped ? _code : escape$1(_code, true)) + '</code></pre>\n';
        };
        _proto.blockquote = function blockquote(quote) {
          return '<blockquote>\n' + quote + '</blockquote>\n';
        };
        _proto.html = function html(_html) {
          return _html;
        };
        _proto.heading = function heading(text, level, raw, slugger) {
          if (this.options.headerIds) {
            return '<h' + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' +
                text + '</h' + level + '>\n';
          }
          return '<h' + level + '>' + text + '</h' + level + '>\n';
        };
        _proto.hr = function hr() {
          return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
        };
        _proto.list = function list(body, ordered, start) {
          var type = ordered ? 'ol' : 'ul',
              startatt = ordered && start !== 1 ? ' start="' + start + '"' : '';
          return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
        };
        _proto.listitem = function listitem(text) {
          return '<li>' + text + '</li>\n';
        };
        _proto.checkbox = function checkbox(checked) {
          return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox"' +
              (this.options.xhtml ? ' /' : '') + '> ';
        };
        _proto.paragraph = function paragraph(text) {
          return '<p>' + text + '</p>\n';
        };
        _proto.table = function table(header, body) {
          if (body) body = '<tbody>' + body + '</tbody>';
          return '<table>\n<thead>\n' + header + '</thead>\n' + body + '</table>\n';
        };
        _proto.tablerow = function tablerow(content) {
          return '<tr>\n' + content + '</tr>\n';
        };
        _proto.tablecell = function tablecell(content, flags) {
          var type = flags.header ? 'th' : 'td';
          var tag = flags.align ? '<' + type + ' align="' + flags.align + '">' : '<' + type + '>';
          return tag + content + '</' + type + '>\n';
        };
        _proto.strong = function strong(text) {
          return '<strong>' + text + '</strong>';
        };
        _proto.em = function em(text) {
          return '<em>' + text + '</em>';
        };
        _proto.codespan = function codespan(text) {
          return '<code>' + text + '</code>';
        };
        _proto.br = function br() {
          return this.options.xhtml ? '<br/>' : '<br>';
        };
        _proto.del = function del(text) {
          return '<del>' + text + '</del>';
        };
        _proto.link = function link(href, title, text) {
          href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);
          if (href === null) {
            return text;
          }
          var out = '<a href="' + escape$1(href) + '"';
          if (title) {
            out += ' title="' + title + '"';
          }
          out += '>' + text + '</a>';
          return out;
        };
        _proto.image = function image(href, title, text) {
          href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);
          if (href === null) {
            return text;
          }
          var out = '<img src="' + href + '" alt="' + text + '"';
          if (title) {
            out += ' title="' + title + '"';
          }
          out += this.options.xhtml ? '/>' : '>';
          return out;
        };
        _proto.text = function text(_text) {
          return _text;
        };
        return Renderer4;
      }();
      var TextRenderer_1 = function() {
        function TextRenderer() {}
        var _proto = TextRenderer.prototype;
        _proto.strong = function strong(text) {
          return text;
        };
        _proto.em = function em(text) {
          return text;
        };
        _proto.codespan = function codespan(text) {
          return text;
        };
        _proto.del = function del(text) {
          return text;
        };
        _proto.html = function html(text) {
          return text;
        };
        _proto.text = function text(_text) {
          return _text;
        };
        _proto.link = function link(href, title, text) {
          return '' + text;
        };
        _proto.image = function image(href, title, text) {
          return '' + text;
        };
        _proto.br = function br() {
          return '';
        };
        return TextRenderer;
      }();
      var Slugger_1 = function() {
        function Slugger() {
          this.seen = {};
        }
        var _proto = Slugger.prototype;
        _proto.serialize = function serialize(value) {
          return value.toLowerCase()
              .trim()
              .replace(/<[!\/a-z].*?>/ig, '')
              .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
              .replace(/\s/g, '-');
        };
        _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
          var slug = originalSlug;
          var occurenceAccumulator = 0;
          if (this.seen.hasOwnProperty(slug)) {
            occurenceAccumulator = this.seen[originalSlug];
            do {
              occurenceAccumulator++;
              slug = originalSlug + '-' + occurenceAccumulator;
            } while (this.seen.hasOwnProperty(slug));
          }
          if (!isDryRun) {
            this.seen[originalSlug] = occurenceAccumulator;
            this.seen[slug] = 0;
          }
          return slug;
        };
        _proto.slug = function slug(value, options) {
          if (options === void 0) {
            options = {};
          }
          var slug2 = this.serialize(value);
          return this.getNextSafeSlug(slug2, options.dryrun);
        };
        return Slugger;
      }();
      var defaults$4 = defaults.defaults;
      var unescape$1 = helpers.unescape;
      var Parser_1 = function() {
        function Parser(options) {
          this.options = options || defaults$4;
          this.options.renderer = this.options.renderer || new Renderer_1();
          this.renderer = this.options.renderer;
          this.renderer.options = this.options;
          this.textRenderer = new TextRenderer_1();
          this.slugger = new Slugger_1();
        }
        Parser.parse = function parse2(tokens, options) {
          var parser = new Parser(options);
          return parser.parse(tokens);
        };
        Parser.parseInline = function parseInline(tokens, options) {
          var parser = new Parser(options);
          return parser.parseInline(tokens);
        };
        var _proto = Parser.prototype;
        _proto.parse = function parse2(tokens, top) {
          if (top === void 0) {
            top = true;
          }
          var out = '', i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose,
              itemBody, item, checked, task, checkbox;
          var l = tokens.length;
          for (i = 0; i < l; i++) {
            token = tokens[i];
            switch (token.type) {
              case 'space': {
                continue;
              }
              case 'hr': {
                out += this.renderer.hr();
                continue;
              }
              case 'heading': {
                out += this.renderer.heading(
                    this.parseInline(token.tokens), token.depth,
                    unescape$1(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
                continue;
              }
              case 'code': {
                out += this.renderer.code(token.text, token.lang, token.escaped);
                continue;
              }
              case 'table': {
                header = '';
                cell = '';
                l2 = token.header.length;
                for (j = 0; j < l2; j++) {
                  cell += this.renderer.tablecell(
                      this.parseInline(token.tokens.header[j]),
                      {header: true, align: token.align[j]});
                }
                header += this.renderer.tablerow(cell);
                body = '';
                l2 = token.cells.length;
                for (j = 0; j < l2; j++) {
                  row = token.tokens.cells[j];
                  cell = '';
                  l3 = row.length;
                  for (k = 0; k < l3; k++) {
                    cell += this.renderer.tablecell(
                        this.parseInline(row[k]), {header: false, align: token.align[k]});
                  }
                  body += this.renderer.tablerow(cell);
                }
                out += this.renderer.table(header, body);
                continue;
              }
              case 'blockquote': {
                body = this.parse(token.tokens);
                out += this.renderer.blockquote(body);
                continue;
              }
              case 'list': {
                ordered = token.ordered;
                start = token.start;
                loose = token.loose;
                l2 = token.items.length;
                body = '';
                for (j = 0; j < l2; j++) {
                  item = token.items[j];
                  checked = item.checked;
                  task = item.task;
                  itemBody = '';
                  if (item.task) {
                    checkbox = this.renderer.checkbox(checked);
                    if (loose) {
                      if (item.tokens.length > 0 && item.tokens[0].type === 'text') {
                        item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 &&
                            item.tokens[0].tokens[0].type === 'text') {
                          item.tokens[0].tokens[0].text =
                              checkbox + ' ' + item.tokens[0].tokens[0].text;
                        }
                      } else {
                        item.tokens.unshift({type: 'text', text: checkbox});
                      }
                    } else {
                      itemBody += checkbox;
                    }
                  }
                  itemBody += this.parse(item.tokens, loose);
                  body += this.renderer.listitem(itemBody, task, checked);
                }
                out += this.renderer.list(body, ordered, start);
                continue;
              }
              case 'html': {
                out += this.renderer.html(token.text);
                continue;
              }
              case 'paragraph': {
                out += this.renderer.paragraph(this.parseInline(token.tokens));
                continue;
              }
              case 'text': {
                body = token.tokens ? this.parseInline(token.tokens) : token.text;
                while (i + 1 < l && tokens[i + 1].type === 'text') {
                  token = tokens[++i];
                  body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
                }
                out += top ? this.renderer.paragraph(body) : body;
                continue;
              }
              default: {
                var errMsg = 'Token with "' + token.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(errMsg);
                  return;
                } else {
                  throw new Error(errMsg);
                }
              }
            }
          }
          return out;
        };
        _proto.parseInline = function parseInline(tokens, renderer) {
          renderer = renderer || this.renderer;
          var out = '', i, token;
          var l = tokens.length;
          for (i = 0; i < l; i++) {
            token = tokens[i];
            switch (token.type) {
              case 'escape': {
                out += renderer.text(token.text);
                break;
              }
              case 'html': {
                out += renderer.html(token.text);
                break;
              }
              case 'link': {
                out += renderer.link(
                    token.href, token.title, this.parseInline(token.tokens, renderer));
                break;
              }
              case 'image': {
                out += renderer.image(token.href, token.title, token.text);
                break;
              }
              case 'strong': {
                out += renderer.strong(this.parseInline(token.tokens, renderer));
                break;
              }
              case 'em': {
                out += renderer.em(this.parseInline(token.tokens, renderer));
                break;
              }
              case 'codespan': {
                out += renderer.codespan(token.text);
                break;
              }
              case 'br': {
                out += renderer.br();
                break;
              }
              case 'del': {
                out += renderer.del(this.parseInline(token.tokens, renderer));
                break;
              }
              case 'text': {
                out += renderer.text(token.text);
                break;
              }
              default: {
                var errMsg = 'Token with "' + token.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(errMsg);
                  return;
                } else {
                  throw new Error(errMsg);
                }
              }
            }
          }
          return out;
        };
        return Parser;
      }();
      var merge$2 = helpers.merge, checkSanitizeDeprecation$1 = helpers.checkSanitizeDeprecation,
          escape$2 = helpers.escape;
      var getDefaults = defaults.getDefaults, changeDefaults = defaults.changeDefaults,
          defaults$5 = defaults.defaults;
      function marked(src, opt, callback) {
        if (typeof src === 'undefined' || src === null) {
          throw new Error('marked(): input parameter is undefined or null');
        }
        if (typeof src !== 'string') {
          throw new Error(
              'marked(): input parameter is of type ' + Object.prototype.toString.call(src) +
              ', string expected');
        }
        if (typeof opt === 'function') {
          callback = opt;
          opt = null;
        }
        opt = merge$2({}, marked.defaults, opt || {});
        checkSanitizeDeprecation$1(opt);
        if (callback) {
          var highlight = opt.highlight;
          var tokens;
          try {
            tokens = Lexer_1.lex(src, opt);
          } catch (e) {
            return callback(e);
          }
          var done = function done2(err) {
            var out;
            if (!err) {
              try {
                out = Parser_1.parse(tokens, opt);
              } catch (e) {
                err = e;
              }
            }
            opt.highlight = highlight;
            return err ? callback(err) : callback(null, out);
          };
          if (!highlight || highlight.length < 3) {
            return done();
          }
          delete opt.highlight;
          if (!tokens.length) return done();
          var pending = 0;
          marked.walkTokens(tokens, function(token) {
            if (token.type === 'code') {
              pending++;
              setTimeout(function() {
                highlight(token.text, token.lang, function(err, code) {
                  if (err) {
                    return done(err);
                  }
                  if (code != null && code !== token.text) {
                    token.text = code;
                    token.escaped = true;
                  }
                  pending--;
                  if (pending === 0) {
                    done();
                  }
                });
              }, 0);
            }
          });
          if (pending === 0) {
            done();
          }
          return;
        }
        try {
          var _tokens = Lexer_1.lex(src, opt);
          if (opt.walkTokens) {
            marked.walkTokens(_tokens, opt.walkTokens);
          }
          return Parser_1.parse(_tokens, opt);
        } catch (e) {
          e.message += '\nPlease report this to https://github.com/markedjs/marked.';
          if (opt.silent) {
            return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';
          }
          throw e;
        }
      }
      marked.options = marked.setOptions = function(opt) {
        merge$2(marked.defaults, opt);
        changeDefaults(marked.defaults);
        return marked;
      };
      marked.getDefaults = getDefaults;
      marked.defaults = defaults$5;
      marked.use = function(extension) {
        var opts = merge$2({}, extension);
        if (extension.renderer) {
          (function() {
            var renderer = marked.defaults.renderer || new Renderer_1();
            var _loop = function _loop2(prop2) {
              var prevRenderer = renderer[prop2];
              renderer[prop2] = function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len;
                     _key++) {
                  args[_key] = arguments[_key];
                }
                var ret = extension.renderer[prop2].apply(renderer, args);
                if (ret === false) {
                  ret = prevRenderer.apply(renderer, args);
                }
                return ret;
              };
            };
            for (var prop in extension.renderer) {
              _loop(prop);
            }
            opts.renderer = renderer;
          })();
        }
        if (extension.tokenizer) {
          (function() {
            var tokenizer = marked.defaults.tokenizer || new Tokenizer_1();
            var _loop2 = function _loop22(prop2) {
              var prevTokenizer = tokenizer[prop2];
              tokenizer[prop2] = function() {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;
                     _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }
                var ret = extension.tokenizer[prop2].apply(tokenizer, args);
                if (ret === false) {
                  ret = prevTokenizer.apply(tokenizer, args);
                }
                return ret;
              };
            };
            for (var prop in extension.tokenizer) {
              _loop2(prop);
            }
            opts.tokenizer = tokenizer;
          })();
        }
        if (extension.walkTokens) {
          var walkTokens = marked.defaults.walkTokens;
          opts.walkTokens = function(token) {
            extension.walkTokens(token);
            if (walkTokens) {
              walkTokens(token);
            }
          };
        }
        marked.setOptions(opts);
      };
      marked.walkTokens = function(tokens, callback) {
        for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step;
             !(_step = _iterator()).done;) {
          var token = _step.value;
          callback(token);
          switch (token.type) {
            case 'table': {
              for (var _iterator2 = _createForOfIteratorHelperLoose(token.tokens.header), _step2;
                   !(_step2 = _iterator2()).done;) {
                var cell = _step2.value;
                marked.walkTokens(cell, callback);
              }
              for (var _iterator3 = _createForOfIteratorHelperLoose(token.tokens.cells), _step3;
                   !(_step3 = _iterator3()).done;) {
                var row = _step3.value;
                for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4;
                     !(_step4 = _iterator4()).done;) {
                  var _cell = _step4.value;
                  marked.walkTokens(_cell, callback);
                }
              }
              break;
            }
            case 'list': {
              marked.walkTokens(token.items, callback);
              break;
            }
            default: {
              if (token.tokens) {
                marked.walkTokens(token.tokens, callback);
              }
            }
          }
        }
      };
      marked.parseInline = function(src, opt) {
        if (typeof src === 'undefined' || src === null) {
          throw new Error('marked.parseInline(): input parameter is undefined or null');
        }
        if (typeof src !== 'string') {
          throw new Error(
              'marked.parseInline(): input parameter is of type ' +
              Object.prototype.toString.call(src) + ', string expected');
        }
        opt = merge$2({}, marked.defaults, opt || {});
        checkSanitizeDeprecation$1(opt);
        try {
          var tokens = Lexer_1.lexInline(src, opt);
          if (opt.walkTokens) {
            marked.walkTokens(tokens, opt.walkTokens);
          }
          return Parser_1.parseInline(tokens, opt);
        } catch (e) {
          e.message += '\nPlease report this to https://github.com/markedjs/marked.';
          if (opt.silent) {
            return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';
          }
          throw e;
        }
      };
      marked.Parser = Parser_1;
      marked.parser = Parser_1.parse;
      marked.Renderer = Renderer_1;
      marked.TextRenderer = TextRenderer_1;
      marked.Lexer = Lexer_1;
      marked.lexer = Lexer_1.lex;
      marked.Tokenizer = Tokenizer_1;
      marked.Slugger = Slugger_1;
      marked.parse = marked;
      var marked_1 = marked;
      return marked_1;
    });
  });

  // external/npm/node_modules/tslib/tslib.es6.js
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    if (typeof b !== 'function' && b !== null)
      throw new TypeError('Class extends value ' + String(b) + ' is not a constructor or null');
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  // external/npm/node_modules/rxjs/_esm5/internal/util/isFunction.js
  function isFunction(x) {
    return typeof x === 'function';
  }

  // external/npm/node_modules/rxjs/_esm5/internal/config.js
  var _enable_super_gross_mode_that_will_cause_bad_things = false;
  var config = {
    Promise: void 0,
    set useDeprecatedSynchronousErrorHandling(value) {
      if (value) {
        var error = new Error();
        console.warn(
            'DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' +
            error.stack);
      } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
        console.log('RxJS: Back to a better error behavior. Thank you. <3');
      }
      _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
      return _enable_super_gross_mode_that_will_cause_bad_things;
    }
  };

  // external/npm/node_modules/rxjs/_esm5/internal/util/hostReportError.js
  function hostReportError(err) {
    setTimeout(function() {
      throw err;
    }, 0);
  }

  // external/npm/node_modules/rxjs/_esm5/internal/Observer.js
  var empty = {
    closed: true,
    next: function(value) {},
    error: function(err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        hostReportError(err);
      }
    },
    complete: function() {}
  };

  // external/npm/node_modules/rxjs/_esm5/internal/util/isArray.js
  var isArray = function() {
    return Array.isArray || function(x) {
      return x && typeof x.length === 'number';
    };
  }();

  // external/npm/node_modules/rxjs/_esm5/internal/util/isObject.js
  function isObject(x) {
    return x !== null && typeof x === 'object';
  }

  // external/npm/node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js
  var UnsubscriptionErrorImpl = function() {
    function UnsubscriptionErrorImpl2(errors) {
      Error.call(this);
      this.message = errors ? errors.length + ' errors occurred during unsubscription:\n' +
              errors
                  .map(function(err, i) {
                    return i + 1 + ') ' + err.toString();
                  })
                  .join('\n  ') :
                              '';
      this.name = 'UnsubscriptionError';
      this.errors = errors;
      return this;
    }
    UnsubscriptionErrorImpl2.prototype = Object.create(Error.prototype);
    return UnsubscriptionErrorImpl2;
  }();
  var UnsubscriptionError = UnsubscriptionErrorImpl;

  // external/npm/node_modules/rxjs/_esm5/internal/Subscription.js
  var Subscription = function() {
    function Subscription2(unsubscribe) {
      this.closed = false;
      this._parentOrParents = null;
      this._subscriptions = null;
      if (unsubscribe) {
        this._ctorUnsubscribe = true;
        this._unsubscribe = unsubscribe;
      }
    }
    Subscription2.prototype.unsubscribe = function() {
      var errors;
      if (this.closed) {
        return;
      }
      var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe,
          _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
      this.closed = true;
      this._parentOrParents = null;
      this._subscriptions = null;
      if (_parentOrParents instanceof Subscription2) {
        _parentOrParents.remove(this);
      } else if (_parentOrParents !== null) {
        for (var index = 0; index < _parentOrParents.length; ++index) {
          var parent_1 = _parentOrParents[index];
          parent_1.remove(this);
        }
      }
      if (isFunction(_unsubscribe)) {
        if (_ctorUnsubscribe) {
          this._unsubscribe = void 0;
        }
        try {
          _unsubscribe.call(this);
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
        }
      }
      if (isArray(_subscriptions)) {
        var index = -1;
        var len = _subscriptions.length;
        while (++index < len) {
          var sub = _subscriptions[index];
          if (isObject(sub)) {
            try {
              sub.unsubscribe();
            } catch (e) {
              errors = errors || [];
              if (e instanceof UnsubscriptionError) {
                errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
              } else {
                errors.push(e);
              }
            }
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var subscription = teardown;
      if (!teardown) {
        return Subscription2.EMPTY;
      }
      switch (typeof teardown) {
        case 'function':
          subscription = new Subscription2(teardown);
        case 'object':
          if (subscription === this || subscription.closed ||
              typeof subscription.unsubscribe !== 'function') {
            return subscription;
          } else if (this.closed) {
            subscription.unsubscribe();
            return subscription;
          } else if (!(subscription instanceof Subscription2)) {
            var tmp = subscription;
            subscription = new Subscription2();
            subscription._subscriptions = [tmp];
          }
          break;
        default: {
          throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
      }
      var _parentOrParents = subscription._parentOrParents;
      if (_parentOrParents === null) {
        subscription._parentOrParents = this;
      } else if (_parentOrParents instanceof Subscription2) {
        if (_parentOrParents === this) {
          return subscription;
        }
        subscription._parentOrParents = [_parentOrParents, this];
      } else if (_parentOrParents.indexOf(this) === -1) {
        _parentOrParents.push(this);
      } else {
        return subscription;
      }
      var subscriptions = this._subscriptions;
      if (subscriptions === null) {
        this._subscriptions = [subscription];
      } else {
        subscriptions.push(subscription);
      }
      return subscription;
    };
    Subscription2.prototype.remove = function(subscription) {
      var subscriptions = this._subscriptions;
      if (subscriptions) {
        var subscriptionIndex = subscriptions.indexOf(subscription);
        if (subscriptionIndex !== -1) {
          subscriptions.splice(subscriptionIndex, 1);
        }
      }
    };
    Subscription2.EMPTY = function(empty3) {
      empty3.closed = true;
      return empty3;
    }(new Subscription2());
    return Subscription2;
  }();
  function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function(errs, err) {
      return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
    }, []);
  }

  // external/npm/node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
  var rxSubscriber = function() {
    return typeof Symbol === 'function' ? Symbol('rxSubscriber') :
                                          '@@rxSubscriber_' + Math.random();
  }();

  // external/npm/node_modules/rxjs/_esm5/internal/Subscriber.js
  var Subscriber = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destinationOrNext, error, complete) {
      var _this = _super.call(this) || this;
      _this.syncErrorValue = null;
      _this.syncErrorThrown = false;
      _this.syncErrorThrowable = false;
      _this.isStopped = false;
      switch (arguments.length) {
        case 0:
          _this.destination = empty;
          break;
        case 1:
          if (!destinationOrNext) {
            _this.destination = empty;
            break;
          }
          if (typeof destinationOrNext === 'object') {
            if (destinationOrNext instanceof Subscriber2) {
              _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
              _this.destination = destinationOrNext;
              destinationOrNext.add(_this);
            } else {
              _this.syncErrorThrowable = true;
              _this.destination = new SafeSubscriber(_this, destinationOrNext);
            }
            break;
          }
        default:
          _this.syncErrorThrowable = true;
          _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
          break;
      }
      return _this;
    }
    Subscriber2.prototype[rxSubscriber] = function() {
      return this;
    };
    Subscriber2.create = function(next, error, complete) {
      var subscriber = new Subscriber2(next, error, complete);
      subscriber.syncErrorThrowable = false;
      return subscriber;
    };
    Subscriber2.prototype.next = function(value) {
      if (!this.isStopped) {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (!this.isStopped) {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (!this.isStopped) {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (this.closed) {
        return;
      }
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      this.destination.error(err);
      this.unsubscribe();
    };
    Subscriber2.prototype._complete = function() {
      this.destination.complete();
      this.unsubscribe();
    };
    Subscriber2.prototype._unsubscribeAndRecycle = function() {
      var _parentOrParents = this._parentOrParents;
      this._parentOrParents = null;
      this.unsubscribe();
      this.closed = false;
      this.isStopped = false;
      this._parentOrParents = _parentOrParents;
      return this;
    };
    return Subscriber2;
  }(Subscription);
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      _this._parentSubscriber = _parentSubscriber;
      var next;
      var context = _this;
      if (isFunction(observerOrNext)) {
        next = observerOrNext;
      } else if (observerOrNext) {
        next = observerOrNext.next;
        error = observerOrNext.error;
        complete = observerOrNext.complete;
        if (observerOrNext !== empty) {
          context = Object.create(observerOrNext);
          if (isFunction(context.unsubscribe)) {
            _this.add(context.unsubscribe.bind(context));
          }
          context.unsubscribe = _this.unsubscribe.bind(_this);
        }
      }
      _this._context = context;
      _this._next = next;
      _this._error = error;
      _this._complete = complete;
      return _this;
    }
    SafeSubscriber2.prototype.next = function(value) {
      if (!this.isStopped && this._next) {
        var _parentSubscriber = this._parentSubscriber;
        if (!config.useDeprecatedSynchronousErrorHandling ||
            !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._next, value);
        } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber2.prototype.error = function(err) {
      if (!this.isStopped) {
        var _parentSubscriber = this._parentSubscriber;
        var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
        if (this._error) {
          if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(this._error, err);
            this.unsubscribe();
          } else {
            this.__tryOrSetError(_parentSubscriber, this._error, err);
            this.unsubscribe();
          }
        } else if (!_parentSubscriber.syncErrorThrowable) {
          this.unsubscribe();
          if (useDeprecatedSynchronousErrorHandling) {
            throw err;
          }
          hostReportError(err);
        } else {
          if (useDeprecatedSynchronousErrorHandling) {
            _parentSubscriber.syncErrorValue = err;
            _parentSubscriber.syncErrorThrown = true;
          } else {
            hostReportError(err);
          }
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber2.prototype.complete = function() {
      var _this = this;
      if (!this.isStopped) {
        var _parentSubscriber = this._parentSubscriber;
        if (this._complete) {
          var wrappedComplete = function() {
            return _this._complete.call(_this._context);
          };
          if (!config.useDeprecatedSynchronousErrorHandling ||
              !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(wrappedComplete);
            this.unsubscribe();
          } else {
            this.__tryOrSetError(_parentSubscriber, wrappedComplete);
            this.unsubscribe();
          }
        } else {
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber2.prototype.__tryOrUnsub = function(fn, value) {
      try {
        fn.call(this._context, value);
      } catch (err) {
        this.unsubscribe();
        if (config.useDeprecatedSynchronousErrorHandling) {
          throw err;
        } else {
          hostReportError(err);
        }
      }
    };
    SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn, value) {
      if (!config.useDeprecatedSynchronousErrorHandling) {
        throw new Error('bad call');
      }
      try {
        fn.call(this._context, value);
      } catch (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
          parent.syncErrorValue = err;
          parent.syncErrorThrown = true;
          return true;
        } else {
          hostReportError(err);
          return true;
        }
      }
      return false;
    };
    SafeSubscriber2.prototype._unsubscribe = function() {
      var _parentSubscriber = this._parentSubscriber;
      this._context = null;
      this._parentSubscriber = null;
      _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/util/canReportError.js
  function canReportError(observer) {
    while (observer) {
      var _a = observer, closed_1 = _a.closed, destination = _a.destination,
          isStopped = _a.isStopped;
      if (closed_1 || isStopped) {
        return false;
      } else if (destination && destination instanceof Subscriber) {
        observer = destination;
      } else {
        observer = null;
      }
    }
    return true;
  }

  // external/npm/node_modules/rxjs/_esm5/internal/util/toSubscriber.js
  function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
      if (nextOrObserver instanceof Subscriber) {
        return nextOrObserver;
      }
      if (nextOrObserver[rxSubscriber]) {
        return nextOrObserver[rxSubscriber]();
      }
    }
    if (!nextOrObserver && !error && !complete) {
      return new Subscriber(empty);
    }
    return new Subscriber(nextOrObserver, error, complete);
  }

  // external/npm/node_modules/rxjs/_esm5/internal/symbol/observable.js
  var observable = function() {
    return typeof Symbol === 'function' && Symbol.observable || '@@observable';
  }();

  // external/npm/node_modules/rxjs/_esm5/internal/util/identity.js
  function identity(x) {
    return x;
  }

  // external/npm/node_modules/rxjs/_esm5/internal/util/pipe.js
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }

  // external/npm/node_modules/rxjs/_esm5/internal/Observable.js
  var Observable = function() {
    function Observable2(subscribe) {
      this._isScalar = false;
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable2 = new Observable2();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
      var operator = this.operator;
      var sink = toSubscriber(observerOrNext, error, complete);
      if (operator) {
        sink.add(operator.call(sink, this.source));
      } else {
        sink.add(
            this.source ||
                    config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
      }
      if (config.useDeprecatedSynchronousErrorHandling) {
        if (sink.syncErrorThrowable) {
          sink.syncErrorThrowable = false;
          if (sink.syncErrorThrown) {
            throw sink.syncErrorValue;
          }
        }
      }
      return sink;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
          sink.syncErrorThrown = true;
          sink.syncErrorValue = err;
        }
        if (canReportError(sink)) {
          sink.error(err);
        } else {
          console.warn(err);
        }
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscription;
        subscription = _this.subscribe(function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            if (subscription) {
              subscription.unsubscribe();
            }
          }
        }, reject, resolve);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var source = this.source;
      return source && source.subscribe(subscriber);
    };
    Observable2.prototype[observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      if (operations.length === 0) {
        return this;
      }
      return pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(
            function(x) {
              return value = x;
            },
            function(err) {
              return reject(err);
            },
            function() {
              return resolve(value);
            });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
      promiseCtor = config.Promise || Promise;
    }
    if (!promiseCtor) {
      throw new Error('no Promise impl found');
    }
    return promiseCtor;
  }

  // external/npm/node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js
  var ObjectUnsubscribedErrorImpl = function() {
    function ObjectUnsubscribedErrorImpl2() {
      Error.call(this);
      this.message = 'object unsubscribed';
      this.name = 'ObjectUnsubscribedError';
      return this;
    }
    ObjectUnsubscribedErrorImpl2.prototype = Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl2;
  }();
  var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

  // external/npm/node_modules/rxjs/_esm5/internal/SubjectSubscription.js
  var SubjectSubscription = function(_super) {
    __extends(SubjectSubscription2, _super);
    function SubjectSubscription2(subject, subscriber) {
      var _this = _super.call(this) || this;
      _this.subject = subject;
      _this.subscriber = subscriber;
      _this.closed = false;
      return _this;
    }
    SubjectSubscription2.prototype.unsubscribe = function() {
      if (this.closed) {
        return;
      }
      this.closed = true;
      var subject = this.subject;
      var observers = subject.observers;
      this.subject = null;
      if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
        return;
      }
      var subscriberIndex = observers.indexOf(this.subscriber);
      if (subscriberIndex !== -1) {
        observers.splice(subscriberIndex, 1);
      }
    };
    return SubjectSubscription2;
  }(Subscription);

  // external/npm/node_modules/rxjs/_esm5/internal/Subject.js
  var SubjectSubscriber = function(_super) {
    __extends(SubjectSubscriber2, _super);
    function SubjectSubscriber2(destination) {
      var _this = _super.call(this, destination) || this;
      _this.destination = destination;
      return _this;
    }
    return SubjectSubscriber2;
  }(Subscriber);
  var Subject = function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.observers = [];
      _this.closed = false;
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype[rxSubscriber] = function() {
      return new SubjectSubscriber(this);
    };
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype.next = function(value) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
      if (!this.isStopped) {
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
          copy[i].next(value);
        }
      }
    };
    Subject2.prototype.error = function(err) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
      this.hasError = true;
      this.thrownError = err;
      this.isStopped = true;
      var observers = this.observers;
      var len = observers.length;
      var copy = observers.slice();
      for (var i = 0; i < len; i++) {
        copy[i].error(err);
      }
      this.observers.length = 0;
    };
    Subject2.prototype.complete = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
      this.isStopped = true;
      var observers = this.observers;
      var len = observers.length;
      var copy = observers.slice();
      for (var i = 0; i < len; i++) {
        copy[i].complete();
      }
      this.observers.length = 0;
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = true;
      this.closed = true;
      this.observers = null;
    };
    Subject2.prototype._trySubscribe = function(subscriber) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else {
        return _super.prototype._trySubscribe.call(this, subscriber);
      }
    };
    Subject2.prototype._subscribe = function(subscriber) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription.EMPTY;
      } else if (this.isStopped) {
        subscriber.complete();
        return Subscription.EMPTY;
      } else {
        this.observers.push(subscriber);
        return new SubjectSubscription(this, subscriber);
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable2 = new Observable();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable);
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var destination = this.destination;
      if (destination && destination.next) {
        destination.next(value);
      }
    };
    AnonymousSubject2.prototype.error = function(err) {
      var destination = this.destination;
      if (destination && destination.error) {
        this.destination.error(err);
      }
    };
    AnonymousSubject2.prototype.complete = function() {
      var destination = this.destination;
      if (destination && destination.complete) {
        this.destination.complete();
      }
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var source = this.source;
      if (source) {
        return this.source.subscribe(subscriber);
      } else {
        return Subscription.EMPTY;
      }
    };
    return AnonymousSubject2;
  }(Subject);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/refCount.js
  function refCount() {
    return function refCountOperatorFunction(source) {
      return source.lift(new RefCountOperator(source));
    };
  }
  var RefCountOperator = function() {
    function RefCountOperator3(connectable) {
      this.connectable = connectable;
    }
    RefCountOperator3.prototype.call = function(subscriber, source) {
      var connectable = this.connectable;
      connectable._refCount++;
      var refCounter = new RefCountSubscriber(subscriber, connectable);
      var subscription = source.subscribe(refCounter);
      if (!refCounter.closed) {
        refCounter.connection = connectable.connect();
      }
      return subscription;
    };
    return RefCountOperator3;
  }();
  var RefCountSubscriber = function(_super) {
    __extends(RefCountSubscriber3, _super);
    function RefCountSubscriber3(destination, connectable) {
      var _this = _super.call(this, destination) || this;
      _this.connectable = connectable;
      return _this;
    }
    RefCountSubscriber3.prototype._unsubscribe = function() {
      var connectable = this.connectable;
      if (!connectable) {
        this.connection = null;
        return;
      }
      this.connectable = null;
      var refCount2 = connectable._refCount;
      if (refCount2 <= 0) {
        this.connection = null;
        return;
      }
      connectable._refCount = refCount2 - 1;
      if (refCount2 > 1) {
        this.connection = null;
        return;
      }
      var connection = this.connection;
      var sharedConnection = connectable._connection;
      this.connection = null;
      if (sharedConnection && (!connection || sharedConnection === connection)) {
        sharedConnection.unsubscribe();
      }
    };
    return RefCountSubscriber3;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js
  var ConnectableObservable = function(_super) {
    __extends(ConnectableObservable2, _super);
    function ConnectableObservable2(source, subjectFactory) {
      var _this = _super.call(this) || this;
      _this.source = source;
      _this.subjectFactory = subjectFactory;
      _this._refCount = 0;
      _this._isComplete = false;
      return _this;
    }
    ConnectableObservable2.prototype._subscribe = function(subscriber) {
      return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable2.prototype.getSubject = function() {
      var subject = this._subject;
      if (!subject || subject.isStopped) {
        this._subject = this.subjectFactory();
      }
      return this._subject;
    };
    ConnectableObservable2.prototype.connect = function() {
      var connection = this._connection;
      if (!connection) {
        this._isComplete = false;
        connection = this._connection = new Subscription();
        connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
        if (connection.closed) {
          this._connection = null;
          connection = Subscription.EMPTY;
        }
      }
      return connection;
    };
    ConnectableObservable2.prototype.refCount = function() {
      return refCount()(this);
    };
    return ConnectableObservable2;
  }(Observable);
  var connectableObservableDescriptor = function() {
    var connectableProto = ConnectableObservable.prototype;
    return {
      operator: {value: null},
      _refCount: {value: 0, writable: true},
      _subject: {value: null, writable: true},
      _connection: {value: null, writable: true},
      _subscribe: {value: connectableProto._subscribe},
      _isComplete: {value: connectableProto._isComplete, writable: true},
      getSubject: {value: connectableProto.getSubject},
      connect: {value: connectableProto.connect},
      refCount: {value: connectableProto.refCount}
    };
  }();
  var ConnectableSubscriber = function(_super) {
    __extends(ConnectableSubscriber2, _super);
    function ConnectableSubscriber2(destination, connectable) {
      var _this = _super.call(this, destination) || this;
      _this.connectable = connectable;
      return _this;
    }
    ConnectableSubscriber2.prototype._error = function(err) {
      this._unsubscribe();
      _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber2.prototype._complete = function() {
      this.connectable._isComplete = true;
      this._unsubscribe();
      _super.prototype._complete.call(this);
    };
    ConnectableSubscriber2.prototype._unsubscribe = function() {
      var connectable = this.connectable;
      if (connectable) {
        this.connectable = null;
        var connection = connectable._connection;
        connectable._refCount = 0;
        connectable._subject = null;
        connectable._connection = null;
        if (connection) {
          connection.unsubscribe();
        }
      }
    };
    return ConnectableSubscriber2;
  }(SubjectSubscriber);
  var RefCountOperator2 = function() {
    function RefCountOperator3(connectable) {
      this.connectable = connectable;
    }
    RefCountOperator3.prototype.call = function(subscriber, source) {
      var connectable = this.connectable;
      connectable._refCount++;
      var refCounter = new RefCountSubscriber2(subscriber, connectable);
      var subscription = source.subscribe(refCounter);
      if (!refCounter.closed) {
        refCounter.connection = connectable.connect();
      }
      return subscription;
    };
    return RefCountOperator3;
  }();
  var RefCountSubscriber2 = function(_super) {
    __extends(RefCountSubscriber3, _super);
    function RefCountSubscriber3(destination, connectable) {
      var _this = _super.call(this, destination) || this;
      _this.connectable = connectable;
      return _this;
    }
    RefCountSubscriber3.prototype._unsubscribe = function() {
      var connectable = this.connectable;
      if (!connectable) {
        this.connection = null;
        return;
      }
      this.connectable = null;
      var refCount2 = connectable._refCount;
      if (refCount2 <= 0) {
        this.connection = null;
        return;
      }
      connectable._refCount = refCount2 - 1;
      if (refCount2 > 1) {
        this.connection = null;
        return;
      }
      var connection = this.connection;
      var sharedConnection = connectable._connection;
      this.connection = null;
      if (sharedConnection && (!connection || sharedConnection === connection)) {
        sharedConnection.unsubscribe();
      }
    };
    return RefCountSubscriber3;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/groupBy.js
  var GroupByOperator = function() {
    function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
      this.keySelector = keySelector;
      this.elementSelector = elementSelector;
      this.durationSelector = durationSelector;
      this.subjectSelector = subjectSelector;
    }
    GroupByOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new GroupBySubscriber(
          subscriber, this.keySelector, this.elementSelector, this.durationSelector,
          this.subjectSelector));
    };
    return GroupByOperator2;
  }();
  var GroupBySubscriber = function(_super) {
    __extends(GroupBySubscriber2, _super);
    function GroupBySubscriber2(
        destination, keySelector, elementSelector, durationSelector, subjectSelector) {
      var _this = _super.call(this, destination) || this;
      _this.keySelector = keySelector;
      _this.elementSelector = elementSelector;
      _this.durationSelector = durationSelector;
      _this.subjectSelector = subjectSelector;
      _this.groups = null;
      _this.attemptedToUnsubscribe = false;
      _this.count = 0;
      return _this;
    }
    GroupBySubscriber2.prototype._next = function(value) {
      var key;
      try {
        key = this.keySelector(value);
      } catch (err) {
        this.error(err);
        return;
      }
      this._group(value, key);
    };
    GroupBySubscriber2.prototype._group = function(value, key) {
      var groups = this.groups;
      if (!groups) {
        groups = this.groups = new Map();
      }
      var group = groups.get(key);
      var element;
      if (this.elementSelector) {
        try {
          element = this.elementSelector(value);
        } catch (err) {
          this.error(err);
        }
      } else {
        element = value;
      }
      if (!group) {
        group = this.subjectSelector ? this.subjectSelector() : new Subject();
        groups.set(key, group);
        var groupedObservable = new GroupedObservable(key, group, this);
        this.destination.next(groupedObservable);
        if (this.durationSelector) {
          var duration = void 0;
          try {
            duration = this.durationSelector(new GroupedObservable(key, group));
          } catch (err) {
            this.error(err);
            return;
          }
          this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
        }
      }
      if (!group.closed) {
        group.next(element);
      }
    };
    GroupBySubscriber2.prototype._error = function(err) {
      var groups = this.groups;
      if (groups) {
        groups.forEach(function(group, key) {
          group.error(err);
        });
        groups.clear();
      }
      this.destination.error(err);
    };
    GroupBySubscriber2.prototype._complete = function() {
      var groups = this.groups;
      if (groups) {
        groups.forEach(function(group, key) {
          group.complete();
        });
        groups.clear();
      }
      this.destination.complete();
    };
    GroupBySubscriber2.prototype.removeGroup = function(key) {
      this.groups.delete(key);
    };
    GroupBySubscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.attemptedToUnsubscribe = true;
        if (this.count === 0) {
          _super.prototype.unsubscribe.call(this);
        }
      }
    };
    return GroupBySubscriber2;
  }(Subscriber);
  var GroupDurationSubscriber = function(_super) {
    __extends(GroupDurationSubscriber2, _super);
    function GroupDurationSubscriber2(key, group, parent) {
      var _this = _super.call(this, group) || this;
      _this.key = key;
      _this.group = group;
      _this.parent = parent;
      return _this;
    }
    GroupDurationSubscriber2.prototype._next = function(value) {
      this.complete();
    };
    GroupDurationSubscriber2.prototype._unsubscribe = function() {
      var _a = this, parent = _a.parent, key = _a.key;
      this.key = this.parent = null;
      if (parent) {
        parent.removeGroup(key);
      }
    };
    return GroupDurationSubscriber2;
  }(Subscriber);
  var GroupedObservable = function(_super) {
    __extends(GroupedObservable2, _super);
    function GroupedObservable2(key, groupSubject, refCountSubscription) {
      var _this = _super.call(this) || this;
      _this.key = key;
      _this.groupSubject = groupSubject;
      _this.refCountSubscription = refCountSubscription;
      return _this;
    }
    GroupedObservable2.prototype._subscribe = function(subscriber) {
      var subscription = new Subscription();
      var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
      if (refCountSubscription && !refCountSubscription.closed) {
        subscription.add(new InnerRefCountSubscription(refCountSubscription));
      }
      subscription.add(groupSubject.subscribe(subscriber));
      return subscription;
    };
    return GroupedObservable2;
  }(Observable);
  var InnerRefCountSubscription = function(_super) {
    __extends(InnerRefCountSubscription2, _super);
    function InnerRefCountSubscription2(parent) {
      var _this = _super.call(this) || this;
      _this.parent = parent;
      parent.count++;
      return _this;
    }
    InnerRefCountSubscription2.prototype.unsubscribe = function() {
      var parent = this.parent;
      if (!parent.closed && !this.closed) {
        _super.prototype.unsubscribe.call(this);
        parent.count -= 1;
        if (parent.count === 0 && parent.attemptedToUnsubscribe) {
          parent.unsubscribe();
        }
      }
    };
    return InnerRefCountSubscription2;
  }(Subscription);

  // external/npm/node_modules/rxjs/_esm5/internal/BehaviorSubject.js
  var BehaviorSubject = function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, 'value', {
      get: function() {
        return this.getValue();
      },
      enumerable: true,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      if (subscription && !subscription.closed) {
        subscriber.next(this._value);
      }
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      if (this.hasError) {
        throw this.thrownError;
      } else if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else {
        return this._value;
      }
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject);

  // external/npm/node_modules/rxjs/_esm5/internal/scheduler/Action.js
  var Action = function(_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function(state, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return this;
    };
    return Action2;
  }(Subscription);

  // external/npm/node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js
  var AsyncAction = function(_super) {
    __extends(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function(state, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state;
      var id = this.id;
      var scheduler = this.scheduler;
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay2);
      }
      this.pending = true;
      this.delay = delay2;
      this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return setInterval(scheduler.flush.bind(scheduler, this), delay2);
    };
    AsyncAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && this.delay === delay2 && this.pending === false) {
        return id;
      }
      clearInterval(id);
      return void 0;
    };
    AsyncAction2.prototype.execute = function(state, delay2) {
      if (this.closed) {
        return new Error('executing a cancelled action');
      }
      this.pending = false;
      var error = this._execute(state, delay2);
      if (error) {
        return error;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state, delay2) {
      var errored = false;
      var errorValue = void 0;
      try {
        this.work(state);
      } catch (e) {
        errored = true;
        errorValue = !!e && e || new Error(e);
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype._unsubscribe = function() {
      var id = this.id;
      var scheduler = this.scheduler;
      var actions = scheduler.actions;
      var index = actions.indexOf(this);
      this.work = null;
      this.state = null;
      this.pending = false;
      this.scheduler = null;
      if (index !== -1) {
        actions.splice(index, 1);
      }
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
    };
    return AsyncAction2;
  }(Action);

  // external/npm/node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js
  var QueueAction = function(_super) {
    __extends(QueueAction2, _super);
    function QueueAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    QueueAction2.prototype.schedule = function(state, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 > 0) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.delay = delay2;
      this.state = state;
      this.scheduler.flush(this);
      return this;
    };
    QueueAction2.prototype.execute = function(state, delay2) {
      return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) :
                                         this._execute(state, delay2);
    };
    QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
      }
      return scheduler.flush(this);
    };
    return QueueAction2;
  }(AsyncAction);

  // external/npm/node_modules/rxjs/_esm5/internal/Scheduler.js
  var Scheduler = function() {
    function Scheduler2(SchedulerAction, now) {
      if (now === void 0) {
        now = Scheduler2.now;
      }
      this.SchedulerAction = SchedulerAction;
      this.now = now;
    }
    Scheduler2.prototype.schedule = function(work, delay2, state) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return new this.SchedulerAction(this, work).schedule(state, delay2);
    };
    Scheduler2.now = function() {
      return Date.now();
    };
    return Scheduler2;
  }();

  // external/npm/node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js
  var AsyncScheduler = function(_super) {
    __extends(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now) {
      if (now === void 0) {
        now = Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, function() {
        if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
          return AsyncScheduler2.delegate.now();
        } else {
          return now();
        }
      }) || this;
      _this.actions = [];
      _this.active = false;
      _this.scheduled = void 0;
      return _this;
    }
    AsyncScheduler2.prototype.schedule = function(work, delay2, state) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
        return AsyncScheduler2.delegate.schedule(work, delay2, state);
      } else {
        return _super.prototype.schedule.call(this, work, delay2, state);
      }
    };
    AsyncScheduler2.prototype.flush = function(action) {
      var actions = this.actions;
      if (this.active) {
        actions.push(action);
        return;
      }
      var error;
      this.active = true;
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this.active = false;
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsyncScheduler2;
  }(Scheduler);

  // external/npm/node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js
  var QueueScheduler = function(_super) {
    __extends(QueueScheduler2, _super);
    function QueueScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler2;
  }(AsyncScheduler);

  // external/npm/node_modules/rxjs/_esm5/internal/scheduler/queue.js
  var queueScheduler = new QueueScheduler(QueueAction);
  var queue = queueScheduler;

  // external/npm/node_modules/rxjs/_esm5/internal/observable/empty.js
  var EMPTY = new Observable(function(subscriber) {
    return subscriber.complete();
  });
  function empty2(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
  }
  function emptyScheduled(scheduler) {
    return new Observable(function(subscriber) {
      return scheduler.schedule(function() {
        return subscriber.complete();
      });
    });
  }

  // external/npm/node_modules/rxjs/_esm5/internal/util/isScheduler.js
  function isScheduler(value) {
    return value && typeof value.schedule === 'function';
  }

  // external/npm/node_modules/rxjs/_esm5/internal/util/subscribeToArray.js
  var subscribeToArray = function(array) {
    return function(subscriber) {
      for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }
      subscriber.complete();
    };
  };

  // external/npm/node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js
  function scheduleArray(input, scheduler) {
    return new Observable(function(subscriber) {
      var sub = new Subscription();
      var i = 0;
      sub.add(scheduler.schedule(function() {
        if (i === input.length) {
          subscriber.complete();
          return;
        }
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          sub.add(this.schedule());
        }
      }));
      return sub;
    });
  }

  // external/npm/node_modules/rxjs/_esm5/internal/observable/fromArray.js
  function fromArray(input, scheduler) {
    if (!scheduler) {
      return new Observable(subscribeToArray(input));
    } else {
      return scheduleArray(input, scheduler);
    }
  }

  // external/npm/node_modules/rxjs/_esm5/internal/observable/of.js
  function of () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler(scheduler)) {
      args.pop();
      return scheduleArray(args, scheduler);
    } else {
      return fromArray(args);
    }
  }

  // external/npm/node_modules/rxjs/_esm5/internal/observable/throwError.js
  function throwError(error, scheduler) {
    if (!scheduler) {
      return new Observable(function(subscriber) {
        return subscriber.error(error);
      });
    } else {
      return new Observable(function(subscriber) {
        return scheduler.schedule(dispatch, 0, {error, subscriber});
      });
    }
  }
  function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
  }

  // external/npm/node_modules/rxjs/_esm5/internal/Notification.js
  var NotificationKind;
  (function(NotificationKind2) {
    NotificationKind2['NEXT'] = 'N';
    NotificationKind2['ERROR'] = 'E';
    NotificationKind2['COMPLETE'] = 'C';
  })(NotificationKind || (NotificationKind = {}));
  var Notification = function() {
    function Notification2(kind, value, error) {
      this.kind = kind;
      this.value = value;
      this.error = error;
      this.hasValue = kind === 'N';
    }
    Notification2.prototype.observe = function(observer) {
      switch (this.kind) {
        case 'N':
          return observer.next && observer.next(this.value);
        case 'E':
          return observer.error && observer.error(this.error);
        case 'C':
          return observer.complete && observer.complete();
      }
    };
    Notification2.prototype.do = function(next, error, complete) {
      var kind = this.kind;
      switch (kind) {
        case 'N':
          return next && next(this.value);
        case 'E':
          return error && error(this.error);
        case 'C':
          return complete && complete();
      }
    };
    Notification2.prototype.accept = function(nextOrObserver, error, complete) {
      if (nextOrObserver && typeof nextOrObserver.next === 'function') {
        return this.observe(nextOrObserver);
      } else {
        return this.do(nextOrObserver, error, complete);
      }
    };
    Notification2.prototype.toObservable = function() {
      var kind = this.kind;
      switch (kind) {
        case 'N':
          return of(this.value);
        case 'E':
          return throwError(this.error);
        case 'C':
          return empty2();
      }
      throw new Error('unexpected notification kind value');
    };
    Notification2.createNext = function(value) {
      if (typeof value !== 'undefined') {
        return new Notification2('N', value);
      }
      return Notification2.undefinedValueNotification;
    };
    Notification2.createError = function(err) {
      return new Notification2('E', void 0, err);
    };
    Notification2.createComplete = function() {
      return Notification2.completeNotification;
    };
    Notification2.completeNotification = new Notification2('C');
    Notification2.undefinedValueNotification = new Notification2('N', void 0);
    return Notification2;
  }();

  // external/npm/node_modules/rxjs/_esm5/internal/operators/observeOn.js
  var ObserveOnOperator = function() {
    function ObserveOnOperator2(scheduler, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      this.scheduler = scheduler;
      this.delay = delay2;
    }
    ObserveOnOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator2;
  }();
  var ObserveOnSubscriber = function(_super) {
    __extends(ObserveOnSubscriber2, _super);
    function ObserveOnSubscriber2(destination, scheduler, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      var _this = _super.call(this, destination) || this;
      _this.scheduler = scheduler;
      _this.delay = delay2;
      return _this;
    }
    ObserveOnSubscriber2.dispatch = function(arg) {
      var notification = arg.notification, destination = arg.destination;
      notification.observe(destination);
      this.unsubscribe();
    };
    ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
      var destination = this.destination;
      destination.add(this.scheduler.schedule(
          ObserveOnSubscriber2.dispatch, this.delay,
          new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber2.prototype._next = function(value) {
      this.scheduleMessage(Notification.createNext(value));
    };
    ObserveOnSubscriber2.prototype._error = function(err) {
      this.scheduleMessage(Notification.createError(err));
      this.unsubscribe();
    };
    ObserveOnSubscriber2.prototype._complete = function() {
      this.scheduleMessage(Notification.createComplete());
      this.unsubscribe();
    };
    return ObserveOnSubscriber2;
  }(Subscriber);
  var ObserveOnMessage = function() {
    function ObserveOnMessage2(notification, destination) {
      this.notification = notification;
      this.destination = destination;
    }
    return ObserveOnMessage2;
  }();

  // external/npm/node_modules/rxjs/_esm5/internal/ReplaySubject.js
  var ReplaySubject = function(_super) {
    __extends(ReplaySubject2, _super);
    function ReplaySubject2(bufferSize, windowTime2, scheduler) {
      if (bufferSize === void 0) {
        bufferSize = Number.POSITIVE_INFINITY;
      }
      if (windowTime2 === void 0) {
        windowTime2 = Number.POSITIVE_INFINITY;
      }
      var _this = _super.call(this) || this;
      _this.scheduler = scheduler;
      _this._events = [];
      _this._infiniteTimeWindow = false;
      _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
      _this._windowTime = windowTime2 < 1 ? 1 : windowTime2;
      if (windowTime2 === Number.POSITIVE_INFINITY) {
        _this._infiniteTimeWindow = true;
        _this.next = _this.nextInfiniteTimeWindow;
      } else {
        _this.next = _this.nextTimeWindow;
      }
      return _this;
    }
    ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value) {
      if (!this.isStopped) {
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) {
          _events.shift();
        }
      }
      _super.prototype.next.call(this, value);
    };
    ReplaySubject2.prototype.nextTimeWindow = function(value) {
      if (!this.isStopped) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
      }
      _super.prototype.next.call(this, value);
    };
    ReplaySubject2.prototype._subscribe = function(subscriber) {
      var _infiniteTimeWindow = this._infiniteTimeWindow;
      var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
      var scheduler = this.scheduler;
      var len = _events.length;
      var subscription;
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else if (this.isStopped || this.hasError) {
        subscription = Subscription.EMPTY;
      } else {
        this.observers.push(subscriber);
        subscription = new SubjectSubscription(this, subscriber);
      }
      if (scheduler) {
        subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
      }
      if (_infiniteTimeWindow) {
        for (var i = 0; i < len && !subscriber.closed; i++) {
          subscriber.next(_events[i]);
        }
      } else {
        for (var i = 0; i < len && !subscriber.closed; i++) {
          subscriber.next(_events[i].value);
        }
      }
      if (this.hasError) {
        subscriber.error(this.thrownError);
      } else if (this.isStopped) {
        subscriber.complete();
      }
      return subscription;
    };
    ReplaySubject2.prototype._getNow = function() {
      return (this.scheduler || queue).now();
    };
    ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
      var now = this._getNow();
      var _bufferSize = this._bufferSize;
      var _windowTime = this._windowTime;
      var _events = this._events;
      var eventsCount = _events.length;
      var spliceCount = 0;
      while (spliceCount < eventsCount) {
        if (now - _events[spliceCount].time < _windowTime) {
          break;
        }
        spliceCount++;
      }
      if (eventsCount > _bufferSize) {
        spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
      }
      if (spliceCount > 0) {
        _events.splice(0, spliceCount);
      }
      return _events;
    };
    return ReplaySubject2;
  }(Subject);
  var ReplayEvent = function() {
    function ReplayEvent2(time, value) {
      this.time = time;
      this.value = value;
    }
    return ReplayEvent2;
  }();

  // external/npm/node_modules/rxjs/_esm5/internal/AsyncSubject.js
  var AsyncSubject = function(_super) {
    __extends(AsyncSubject2, _super);
    function AsyncSubject2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.value = null;
      _this.hasNext = false;
      _this.hasCompleted = false;
      return _this;
    }
    AsyncSubject2.prototype._subscribe = function(subscriber) {
      if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription.EMPTY;
      } else if (this.hasCompleted && this.hasNext) {
        subscriber.next(this.value);
        subscriber.complete();
        return Subscription.EMPTY;
      }
      return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject2.prototype.next = function(value) {
      if (!this.hasCompleted) {
        this.value = value;
        this.hasNext = true;
      }
    };
    AsyncSubject2.prototype.error = function(error) {
      if (!this.hasCompleted) {
        _super.prototype.error.call(this, error);
      }
    };
    AsyncSubject2.prototype.complete = function() {
      this.hasCompleted = true;
      if (this.hasNext) {
        _super.prototype.next.call(this, this.value);
      }
      _super.prototype.complete.call(this);
    };
    return AsyncSubject2;
  }(Subject);

  // external/npm/node_modules/rxjs/_esm5/internal/util/Immediate.js
  var nextHandle = 1;
  var RESOLVED = function() {
    return Promise.resolve();
  }();
  var activeHandles = {};
  function findAndClearHandle(handle) {
    if (handle in activeHandles) {
      delete activeHandles[handle];
      return true;
    }
    return false;
  }
  var Immediate = {
    setImmediate: function(cb) {
      var handle = nextHandle++;
      activeHandles[handle] = true;
      RESOLVED.then(function() {
        return findAndClearHandle(handle) && cb();
      });
      return handle;
    },
    clearImmediate: function(handle) {
      findAndClearHandle(handle);
    }
  };

  // external/npm/node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js
  var AsapAction = function(_super) {
    __extends(AsapAction2, _super);
    function AsapAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
      }
      scheduler.actions.push(this);
      return scheduler.scheduled ||
          (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
      }
      if (scheduler.actions.length === 0) {
        Immediate.clearImmediate(id);
        scheduler.scheduled = void 0;
      }
      return void 0;
    };
    return AsapAction2;
  }(AsyncAction);

  // external/npm/node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js
  var AsapScheduler = function(_super) {
    __extends(AsapScheduler2, _super);
    function AsapScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler2.prototype.flush = function(action) {
      this.active = true;
      this.scheduled = void 0;
      var actions = this.actions;
      var error;
      var index = -1;
      var count2 = actions.length;
      action = action || actions.shift();
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (++index < count2 && (action = actions.shift()));
      this.active = false;
      if (error) {
        while (++index < count2 && (action = actions.shift())) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsapScheduler2;
  }(AsyncScheduler);

  // external/npm/node_modules/rxjs/_esm5/internal/scheduler/asap.js
  var asapScheduler = new AsapScheduler(AsapAction);
  var asap = asapScheduler;

  // external/npm/node_modules/rxjs/_esm5/internal/scheduler/async.js
  var asyncScheduler = new AsyncScheduler(AsyncAction);

  // external/npm/node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js
  var AnimationFrameAction = function(_super) {
    __extends(AnimationFrameAction2, _super);
    function AnimationFrameAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
      }
      scheduler.actions.push(this);
      return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function() {
                                       return scheduler.flush(null);
                                     }));
    };
    AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
      }
      if (scheduler.actions.length === 0) {
        cancelAnimationFrame(id);
        scheduler.scheduled = void 0;
      }
      return void 0;
    };
    return AnimationFrameAction2;
  }(AsyncAction);

  // external/npm/node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js
  var AnimationFrameScheduler = function(_super) {
    __extends(AnimationFrameScheduler2, _super);
    function AnimationFrameScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler2.prototype.flush = function(action) {
      this.active = true;
      this.scheduled = void 0;
      var actions = this.actions;
      var error;
      var index = -1;
      var count2 = actions.length;
      action = action || actions.shift();
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (++index < count2 && (action = actions.shift()));
      this.active = false;
      if (error) {
        while (++index < count2 && (action = actions.shift())) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AnimationFrameScheduler2;
  }(AsyncScheduler);

  // external/npm/node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js
  var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

  // external/npm/node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js
  var VirtualTimeScheduler = function(_super) {
    __extends(VirtualTimeScheduler2, _super);
    function VirtualTimeScheduler2(SchedulerAction, maxFrames) {
      if (SchedulerAction === void 0) {
        SchedulerAction = VirtualAction;
      }
      if (maxFrames === void 0) {
        maxFrames = Number.POSITIVE_INFINITY;
      }
      var _this = _super.call(this, SchedulerAction, function() {
        return _this.frame;
      }) || this;
      _this.maxFrames = maxFrames;
      _this.frame = 0;
      _this.index = -1;
      return _this;
    }
    VirtualTimeScheduler2.prototype.flush = function() {
      var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
      var error, action;
      while ((action = actions[0]) && action.delay <= maxFrames) {
        actions.shift();
        this.frame = action.delay;
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      }
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    VirtualTimeScheduler2.frameTimeFactor = 10;
    return VirtualTimeScheduler2;
  }(AsyncScheduler);
  var VirtualAction = function(_super) {
    __extends(VirtualAction2, _super);
    function VirtualAction2(scheduler, work, index) {
      if (index === void 0) {
        index = scheduler.index += 1;
      }
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.index = index;
      _this.active = true;
      _this.index = scheduler.index = index;
      return _this;
    }
    VirtualAction2.prototype.schedule = function(state, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    };
    VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      this.delay = scheduler.frame + delay2;
      var actions = scheduler.actions;
      actions.push(this);
      actions.sort(VirtualAction2.sortActions);
      return true;
    };
    VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return void 0;
    };
    VirtualAction2.prototype._execute = function(state, delay2) {
      if (this.active === true) {
        return _super.prototype._execute.call(this, state, delay2);
      }
    };
    VirtualAction2.sortActions = function(a, b) {
      if (a.delay === b.delay) {
        if (a.index === b.index) {
          return 0;
        } else if (a.index > b.index) {
          return 1;
        } else {
          return -1;
        }
      } else if (a.delay > b.delay) {
        return 1;
      } else {
        return -1;
      }
    };
    return VirtualAction2;
  }(AsyncAction);

  // external/npm/node_modules/rxjs/_esm5/internal/util/noop.js
  function noop() {}

  // external/npm/node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js
  var ArgumentOutOfRangeErrorImpl = function() {
    function ArgumentOutOfRangeErrorImpl2() {
      Error.call(this);
      this.message = 'argument out of range';
      this.name = 'ArgumentOutOfRangeError';
      return this;
    }
    ArgumentOutOfRangeErrorImpl2.prototype = Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl2;
  }();
  var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

  // external/npm/node_modules/rxjs/_esm5/internal/util/EmptyError.js
  var EmptyErrorImpl = function() {
    function EmptyErrorImpl2() {
      Error.call(this);
      this.message = 'no elements in sequence';
      this.name = 'EmptyError';
      return this;
    }
    EmptyErrorImpl2.prototype = Object.create(Error.prototype);
    return EmptyErrorImpl2;
  }();
  var EmptyError = EmptyErrorImpl;

  // external/npm/node_modules/rxjs/_esm5/internal/util/TimeoutError.js
  var TimeoutErrorImpl = function() {
    function TimeoutErrorImpl2() {
      Error.call(this);
      this.message = 'Timeout has occurred';
      this.name = 'TimeoutError';
      return this;
    }
    TimeoutErrorImpl2.prototype = Object.create(Error.prototype);
    return TimeoutErrorImpl2;
  }();

  // external/npm/node_modules/rxjs/_esm5/internal/operators/map.js
  function map(project, thisArg) {
    return function mapOperation(source) {
      if (typeof project !== 'function') {
        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
      }
      return source.lift(new MapOperator(project, thisArg));
    };
  }
  var MapOperator = function() {
    function MapOperator2(project, thisArg) {
      this.project = project;
      this.thisArg = thisArg;
    }
    MapOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator2;
  }();
  var MapSubscriber = function(_super) {
    __extends(MapSubscriber2, _super);
    function MapSubscriber2(destination, project, thisArg) {
      var _this = _super.call(this, destination) || this;
      _this.project = project;
      _this.count = 0;
      _this.thisArg = thisArg || _this;
      return _this;
    }
    MapSubscriber2.prototype._next = function(value) {
      var result;
      try {
        result = this.project.call(this.thisArg, value, this.count++);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.destination.next(result);
    };
    return MapSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/OuterSubscriber.js
  var OuterSubscriber = function(_super) {
    __extends(OuterSubscriber2, _super);
    function OuterSubscriber2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber2.prototype.notifyNext = function(
        outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.destination.next(innerValue);
    };
    OuterSubscriber2.prototype.notifyError = function(error, innerSub) {
      this.destination.error(error);
    };
    OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
      this.destination.complete();
    };
    return OuterSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/InnerSubscriber.js
  var InnerSubscriber = function(_super) {
    __extends(InnerSubscriber2, _super);
    function InnerSubscriber2(parent, outerValue, outerIndex) {
      var _this = _super.call(this) || this;
      _this.parent = parent;
      _this.outerValue = outerValue;
      _this.outerIndex = outerIndex;
      _this.index = 0;
      return _this;
    }
    InnerSubscriber2.prototype._next = function(value) {
      this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber2.prototype._error = function(error) {
      this.parent.notifyError(error, this);
      this.unsubscribe();
    };
    InnerSubscriber2.prototype._complete = function() {
      this.parent.notifyComplete(this);
      this.unsubscribe();
    };
    return InnerSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js
  var subscribeToPromise = function(promise2) {
    return function(subscriber) {
      promise2
          .then(
              function(value) {
                if (!subscriber.closed) {
                  subscriber.next(value);
                  subscriber.complete();
                }
              },
              function(err) {
                return subscriber.error(err);
              })
          .then(null, hostReportError);
      return subscriber;
    };
  };

  // external/npm/node_modules/rxjs/_esm5/internal/symbol/iterator.js
  function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
      return '@@iterator';
    }
    return Symbol.iterator;
  }
  var iterator = getSymbolIterator();

  // external/npm/node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js
  var subscribeToIterable = function(iterable) {
    return function(subscriber) {
      var iterator2 = iterable[iterator]();
      do {
        var item = void 0;
        try {
          item = iterator2.next();
        } catch (err) {
          subscriber.error(err);
          return subscriber;
        }
        if (item.done) {
          subscriber.complete();
          break;
        }
        subscriber.next(item.value);
        if (subscriber.closed) {
          break;
        }
      } while (true);
      if (typeof iterator2.return === 'function') {
        subscriber.add(function() {
          if (iterator2.return ) {
            iterator2.return();
          }
        });
      }
      return subscriber;
    };
  };

  // external/npm/node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js
  var subscribeToObservable = function(obj) {
    return function(subscriber) {
      var obs = obj[observable]();
      if (typeof obs.subscribe !== 'function') {
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
      } else {
        return obs.subscribe(subscriber);
      }
    };
  };

  // external/npm/node_modules/rxjs/_esm5/internal/util/isArrayLike.js
  var isArrayLike = function(x) {
    return x && typeof x.length === 'number' && typeof x !== 'function';
  };

  // external/npm/node_modules/rxjs/_esm5/internal/util/isPromise.js
  function isPromise(value) {
    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
  }

  // external/npm/node_modules/rxjs/_esm5/internal/util/subscribeTo.js
  var subscribeTo = function(result) {
    if (!!result && typeof result[observable] === 'function') {
      return subscribeToObservable(result);
    } else if (isArrayLike(result)) {
      return subscribeToArray(result);
    } else if (isPromise(result)) {
      return subscribeToPromise(result);
    } else if (!!result && typeof result[iterator] === 'function') {
      return subscribeToIterable(result);
    } else {
      var value = isObject(result) ? 'an invalid object' : '\'' + result + '\'';
      var msg = 'You provided ' + value +
          ' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.';
      throw new TypeError(msg);
    }
  };

  // external/npm/node_modules/rxjs/_esm5/internal/util/subscribeToResult.js
  function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
    if (innerSubscriber === void 0) {
      innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    }
    if (innerSubscriber.closed) {
      return void 0;
    }
    if (result instanceof Observable) {
      return result.subscribe(innerSubscriber);
    }
    return subscribeTo(result)(innerSubscriber);
  }

  // external/npm/node_modules/rxjs/_esm5/internal/observable/combineLatest.js
  var NONE = {};
  function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }
    var resultSelector = void 0;
    var scheduler = void 0;
    if (isScheduler(observables[observables.length - 1])) {
      scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
      resultSelector = observables.pop();
    }
    if (observables.length === 1 && isArray(observables[0])) {
      observables = observables[0];
    }
    return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
  }
  var CombineLatestOperator = function() {
    function CombineLatestOperator2(resultSelector) {
      this.resultSelector = resultSelector;
    }
    CombineLatestOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator2;
  }();
  var CombineLatestSubscriber = function(_super) {
    __extends(CombineLatestSubscriber2, _super);
    function CombineLatestSubscriber2(destination, resultSelector) {
      var _this = _super.call(this, destination) || this;
      _this.resultSelector = resultSelector;
      _this.active = 0;
      _this.values = [];
      _this.observables = [];
      return _this;
    }
    CombineLatestSubscriber2.prototype._next = function(observable2) {
      this.values.push(NONE);
      this.observables.push(observable2);
    };
    CombineLatestSubscriber2.prototype._complete = function() {
      var observables = this.observables;
      var len = observables.length;
      if (len === 0) {
        this.destination.complete();
      } else {
        this.active = len;
        this.toRespond = len;
        for (var i = 0; i < len; i++) {
          var observable2 = observables[i];
          this.add(subscribeToResult(this, observable2, void 0, i));
        }
      }
    };
    CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
      if ((this.active -= 1) === 0) {
        this.destination.complete();
      }
    };
    CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
      var values = this.values;
      var oldVal = values[outerIndex];
      var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
      values[outerIndex] = innerValue;
      if (toRespond === 0) {
        if (this.resultSelector) {
          this._tryResultSelector(values);
        } else {
          this.destination.next(values.slice());
        }
      }
    };
    CombineLatestSubscriber2.prototype._tryResultSelector = function(values) {
      var result;
      try {
        result = this.resultSelector.apply(this, values);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.destination.next(result);
    };
    return CombineLatestSubscriber2;
  }(OuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js
  function scheduleObservable(input, scheduler) {
    return new Observable(function(subscriber) {
      var sub = new Subscription();
      sub.add(scheduler.schedule(function() {
        var observable2 = input[observable]();
        sub.add(observable2.subscribe({
          next: function(value) {
            sub.add(scheduler.schedule(function() {
              return subscriber.next(value);
            }));
          },
          error: function(err) {
            sub.add(scheduler.schedule(function() {
              return subscriber.error(err);
            }));
          },
          complete: function() {
            sub.add(scheduler.schedule(function() {
              return subscriber.complete();
            }));
          }
        }));
      }));
      return sub;
    });
  }

  // external/npm/node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js
  function schedulePromise(input, scheduler) {
    return new Observable(function(subscriber) {
      var sub = new Subscription();
      sub.add(scheduler.schedule(function() {
        return input.then(
            function(value) {
              sub.add(scheduler.schedule(function() {
                subscriber.next(value);
                sub.add(scheduler.schedule(function() {
                  return subscriber.complete();
                }));
              }));
            },
            function(err) {
              sub.add(scheduler.schedule(function() {
                return subscriber.error(err);
              }));
            });
      }));
      return sub;
    });
  }

  // external/npm/node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js
  function scheduleIterable(input, scheduler) {
    if (!input) {
      throw new Error('Iterable cannot be null');
    }
    return new Observable(function(subscriber) {
      var sub = new Subscription();
      var iterator2;
      sub.add(function() {
        if (iterator2 && typeof iterator2.return === 'function') {
          iterator2.return();
        }
      });
      sub.add(scheduler.schedule(function() {
        iterator2 = input[iterator]();
        sub.add(scheduler.schedule(function() {
          if (subscriber.closed) {
            return;
          }
          var value;
          var done;
          try {
            var result = iterator2.next();
            value = result.value;
            done = result.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
            this.schedule();
          }
        }));
      }));
      return sub;
    });
  }

  // external/npm/node_modules/rxjs/_esm5/internal/util/isInteropObservable.js
  function isInteropObservable(input) {
    return input && typeof input[observable] === 'function';
  }

  // external/npm/node_modules/rxjs/_esm5/internal/util/isIterable.js
  function isIterable(input) {
    return input && typeof input[iterator] === 'function';
  }

  // external/npm/node_modules/rxjs/_esm5/internal/scheduled/scheduled.js
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable(input)) {
        return scheduleObservable(input, scheduler);
      } else if (isPromise(input)) {
        return schedulePromise(input, scheduler);
      } else if (isArrayLike(input)) {
        return scheduleArray(input, scheduler);
      } else if (isIterable(input) || typeof input === 'string') {
        return scheduleIterable(input, scheduler);
      }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
  }

  // external/npm/node_modules/rxjs/_esm5/internal/observable/from.js
  function from(input, scheduler) {
    if (!scheduler) {
      if (input instanceof Observable) {
        return input;
      }
      return new Observable(subscribeTo(input));
    } else {
      return scheduled(input, scheduler);
    }
  }

  // external/npm/node_modules/rxjs/_esm5/internal/innerSubscribe.js
  var SimpleInnerSubscriber = function(_super) {
    __extends(SimpleInnerSubscriber2, _super);
    function SimpleInnerSubscriber2(parent) {
      var _this = _super.call(this) || this;
      _this.parent = parent;
      return _this;
    }
    SimpleInnerSubscriber2.prototype._next = function(value) {
      this.parent.notifyNext(value);
    };
    SimpleInnerSubscriber2.prototype._error = function(error) {
      this.parent.notifyError(error);
      this.unsubscribe();
    };
    SimpleInnerSubscriber2.prototype._complete = function() {
      this.parent.notifyComplete();
      this.unsubscribe();
    };
    return SimpleInnerSubscriber2;
  }(Subscriber);
  var ComplexInnerSubscriber = function(_super) {
    __extends(ComplexInnerSubscriber2, _super);
    function ComplexInnerSubscriber2(parent, outerValue, outerIndex) {
      var _this = _super.call(this) || this;
      _this.parent = parent;
      _this.outerValue = outerValue;
      _this.outerIndex = outerIndex;
      return _this;
    }
    ComplexInnerSubscriber2.prototype._next = function(value) {
      this.parent.notifyNext(this.outerValue, value, this.outerIndex, this);
    };
    ComplexInnerSubscriber2.prototype._error = function(error) {
      this.parent.notifyError(error);
      this.unsubscribe();
    };
    ComplexInnerSubscriber2.prototype._complete = function() {
      this.parent.notifyComplete(this);
      this.unsubscribe();
    };
    return ComplexInnerSubscriber2;
  }(Subscriber);
  var SimpleOuterSubscriber = function(_super) {
    __extends(SimpleOuterSubscriber2, _super);
    function SimpleOuterSubscriber2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
      this.destination.next(innerValue);
    };
    SimpleOuterSubscriber2.prototype.notifyError = function(err) {
      this.destination.error(err);
    };
    SimpleOuterSubscriber2.prototype.notifyComplete = function() {
      this.destination.complete();
    };
    return SimpleOuterSubscriber2;
  }(Subscriber);
  var ComplexOuterSubscriber = function(_super) {
    __extends(ComplexOuterSubscriber2, _super);
    function ComplexOuterSubscriber2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ComplexOuterSubscriber2.prototype.notifyNext = function(
        _outerValue, innerValue, _outerIndex, _innerSub) {
      this.destination.next(innerValue);
    };
    ComplexOuterSubscriber2.prototype.notifyError = function(error) {
      this.destination.error(error);
    };
    ComplexOuterSubscriber2.prototype.notifyComplete = function(_innerSub) {
      this.destination.complete();
    };
    return ComplexOuterSubscriber2;
  }(Subscriber);
  function innerSubscribe(result, innerSubscriber) {
    if (innerSubscriber.closed) {
      return void 0;
    }
    if (result instanceof Observable) {
      return result.subscribe(innerSubscriber);
    }
    return subscribeTo(result)(innerSubscriber);
  }

  // external/npm/node_modules/rxjs/_esm5/internal/operators/mergeMap.js
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
      return function(source) {
        return source.pipe(mergeMap(function(a, i) {
          return from(project(a, i)).pipe(map(function(b, ii) {
            return resultSelector(a, b, i, ii);
          }));
        }, concurrent));
      };
    } else if (typeof resultSelector === 'number') {
      concurrent = resultSelector;
    }
    return function(source) {
      return source.lift(new MergeMapOperator(project, concurrent));
    };
  }
  var MergeMapOperator = function() {
    function MergeMapOperator2(project, concurrent) {
      if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
      }
      this.project = project;
      this.concurrent = concurrent;
    }
    MergeMapOperator2.prototype.call = function(observer, source) {
      return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator2;
  }();
  var MergeMapSubscriber = function(_super) {
    __extends(MergeMapSubscriber2, _super);
    function MergeMapSubscriber2(destination, project, concurrent) {
      if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
      }
      var _this = _super.call(this, destination) || this;
      _this.project = project;
      _this.concurrent = concurrent;
      _this.hasCompleted = false;
      _this.buffer = [];
      _this.active = 0;
      _this.index = 0;
      return _this;
    }
    MergeMapSubscriber2.prototype._next = function(value) {
      if (this.active < this.concurrent) {
        this._tryNext(value);
      } else {
        this.buffer.push(value);
      }
    };
    MergeMapSubscriber2.prototype._tryNext = function(value) {
      var result;
      var index = this.index++;
      try {
        result = this.project(value, index);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.active++;
      this._innerSub(result);
    };
    MergeMapSubscriber2.prototype._innerSub = function(ish) {
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      var innerSubscription = innerSubscribe(ish, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        destination.add(innerSubscription);
      }
    };
    MergeMapSubscriber2.prototype._complete = function() {
      this.hasCompleted = true;
      if (this.active === 0 && this.buffer.length === 0) {
        this.destination.complete();
      }
      this.unsubscribe();
    };
    MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
      this.destination.next(innerValue);
    };
    MergeMapSubscriber2.prototype.notifyComplete = function() {
      var buffer2 = this.buffer;
      this.active--;
      if (buffer2.length > 0) {
        this._next(buffer2.shift());
      } else if (this.active === 0 && this.hasCompleted) {
        this.destination.complete();
      }
    };
    return MergeMapSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/mergeAll.js
  function mergeAll(concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    return mergeMap(identity, concurrent);
  }

  // external/npm/node_modules/rxjs/_esm5/internal/operators/concatAll.js
  function concatAll() {
    return mergeAll(1);
  }

  // external/npm/node_modules/rxjs/_esm5/internal/observable/concat.js
  function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }
    return concatAll()(of.apply(void 0, observables));
  }

  // external/npm/node_modules/rxjs/_esm5/internal/observable/defer.js
  function defer(observableFactory) {
    return new Observable(function(subscriber) {
      var input;
      try {
        input = observableFactory();
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
      var source = input ? from(input) : empty2();
      return source.subscribe(subscriber);
    });
  }

  // external/npm/node_modules/rxjs/_esm5/internal/observable/fromEvent.js
  var toString = function() {
    return Object.prototype.toString;
  }();

  // external/npm/node_modules/rxjs/_esm5/internal/util/isNumeric.js
  function isNumeric(val) {
    return !isArray(val) && val - parseFloat(val) + 1 >= 0;
  }

  // external/npm/node_modules/rxjs/_esm5/internal/observable/merge.js
  function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last3 = observables[observables.length - 1];
    if (isScheduler(last3)) {
      scheduler = observables.pop();
      if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
        concurrent = observables.pop();
      }
    } else if (typeof last3 === 'number') {
      concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
      return observables[0];
    }
    return mergeAll(concurrent)(fromArray(observables, scheduler));
  }

  // external/npm/node_modules/rxjs/_esm5/internal/observable/never.js
  var NEVER = new Observable(noop);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/filter.js
  function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
      return source.lift(new FilterOperator(predicate, thisArg));
    };
  }
  var FilterOperator = function() {
    function FilterOperator2(predicate, thisArg) {
      this.predicate = predicate;
      this.thisArg = thisArg;
    }
    FilterOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator2;
  }();
  var FilterSubscriber = function(_super) {
    __extends(FilterSubscriber2, _super);
    function FilterSubscriber2(destination, predicate, thisArg) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.thisArg = thisArg;
      _this.count = 0;
      return _this;
    }
    FilterSubscriber2.prototype._next = function(value) {
      var result;
      try {
        result = this.predicate.call(this.thisArg, value, this.count++);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      if (result) {
        this.destination.next(value);
      }
    };
    return FilterSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/observable/race.js
  var RaceOperator = function() {
    function RaceOperator2() {}
    RaceOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator2;
  }();
  var RaceSubscriber = function(_super) {
    __extends(RaceSubscriber2, _super);
    function RaceSubscriber2(destination) {
      var _this = _super.call(this, destination) || this;
      _this.hasFirst = false;
      _this.observables = [];
      _this.subscriptions = [];
      return _this;
    }
    RaceSubscriber2.prototype._next = function(observable2) {
      this.observables.push(observable2);
    };
    RaceSubscriber2.prototype._complete = function() {
      var observables = this.observables;
      var len = observables.length;
      if (len === 0) {
        this.destination.complete();
      } else {
        for (var i = 0; i < len && !this.hasFirst; i++) {
          var observable2 = observables[i];
          var subscription = subscribeToResult(this, observable2, void 0, i);
          if (this.subscriptions) {
            this.subscriptions.push(subscription);
          }
          this.add(subscription);
        }
        this.observables = null;
      }
    };
    RaceSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
      if (!this.hasFirst) {
        this.hasFirst = true;
        for (var i = 0; i < this.subscriptions.length; i++) {
          if (i !== outerIndex) {
            var subscription = this.subscriptions[i];
            subscription.unsubscribe();
            this.remove(subscription);
          }
        }
        this.subscriptions = null;
      }
      this.destination.next(innerValue);
    };
    return RaceSubscriber2;
  }(OuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/observable/zip.js
  var ZipOperator = function() {
    function ZipOperator2(resultSelector) {
      this.resultSelector = resultSelector;
    }
    ZipOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator2;
  }();
  var ZipSubscriber = function(_super) {
    __extends(ZipSubscriber2, _super);
    function ZipSubscriber2(destination, resultSelector, values) {
      if (values === void 0) {
        values = Object.create(null);
      }
      var _this = _super.call(this, destination) || this;
      _this.resultSelector = resultSelector;
      _this.iterators = [];
      _this.active = 0;
      _this.resultSelector = typeof resultSelector === 'function' ? resultSelector : void 0;
      return _this;
    }
    ZipSubscriber2.prototype._next = function(value) {
      var iterators = this.iterators;
      if (isArray(value)) {
        iterators.push(new StaticArrayIterator(value));
      } else if (typeof value[iterator] === 'function') {
        iterators.push(new StaticIterator(value[iterator]()));
      } else {
        iterators.push(new ZipBufferIterator(this.destination, this, value));
      }
    };
    ZipSubscriber2.prototype._complete = function() {
      var iterators = this.iterators;
      var len = iterators.length;
      this.unsubscribe();
      if (len === 0) {
        this.destination.complete();
        return;
      }
      this.active = len;
      for (var i = 0; i < len; i++) {
        var iterator2 = iterators[i];
        if (iterator2.stillUnsubscribed) {
          var destination = this.destination;
          destination.add(iterator2.subscribe());
        } else {
          this.active--;
        }
      }
    };
    ZipSubscriber2.prototype.notifyInactive = function() {
      this.active--;
      if (this.active === 0) {
        this.destination.complete();
      }
    };
    ZipSubscriber2.prototype.checkIterators = function() {
      var iterators = this.iterators;
      var len = iterators.length;
      var destination = this.destination;
      for (var i = 0; i < len; i++) {
        var iterator2 = iterators[i];
        if (typeof iterator2.hasValue === 'function' && !iterator2.hasValue()) {
          return;
        }
      }
      var shouldComplete = false;
      var args = [];
      for (var i = 0; i < len; i++) {
        var iterator2 = iterators[i];
        var result = iterator2.next();
        if (iterator2.hasCompleted()) {
          shouldComplete = true;
        }
        if (result.done) {
          destination.complete();
          return;
        }
        args.push(result.value);
      }
      if (this.resultSelector) {
        this._tryresultSelector(args);
      } else {
        destination.next(args);
      }
      if (shouldComplete) {
        destination.complete();
      }
    };
    ZipSubscriber2.prototype._tryresultSelector = function(args) {
      var result;
      try {
        result = this.resultSelector.apply(this, args);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.destination.next(result);
    };
    return ZipSubscriber2;
  }(Subscriber);
  var StaticIterator = function() {
    function StaticIterator2(iterator2) {
      this.iterator = iterator2;
      this.nextResult = iterator2.next();
    }
    StaticIterator2.prototype.hasValue = function() {
      return true;
    };
    StaticIterator2.prototype.next = function() {
      var result = this.nextResult;
      this.nextResult = this.iterator.next();
      return result;
    };
    StaticIterator2.prototype.hasCompleted = function() {
      var nextResult = this.nextResult;
      return Boolean(nextResult && nextResult.done);
    };
    return StaticIterator2;
  }();
  var StaticArrayIterator = function() {
    function StaticArrayIterator2(array) {
      this.array = array;
      this.index = 0;
      this.length = 0;
      this.length = array.length;
    }
    StaticArrayIterator2.prototype[iterator] = function() {
      return this;
    };
    StaticArrayIterator2.prototype.next = function(value) {
      var i = this.index++;
      var array = this.array;
      return i < this.length ? {value: array[i], done: false} : {value: null, done: true};
    };
    StaticArrayIterator2.prototype.hasValue = function() {
      return this.array.length > this.index;
    };
    StaticArrayIterator2.prototype.hasCompleted = function() {
      return this.array.length === this.index;
    };
    return StaticArrayIterator2;
  }();
  var ZipBufferIterator = function(_super) {
    __extends(ZipBufferIterator2, _super);
    function ZipBufferIterator2(destination, parent, observable2) {
      var _this = _super.call(this, destination) || this;
      _this.parent = parent;
      _this.observable = observable2;
      _this.stillUnsubscribed = true;
      _this.buffer = [];
      _this.isComplete = false;
      return _this;
    }
    ZipBufferIterator2.prototype[iterator] = function() {
      return this;
    };
    ZipBufferIterator2.prototype.next = function() {
      var buffer2 = this.buffer;
      if (buffer2.length === 0 && this.isComplete) {
        return {value: null, done: true};
      } else {
        return {value: buffer2.shift(), done: false};
      }
    };
    ZipBufferIterator2.prototype.hasValue = function() {
      return this.buffer.length > 0;
    };
    ZipBufferIterator2.prototype.hasCompleted = function() {
      return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator2.prototype.notifyComplete = function() {
      if (this.buffer.length > 0) {
        this.isComplete = true;
        this.parent.notifyInactive();
      } else {
        this.destination.complete();
      }
    };
    ZipBufferIterator2.prototype.notifyNext = function(innerValue) {
      this.buffer.push(innerValue);
      this.parent.checkIterators();
    };
    ZipBufferIterator2.prototype.subscribe = function() {
      return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
    };
    return ZipBufferIterator2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/audit.js
  var AuditOperator = function() {
    function AuditOperator2(durationSelector) {
      this.durationSelector = durationSelector;
    }
    AuditOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator2;
  }();
  var AuditSubscriber = function(_super) {
    __extends(AuditSubscriber2, _super);
    function AuditSubscriber2(destination, durationSelector) {
      var _this = _super.call(this, destination) || this;
      _this.durationSelector = durationSelector;
      _this.hasValue = false;
      return _this;
    }
    AuditSubscriber2.prototype._next = function(value) {
      this.value = value;
      this.hasValue = true;
      if (!this.throttled) {
        var duration = void 0;
        try {
          var durationSelector = this.durationSelector;
          duration = durationSelector(value);
        } catch (err) {
          return this.destination.error(err);
        }
        var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
        if (!innerSubscription || innerSubscription.closed) {
          this.clearThrottle();
        } else {
          this.add(this.throttled = innerSubscription);
        }
      }
    };
    AuditSubscriber2.prototype.clearThrottle = function() {
      var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
      if (throttled) {
        this.remove(throttled);
        this.throttled = void 0;
        throttled.unsubscribe();
      }
      if (hasValue) {
        this.value = void 0;
        this.hasValue = false;
        this.destination.next(value);
      }
    };
    AuditSubscriber2.prototype.notifyNext = function() {
      this.clearThrottle();
    };
    AuditSubscriber2.prototype.notifyComplete = function() {
      this.clearThrottle();
    };
    return AuditSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/buffer.js
  var BufferOperator = function() {
    function BufferOperator2(closingNotifier) {
      this.closingNotifier = closingNotifier;
    }
    BufferOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator2;
  }();
  var BufferSubscriber = function(_super) {
    __extends(BufferSubscriber2, _super);
    function BufferSubscriber2(destination, closingNotifier) {
      var _this = _super.call(this, destination) || this;
      _this.buffer = [];
      _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this)));
      return _this;
    }
    BufferSubscriber2.prototype._next = function(value) {
      this.buffer.push(value);
    };
    BufferSubscriber2.prototype.notifyNext = function() {
      var buffer2 = this.buffer;
      this.buffer = [];
      this.destination.next(buffer2);
    };
    return BufferSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/bufferCount.js
  var BufferCountOperator = function() {
    function BufferCountOperator2(bufferSize, startBufferEvery) {
      this.bufferSize = bufferSize;
      this.startBufferEvery = startBufferEvery;
      if (!startBufferEvery || bufferSize === startBufferEvery) {
        this.subscriberClass = BufferCountSubscriber;
      } else {
        this.subscriberClass = BufferSkipCountSubscriber;
      }
    }
    BufferCountOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(
          new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator2;
  }();
  var BufferCountSubscriber = function(_super) {
    __extends(BufferCountSubscriber2, _super);
    function BufferCountSubscriber2(destination, bufferSize) {
      var _this = _super.call(this, destination) || this;
      _this.bufferSize = bufferSize;
      _this.buffer = [];
      return _this;
    }
    BufferCountSubscriber2.prototype._next = function(value) {
      var buffer2 = this.buffer;
      buffer2.push(value);
      if (buffer2.length == this.bufferSize) {
        this.destination.next(buffer2);
        this.buffer = [];
      }
    };
    BufferCountSubscriber2.prototype._complete = function() {
      var buffer2 = this.buffer;
      if (buffer2.length > 0) {
        this.destination.next(buffer2);
      }
      _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber2;
  }(Subscriber);
  var BufferSkipCountSubscriber = function(_super) {
    __extends(BufferSkipCountSubscriber2, _super);
    function BufferSkipCountSubscriber2(destination, bufferSize, startBufferEvery) {
      var _this = _super.call(this, destination) || this;
      _this.bufferSize = bufferSize;
      _this.startBufferEvery = startBufferEvery;
      _this.buffers = [];
      _this.count = 0;
      return _this;
    }
    BufferSkipCountSubscriber2.prototype._next = function(value) {
      var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery,
          buffers = _a.buffers, count2 = _a.count;
      this.count++;
      if (count2 % startBufferEvery === 0) {
        buffers.push([]);
      }
      for (var i = buffers.length; i--;) {
        var buffer2 = buffers[i];
        buffer2.push(value);
        if (buffer2.length === bufferSize) {
          buffers.splice(i, 1);
          this.destination.next(buffer2);
        }
      }
    };
    BufferSkipCountSubscriber2.prototype._complete = function() {
      var _a = this, buffers = _a.buffers, destination = _a.destination;
      while (buffers.length > 0) {
        var buffer2 = buffers.shift();
        if (buffer2.length > 0) {
          destination.next(buffer2);
        }
      }
      _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/bufferTime.js
  var BufferTimeOperator = function() {
    function BufferTimeOperator2(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
      this.bufferTimeSpan = bufferTimeSpan;
      this.bufferCreationInterval = bufferCreationInterval;
      this.maxBufferSize = maxBufferSize;
      this.scheduler = scheduler;
    }
    BufferTimeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new BufferTimeSubscriber(
          subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize,
          this.scheduler));
    };
    return BufferTimeOperator2;
  }();
  var Context = function() {
    function Context2() {
      this.buffer = [];
    }
    return Context2;
  }();
  var BufferTimeSubscriber = function(_super) {
    __extends(BufferTimeSubscriber2, _super);
    function BufferTimeSubscriber2(
        destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
      var _this = _super.call(this, destination) || this;
      _this.bufferTimeSpan = bufferTimeSpan;
      _this.bufferCreationInterval = bufferCreationInterval;
      _this.maxBufferSize = maxBufferSize;
      _this.scheduler = scheduler;
      _this.contexts = [];
      var context = _this.openContext();
      _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
      if (_this.timespanOnly) {
        var timeSpanOnlyState = {subscriber: _this, context, bufferTimeSpan};
        _this.add(
            context.closeAction =
                scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
      } else {
        var closeState = {subscriber: _this, context};
        var creationState = {bufferTimeSpan, bufferCreationInterval, subscriber: _this, scheduler};
        _this.add(
            context.closeAction =
                scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
        _this.add(
            scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
      }
      return _this;
    }
    BufferTimeSubscriber2.prototype._next = function(value) {
      var contexts = this.contexts;
      var len = contexts.length;
      var filledBufferContext;
      for (var i = 0; i < len; i++) {
        var context_1 = contexts[i];
        var buffer2 = context_1.buffer;
        buffer2.push(value);
        if (buffer2.length == this.maxBufferSize) {
          filledBufferContext = context_1;
        }
      }
      if (filledBufferContext) {
        this.onBufferFull(filledBufferContext);
      }
    };
    BufferTimeSubscriber2.prototype._error = function(err) {
      this.contexts.length = 0;
      _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber2.prototype._complete = function() {
      var _a = this, contexts = _a.contexts, destination = _a.destination;
      while (contexts.length > 0) {
        var context_2 = contexts.shift();
        destination.next(context_2.buffer);
      }
      _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber2.prototype._unsubscribe = function() {
      this.contexts = null;
    };
    BufferTimeSubscriber2.prototype.onBufferFull = function(context) {
      this.closeContext(context);
      var closeAction = context.closeAction;
      closeAction.unsubscribe();
      this.remove(closeAction);
      if (!this.closed && this.timespanOnly) {
        context = this.openContext();
        var bufferTimeSpan = this.bufferTimeSpan;
        var timeSpanOnlyState = {subscriber: this, context, bufferTimeSpan};
        this.add(
            context.closeAction = this.scheduler.schedule(
                dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
      }
    };
    BufferTimeSubscriber2.prototype.openContext = function() {
      var context = new Context();
      this.contexts.push(context);
      return context;
    };
    BufferTimeSubscriber2.prototype.closeContext = function(context) {
      this.destination.next(context.buffer);
      var contexts = this.contexts;
      var spliceIndex = contexts ? contexts.indexOf(context) : -1;
      if (spliceIndex >= 0) {
        contexts.splice(contexts.indexOf(context), 1);
      }
    };
    return BufferTimeSubscriber2;
  }(Subscriber);
  function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
      subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
      state.context = subscriber.openContext();
      state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
  }
  function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval,
        bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber,
        scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
      subscriber.add(
          context.closeAction =
              scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {subscriber, context}));
      action.schedule(state, bufferCreationInterval);
    }
  }
  function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
  }

  // external/npm/node_modules/rxjs/_esm5/internal/operators/bufferToggle.js
  var BufferToggleOperator = function() {
    function BufferToggleOperator2(openings, closingSelector) {
      this.openings = openings;
      this.closingSelector = closingSelector;
    }
    BufferToggleOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(
          new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator2;
  }();
  var BufferToggleSubscriber = function(_super) {
    __extends(BufferToggleSubscriber2, _super);
    function BufferToggleSubscriber2(destination, openings, closingSelector) {
      var _this = _super.call(this, destination) || this;
      _this.closingSelector = closingSelector;
      _this.contexts = [];
      _this.add(subscribeToResult(_this, openings));
      return _this;
    }
    BufferToggleSubscriber2.prototype._next = function(value) {
      var contexts = this.contexts;
      var len = contexts.length;
      for (var i = 0; i < len; i++) {
        contexts[i].buffer.push(value);
      }
    };
    BufferToggleSubscriber2.prototype._error = function(err) {
      var contexts = this.contexts;
      while (contexts.length > 0) {
        var context_1 = contexts.shift();
        context_1.subscription.unsubscribe();
        context_1.buffer = null;
        context_1.subscription = null;
      }
      this.contexts = null;
      _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber2.prototype._complete = function() {
      var contexts = this.contexts;
      while (contexts.length > 0) {
        var context_2 = contexts.shift();
        this.destination.next(context_2.buffer);
        context_2.subscription.unsubscribe();
        context_2.buffer = null;
        context_2.subscription = null;
      }
      this.contexts = null;
      _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue) {
      outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber2.prototype.notifyComplete = function(innerSub) {
      this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber2.prototype.openBuffer = function(value) {
      try {
        var closingSelector = this.closingSelector;
        var closingNotifier = closingSelector.call(this, value);
        if (closingNotifier) {
          this.trySubscribe(closingNotifier);
        }
      } catch (err) {
        this._error(err);
      }
    };
    BufferToggleSubscriber2.prototype.closeBuffer = function(context) {
      var contexts = this.contexts;
      if (contexts && context) {
        var buffer2 = context.buffer, subscription = context.subscription;
        this.destination.next(buffer2);
        contexts.splice(contexts.indexOf(context), 1);
        this.remove(subscription);
        subscription.unsubscribe();
      }
    };
    BufferToggleSubscriber2.prototype.trySubscribe = function(closingNotifier) {
      var contexts = this.contexts;
      var buffer2 = [];
      var subscription = new Subscription();
      var context = {buffer: buffer2, subscription};
      contexts.push(context);
      var innerSubscription = subscribeToResult(this, closingNotifier, context);
      if (!innerSubscription || innerSubscription.closed) {
        this.closeBuffer(context);
      } else {
        innerSubscription.context = context;
        this.add(innerSubscription);
        subscription.add(innerSubscription);
      }
    };
    return BufferToggleSubscriber2;
  }(OuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/bufferWhen.js
  var BufferWhenOperator = function() {
    function BufferWhenOperator2(closingSelector) {
      this.closingSelector = closingSelector;
    }
    BufferWhenOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator2;
  }();
  var BufferWhenSubscriber = function(_super) {
    __extends(BufferWhenSubscriber2, _super);
    function BufferWhenSubscriber2(destination, closingSelector) {
      var _this = _super.call(this, destination) || this;
      _this.closingSelector = closingSelector;
      _this.subscribing = false;
      _this.openBuffer();
      return _this;
    }
    BufferWhenSubscriber2.prototype._next = function(value) {
      this.buffer.push(value);
    };
    BufferWhenSubscriber2.prototype._complete = function() {
      var buffer2 = this.buffer;
      if (buffer2) {
        this.destination.next(buffer2);
      }
      _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber2.prototype._unsubscribe = function() {
      this.buffer = void 0;
      this.subscribing = false;
    };
    BufferWhenSubscriber2.prototype.notifyNext = function() {
      this.openBuffer();
    };
    BufferWhenSubscriber2.prototype.notifyComplete = function() {
      if (this.subscribing) {
        this.complete();
      } else {
        this.openBuffer();
      }
    };
    BufferWhenSubscriber2.prototype.openBuffer = function() {
      var closingSubscription = this.closingSubscription;
      if (closingSubscription) {
        this.remove(closingSubscription);
        closingSubscription.unsubscribe();
      }
      var buffer2 = this.buffer;
      if (this.buffer) {
        this.destination.next(buffer2);
      }
      this.buffer = [];
      var closingNotifier;
      try {
        var closingSelector = this.closingSelector;
        closingNotifier = closingSelector();
      } catch (err) {
        return this.error(err);
      }
      closingSubscription = new Subscription();
      this.closingSubscription = closingSubscription;
      this.add(closingSubscription);
      this.subscribing = true;
      closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));
      this.subscribing = false;
    };
    return BufferWhenSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/catchError.js
  function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
      var operator = new CatchOperator(selector);
      var caught = source.lift(operator);
      return operator.caught = caught;
    };
  }
  var CatchOperator = function() {
    function CatchOperator2(selector) {
      this.selector = selector;
    }
    CatchOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator2;
  }();
  var CatchSubscriber = function(_super) {
    __extends(CatchSubscriber2, _super);
    function CatchSubscriber2(destination, selector, caught) {
      var _this = _super.call(this, destination) || this;
      _this.selector = selector;
      _this.caught = caught;
      return _this;
    }
    CatchSubscriber2.prototype.error = function(err) {
      if (!this.isStopped) {
        var result = void 0;
        try {
          result = this.selector(err, this.caught);
        } catch (err2) {
          _super.prototype.error.call(this, err2);
          return;
        }
        this._unsubscribeAndRecycle();
        var innerSubscriber = new SimpleInnerSubscriber(this);
        this.add(innerSubscriber);
        var innerSubscription = innerSubscribe(result, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          this.add(innerSubscription);
        }
      }
    };
    return CatchSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/concatMap.js
  function concatMap(project, resultSelector) {
    return mergeMap(project, resultSelector, 1);
  }

  // external/npm/node_modules/rxjs/_esm5/internal/operators/count.js
  var CountOperator = function() {
    function CountOperator2(predicate, source) {
      this.predicate = predicate;
      this.source = source;
    }
    CountOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator2;
  }();
  var CountSubscriber = function(_super) {
    __extends(CountSubscriber2, _super);
    function CountSubscriber2(destination, predicate, source) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.source = source;
      _this.count = 0;
      _this.index = 0;
      return _this;
    }
    CountSubscriber2.prototype._next = function(value) {
      if (this.predicate) {
        this._tryPredicate(value);
      } else {
        this.count++;
      }
    };
    CountSubscriber2.prototype._tryPredicate = function(value) {
      var result;
      try {
        result = this.predicate(value, this.index++, this.source);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      if (result) {
        this.count++;
      }
    };
    CountSubscriber2.prototype._complete = function() {
      this.destination.next(this.count);
      this.destination.complete();
    };
    return CountSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/debounce.js
  var DebounceOperator = function() {
    function DebounceOperator2(durationSelector) {
      this.durationSelector = durationSelector;
    }
    DebounceOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator2;
  }();
  var DebounceSubscriber = function(_super) {
    __extends(DebounceSubscriber2, _super);
    function DebounceSubscriber2(destination, durationSelector) {
      var _this = _super.call(this, destination) || this;
      _this.durationSelector = durationSelector;
      _this.hasValue = false;
      return _this;
    }
    DebounceSubscriber2.prototype._next = function(value) {
      try {
        var result = this.durationSelector.call(this, value);
        if (result) {
          this._tryNext(value, result);
        }
      } catch (err) {
        this.destination.error(err);
      }
    };
    DebounceSubscriber2.prototype._complete = function() {
      this.emitValue();
      this.destination.complete();
    };
    DebounceSubscriber2.prototype._tryNext = function(value, duration) {
      var subscription = this.durationSubscription;
      this.value = value;
      this.hasValue = true;
      if (subscription) {
        subscription.unsubscribe();
        this.remove(subscription);
      }
      subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
      if (subscription && !subscription.closed) {
        this.add(this.durationSubscription = subscription);
      }
    };
    DebounceSubscriber2.prototype.notifyNext = function() {
      this.emitValue();
    };
    DebounceSubscriber2.prototype.notifyComplete = function() {
      this.emitValue();
    };
    DebounceSubscriber2.prototype.emitValue = function() {
      if (this.hasValue) {
        var value = this.value;
        var subscription = this.durationSubscription;
        if (subscription) {
          this.durationSubscription = void 0;
          subscription.unsubscribe();
          this.remove(subscription);
        }
        this.value = void 0;
        this.hasValue = false;
        _super.prototype._next.call(this, value);
      }
    };
    return DebounceSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/debounceTime.js
  var DebounceTimeOperator = function() {
    function DebounceTimeOperator2(dueTime, scheduler) {
      this.dueTime = dueTime;
      this.scheduler = scheduler;
    }
    DebounceTimeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator2;
  }();
  var DebounceTimeSubscriber = function(_super) {
    __extends(DebounceTimeSubscriber2, _super);
    function DebounceTimeSubscriber2(destination, dueTime, scheduler) {
      var _this = _super.call(this, destination) || this;
      _this.dueTime = dueTime;
      _this.scheduler = scheduler;
      _this.debouncedSubscription = null;
      _this.lastValue = null;
      _this.hasValue = false;
      return _this;
    }
    DebounceTimeSubscriber2.prototype._next = function(value) {
      this.clearDebounce();
      this.lastValue = value;
      this.hasValue = true;
      this.add(
          this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber2.prototype._complete = function() {
      this.debouncedNext();
      this.destination.complete();
    };
    DebounceTimeSubscriber2.prototype.debouncedNext = function() {
      this.clearDebounce();
      if (this.hasValue) {
        var lastValue = this.lastValue;
        this.lastValue = null;
        this.hasValue = false;
        this.destination.next(lastValue);
      }
    };
    DebounceTimeSubscriber2.prototype.clearDebounce = function() {
      var debouncedSubscription = this.debouncedSubscription;
      if (debouncedSubscription !== null) {
        this.remove(debouncedSubscription);
        debouncedSubscription.unsubscribe();
        this.debouncedSubscription = null;
      }
    };
    return DebounceTimeSubscriber2;
  }(Subscriber);
  function dispatchNext(subscriber) {
    subscriber.debouncedNext();
  }

  // external/npm/node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js
  function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = null;
    }
    return function(source) {
      return source.lift(new DefaultIfEmptyOperator(defaultValue));
    };
  }
  var DefaultIfEmptyOperator = function() {
    function DefaultIfEmptyOperator2(defaultValue) {
      this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator2;
  }();
  var DefaultIfEmptySubscriber = function(_super) {
    __extends(DefaultIfEmptySubscriber2, _super);
    function DefaultIfEmptySubscriber2(destination, defaultValue) {
      var _this = _super.call(this, destination) || this;
      _this.defaultValue = defaultValue;
      _this.isEmpty = true;
      return _this;
    }
    DefaultIfEmptySubscriber2.prototype._next = function(value) {
      this.isEmpty = false;
      this.destination.next(value);
    };
    DefaultIfEmptySubscriber2.prototype._complete = function() {
      if (this.isEmpty) {
        this.destination.next(this.defaultValue);
      }
      this.destination.complete();
    };
    return DefaultIfEmptySubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/delay.js
  var DelayOperator = function() {
    function DelayOperator2(delay2, scheduler) {
      this.delay = delay2;
      this.scheduler = scheduler;
    }
    DelayOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator2;
  }();
  var DelaySubscriber = function(_super) {
    __extends(DelaySubscriber2, _super);
    function DelaySubscriber2(destination, delay2, scheduler) {
      var _this = _super.call(this, destination) || this;
      _this.delay = delay2;
      _this.scheduler = scheduler;
      _this.queue = [];
      _this.active = false;
      _this.errored = false;
      return _this;
    }
    DelaySubscriber2.dispatch = function(state) {
      var source = state.source;
      var queue2 = source.queue;
      var scheduler = state.scheduler;
      var destination = state.destination;
      while (queue2.length > 0 && queue2[0].time - scheduler.now() <= 0) {
        queue2.shift().notification.observe(destination);
      }
      if (queue2.length > 0) {
        var delay_1 = Math.max(0, queue2[0].time - scheduler.now());
        this.schedule(state, delay_1);
      } else {
        this.unsubscribe();
        source.active = false;
      }
    };
    DelaySubscriber2.prototype._schedule = function(scheduler) {
      this.active = true;
      var destination = this.destination;
      destination.add(scheduler.schedule(
          DelaySubscriber2.dispatch, this.delay,
          {source: this, destination: this.destination, scheduler}));
    };
    DelaySubscriber2.prototype.scheduleNotification = function(notification) {
      if (this.errored === true) {
        return;
      }
      var scheduler = this.scheduler;
      var message = new DelayMessage(scheduler.now() + this.delay, notification);
      this.queue.push(message);
      if (this.active === false) {
        this._schedule(scheduler);
      }
    };
    DelaySubscriber2.prototype._next = function(value) {
      this.scheduleNotification(Notification.createNext(value));
    };
    DelaySubscriber2.prototype._error = function(err) {
      this.errored = true;
      this.queue = [];
      this.destination.error(err);
      this.unsubscribe();
    };
    DelaySubscriber2.prototype._complete = function() {
      this.scheduleNotification(Notification.createComplete());
      this.unsubscribe();
    };
    return DelaySubscriber2;
  }(Subscriber);
  var DelayMessage = function() {
    function DelayMessage2(time, notification) {
      this.time = time;
      this.notification = notification;
    }
    return DelayMessage2;
  }();

  // external/npm/node_modules/rxjs/_esm5/internal/operators/delayWhen.js
  var DelayWhenOperator = function() {
    function DelayWhenOperator2(delayDurationSelector) {
      this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator2;
  }();
  var DelayWhenSubscriber = function(_super) {
    __extends(DelayWhenSubscriber2, _super);
    function DelayWhenSubscriber2(destination, delayDurationSelector) {
      var _this = _super.call(this, destination) || this;
      _this.delayDurationSelector = delayDurationSelector;
      _this.completed = false;
      _this.delayNotifierSubscriptions = [];
      _this.index = 0;
      return _this;
    }
    DelayWhenSubscriber2.prototype.notifyNext = function(
        outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
      this.destination.next(outerValue);
      this.removeSubscription(innerSub);
      this.tryComplete();
    };
    DelayWhenSubscriber2.prototype.notifyError = function(error, innerSub) {
      this._error(error);
    };
    DelayWhenSubscriber2.prototype.notifyComplete = function(innerSub) {
      var value = this.removeSubscription(innerSub);
      if (value) {
        this.destination.next(value);
      }
      this.tryComplete();
    };
    DelayWhenSubscriber2.prototype._next = function(value) {
      var index = this.index++;
      try {
        var delayNotifier = this.delayDurationSelector(value, index);
        if (delayNotifier) {
          this.tryDelay(delayNotifier, value);
        }
      } catch (err) {
        this.destination.error(err);
      }
    };
    DelayWhenSubscriber2.prototype._complete = function() {
      this.completed = true;
      this.tryComplete();
      this.unsubscribe();
    };
    DelayWhenSubscriber2.prototype.removeSubscription = function(subscription) {
      subscription.unsubscribe();
      var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
      if (subscriptionIdx !== -1) {
        this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
      }
      return subscription.outerValue;
    };
    DelayWhenSubscriber2.prototype.tryDelay = function(delayNotifier, value) {
      var notifierSubscription = subscribeToResult(this, delayNotifier, value);
      if (notifierSubscription && !notifierSubscription.closed) {
        var destination = this.destination;
        destination.add(notifierSubscription);
        this.delayNotifierSubscriptions.push(notifierSubscription);
      }
    };
    DelayWhenSubscriber2.prototype.tryComplete = function() {
      if (this.completed && this.delayNotifierSubscriptions.length === 0) {
        this.destination.complete();
      }
    };
    return DelayWhenSubscriber2;
  }(OuterSubscriber);
  var SubscriptionDelayObservable = function(_super) {
    __extends(SubscriptionDelayObservable2, _super);
    function SubscriptionDelayObservable2(source, subscriptionDelay) {
      var _this = _super.call(this) || this;
      _this.source = source;
      _this.subscriptionDelay = subscriptionDelay;
      return _this;
    }
    SubscriptionDelayObservable2.prototype._subscribe = function(subscriber) {
      this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable2;
  }(Observable);
  var SubscriptionDelaySubscriber = function(_super) {
    __extends(SubscriptionDelaySubscriber2, _super);
    function SubscriptionDelaySubscriber2(parent, source) {
      var _this = _super.call(this) || this;
      _this.parent = parent;
      _this.source = source;
      _this.sourceSubscribed = false;
      return _this;
    }
    SubscriptionDelaySubscriber2.prototype._next = function(unused) {
      this.subscribeToSource();
    };
    SubscriptionDelaySubscriber2.prototype._error = function(err) {
      this.unsubscribe();
      this.parent.error(err);
    };
    SubscriptionDelaySubscriber2.prototype._complete = function() {
      this.unsubscribe();
      this.subscribeToSource();
    };
    SubscriptionDelaySubscriber2.prototype.subscribeToSource = function() {
      if (!this.sourceSubscribed) {
        this.sourceSubscribed = true;
        this.unsubscribe();
        this.source.subscribe(this.parent);
      }
    };
    return SubscriptionDelaySubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/dematerialize.js
  var DeMaterializeOperator = function() {
    function DeMaterializeOperator2() {}
    DeMaterializeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator2;
  }();
  var DeMaterializeSubscriber = function(_super) {
    __extends(DeMaterializeSubscriber2, _super);
    function DeMaterializeSubscriber2(destination) {
      return _super.call(this, destination) || this;
    }
    DeMaterializeSubscriber2.prototype._next = function(value) {
      value.observe(this.destination);
    };
    return DeMaterializeSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/distinct.js
  var DistinctOperator = function() {
    function DistinctOperator2(keySelector, flushes) {
      this.keySelector = keySelector;
      this.flushes = flushes;
    }
    DistinctOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator2;
  }();
  var DistinctSubscriber = function(_super) {
    __extends(DistinctSubscriber2, _super);
    function DistinctSubscriber2(destination, keySelector, flushes) {
      var _this = _super.call(this, destination) || this;
      _this.keySelector = keySelector;
      _this.values = new Set();
      if (flushes) {
        _this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(_this)));
      }
      return _this;
    }
    DistinctSubscriber2.prototype.notifyNext = function() {
      this.values.clear();
    };
    DistinctSubscriber2.prototype.notifyError = function(error) {
      this._error(error);
    };
    DistinctSubscriber2.prototype._next = function(value) {
      if (this.keySelector) {
        this._useKeySelector(value);
      } else {
        this._finalizeNext(value, value);
      }
    };
    DistinctSubscriber2.prototype._useKeySelector = function(value) {
      var key;
      var destination = this.destination;
      try {
        key = this.keySelector(value);
      } catch (err) {
        destination.error(err);
        return;
      }
      this._finalizeNext(key, value);
    };
    DistinctSubscriber2.prototype._finalizeNext = function(key, value) {
      var values = this.values;
      if (!values.has(key)) {
        values.add(key);
        this.destination.next(value);
      }
    };
    return DistinctSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
  var DistinctUntilChangedOperator = function() {
    function DistinctUntilChangedOperator2(compare2, keySelector) {
      this.compare = compare2;
      this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(
          new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator2;
  }();
  var DistinctUntilChangedSubscriber = function(_super) {
    __extends(DistinctUntilChangedSubscriber2, _super);
    function DistinctUntilChangedSubscriber2(destination, compare2, keySelector) {
      var _this = _super.call(this, destination) || this;
      _this.keySelector = keySelector;
      _this.hasKey = false;
      if (typeof compare2 === 'function') {
        _this.compare = compare2;
      }
      return _this;
    }
    DistinctUntilChangedSubscriber2.prototype.compare = function(x, y) {
      return x === y;
    };
    DistinctUntilChangedSubscriber2.prototype._next = function(value) {
      var key;
      try {
        var keySelector = this.keySelector;
        key = keySelector ? keySelector(value) : value;
      } catch (err) {
        return this.destination.error(err);
      }
      var result = false;
      if (this.hasKey) {
        try {
          var compare2 = this.compare;
          result = compare2(this.key, key);
        } catch (err) {
          return this.destination.error(err);
        }
      } else {
        this.hasKey = true;
      }
      if (!result) {
        this.key = key;
        this.destination.next(value);
      }
    };
    return DistinctUntilChangedSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js
  function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) {
      errorFactory = defaultErrorFactory;
    }
    return function(source) {
      return source.lift(new ThrowIfEmptyOperator(errorFactory));
    };
  }
  var ThrowIfEmptyOperator = function() {
    function ThrowIfEmptyOperator2(errorFactory) {
      this.errorFactory = errorFactory;
    }
    ThrowIfEmptyOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
    };
    return ThrowIfEmptyOperator2;
  }();
  var ThrowIfEmptySubscriber = function(_super) {
    __extends(ThrowIfEmptySubscriber2, _super);
    function ThrowIfEmptySubscriber2(destination, errorFactory) {
      var _this = _super.call(this, destination) || this;
      _this.errorFactory = errorFactory;
      _this.hasValue = false;
      return _this;
    }
    ThrowIfEmptySubscriber2.prototype._next = function(value) {
      this.hasValue = true;
      this.destination.next(value);
    };
    ThrowIfEmptySubscriber2.prototype._complete = function() {
      if (!this.hasValue) {
        var err = void 0;
        try {
          err = this.errorFactory();
        } catch (e) {
          err = e;
        }
        this.destination.error(err);
      } else {
        return this.destination.complete();
      }
    };
    return ThrowIfEmptySubscriber2;
  }(Subscriber);
  function defaultErrorFactory() {
    return new EmptyError();
  }

  // external/npm/node_modules/rxjs/_esm5/internal/operators/take.js
  function take(count2) {
    return function(source) {
      if (count2 === 0) {
        return empty2();
      } else {
        return source.lift(new TakeOperator(count2));
      }
    };
  }
  var TakeOperator = function() {
    function TakeOperator2(total) {
      this.total = total;
      if (this.total < 0) {
        throw new ArgumentOutOfRangeError();
      }
    }
    TakeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator2;
  }();
  var TakeSubscriber = function(_super) {
    __extends(TakeSubscriber2, _super);
    function TakeSubscriber2(destination, total) {
      var _this = _super.call(this, destination) || this;
      _this.total = total;
      _this.count = 0;
      return _this;
    }
    TakeSubscriber2.prototype._next = function(value) {
      var total = this.total;
      var count2 = ++this.count;
      if (count2 <= total) {
        this.destination.next(value);
        if (count2 === total) {
          this.destination.complete();
          this.unsubscribe();
        }
      }
    };
    return TakeSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/every.js
  var EveryOperator = function() {
    function EveryOperator2(predicate, thisArg, source) {
      this.predicate = predicate;
      this.thisArg = thisArg;
      this.source = source;
    }
    EveryOperator2.prototype.call = function(observer, source) {
      return source.subscribe(
          new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator2;
  }();
  var EverySubscriber = function(_super) {
    __extends(EverySubscriber2, _super);
    function EverySubscriber2(destination, predicate, thisArg, source) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.thisArg = thisArg;
      _this.source = source;
      _this.index = 0;
      _this.thisArg = thisArg || _this;
      return _this;
    }
    EverySubscriber2.prototype.notifyComplete = function(everyValueMatch) {
      this.destination.next(everyValueMatch);
      this.destination.complete();
    };
    EverySubscriber2.prototype._next = function(value) {
      var result = false;
      try {
        result = this.predicate.call(this.thisArg, value, this.index++, this.source);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      if (!result) {
        this.notifyComplete(false);
      }
    };
    EverySubscriber2.prototype._complete = function() {
      this.notifyComplete(true);
    };
    return EverySubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/exhaust.js
  var SwitchFirstOperator = function() {
    function SwitchFirstOperator2() {}
    SwitchFirstOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator2;
  }();
  var SwitchFirstSubscriber = function(_super) {
    __extends(SwitchFirstSubscriber2, _super);
    function SwitchFirstSubscriber2(destination) {
      var _this = _super.call(this, destination) || this;
      _this.hasCompleted = false;
      _this.hasSubscription = false;
      return _this;
    }
    SwitchFirstSubscriber2.prototype._next = function(value) {
      if (!this.hasSubscription) {
        this.hasSubscription = true;
        this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));
      }
    };
    SwitchFirstSubscriber2.prototype._complete = function() {
      this.hasCompleted = true;
      if (!this.hasSubscription) {
        this.destination.complete();
      }
    };
    SwitchFirstSubscriber2.prototype.notifyComplete = function() {
      this.hasSubscription = false;
      if (this.hasCompleted) {
        this.destination.complete();
      }
    };
    return SwitchFirstSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/exhaustMap.js
  var ExhaustMapOperator = function() {
    function ExhaustMapOperator2(project) {
      this.project = project;
    }
    ExhaustMapOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhaustMapOperator2;
  }();
  var ExhaustMapSubscriber = function(_super) {
    __extends(ExhaustMapSubscriber2, _super);
    function ExhaustMapSubscriber2(destination, project) {
      var _this = _super.call(this, destination) || this;
      _this.project = project;
      _this.hasSubscription = false;
      _this.hasCompleted = false;
      _this.index = 0;
      return _this;
    }
    ExhaustMapSubscriber2.prototype._next = function(value) {
      if (!this.hasSubscription) {
        this.tryNext(value);
      }
    };
    ExhaustMapSubscriber2.prototype.tryNext = function(value) {
      var result;
      var index = this.index++;
      try {
        result = this.project(value, index);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.hasSubscription = true;
      this._innerSub(result);
    };
    ExhaustMapSubscriber2.prototype._innerSub = function(result) {
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      var innerSubscription = innerSubscribe(result, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        destination.add(innerSubscription);
      }
    };
    ExhaustMapSubscriber2.prototype._complete = function() {
      this.hasCompleted = true;
      if (!this.hasSubscription) {
        this.destination.complete();
      }
      this.unsubscribe();
    };
    ExhaustMapSubscriber2.prototype.notifyNext = function(innerValue) {
      this.destination.next(innerValue);
    };
    ExhaustMapSubscriber2.prototype.notifyError = function(err) {
      this.destination.error(err);
    };
    ExhaustMapSubscriber2.prototype.notifyComplete = function() {
      this.hasSubscription = false;
      if (this.hasCompleted) {
        this.destination.complete();
      }
    };
    return ExhaustMapSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/expand.js
  var ExpandOperator = function() {
    function ExpandOperator2(project, concurrent, scheduler) {
      this.project = project;
      this.concurrent = concurrent;
      this.scheduler = scheduler;
    }
    ExpandOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(
          new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator2;
  }();
  var ExpandSubscriber = function(_super) {
    __extends(ExpandSubscriber2, _super);
    function ExpandSubscriber2(destination, project, concurrent, scheduler) {
      var _this = _super.call(this, destination) || this;
      _this.project = project;
      _this.concurrent = concurrent;
      _this.scheduler = scheduler;
      _this.index = 0;
      _this.active = 0;
      _this.hasCompleted = false;
      if (concurrent < Number.POSITIVE_INFINITY) {
        _this.buffer = [];
      }
      return _this;
    }
    ExpandSubscriber2.dispatch = function(arg) {
      var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
      subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber2.prototype._next = function(value) {
      var destination = this.destination;
      if (destination.closed) {
        this._complete();
        return;
      }
      var index = this.index++;
      if (this.active < this.concurrent) {
        destination.next(value);
        try {
          var project = this.project;
          var result = project(value, index);
          if (!this.scheduler) {
            this.subscribeToProjection(result, value, index);
          } else {
            var state = {subscriber: this, result, value, index};
            var destination_1 = this.destination;
            destination_1.add(this.scheduler.schedule(ExpandSubscriber2.dispatch, 0, state));
          }
        } catch (e) {
          destination.error(e);
        }
      } else {
        this.buffer.push(value);
      }
    };
    ExpandSubscriber2.prototype.subscribeToProjection = function(result, value, index) {
      this.active++;
      var destination = this.destination;
      destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));
    };
    ExpandSubscriber2.prototype._complete = function() {
      this.hasCompleted = true;
      if (this.hasCompleted && this.active === 0) {
        this.destination.complete();
      }
      this.unsubscribe();
    };
    ExpandSubscriber2.prototype.notifyNext = function(innerValue) {
      this._next(innerValue);
    };
    ExpandSubscriber2.prototype.notifyComplete = function() {
      var buffer2 = this.buffer;
      this.active--;
      if (buffer2 && buffer2.length > 0) {
        this._next(buffer2.shift());
      }
      if (this.hasCompleted && this.active === 0) {
        this.destination.complete();
      }
    };
    return ExpandSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/finalize.js
  function finalize(callback) {
    return function(source) {
      return source.lift(new FinallyOperator(callback));
    };
  }
  var FinallyOperator = function() {
    function FinallyOperator2(callback) {
      this.callback = callback;
    }
    FinallyOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator2;
  }();
  var FinallySubscriber = function(_super) {
    __extends(FinallySubscriber2, _super);
    function FinallySubscriber2(destination, callback) {
      var _this = _super.call(this, destination) || this;
      _this.add(new Subscription(callback));
      return _this;
    }
    return FinallySubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/find.js
  var FindValueOperator = function() {
    function FindValueOperator2(predicate, source, yieldIndex, thisArg) {
      this.predicate = predicate;
      this.source = source;
      this.yieldIndex = yieldIndex;
      this.thisArg = thisArg;
    }
    FindValueOperator2.prototype.call = function(observer, source) {
      return source.subscribe(new FindValueSubscriber(
          observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator2;
  }();
  var FindValueSubscriber = function(_super) {
    __extends(FindValueSubscriber2, _super);
    function FindValueSubscriber2(destination, predicate, source, yieldIndex, thisArg) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.source = source;
      _this.yieldIndex = yieldIndex;
      _this.thisArg = thisArg;
      _this.index = 0;
      return _this;
    }
    FindValueSubscriber2.prototype.notifyComplete = function(value) {
      var destination = this.destination;
      destination.next(value);
      destination.complete();
      this.unsubscribe();
    };
    FindValueSubscriber2.prototype._next = function(value) {
      var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
      var index = this.index++;
      try {
        var result = predicate.call(thisArg || this, value, index, this.source);
        if (result) {
          this.notifyComplete(this.yieldIndex ? index : value);
        }
      } catch (err) {
        this.destination.error(err);
      }
    };
    FindValueSubscriber2.prototype._complete = function() {
      this.notifyComplete(this.yieldIndex ? -1 : void 0);
    };
    return FindValueSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/first.js
  function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(
          predicate ? filter(function(v, i) {
            return predicate(v, i, source);
          }) :
                      identity,
          take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
            return new EmptyError();
          }));
    };
  }

  // external/npm/node_modules/rxjs/_esm5/internal/operators/ignoreElements.js
  var IgnoreElementsOperator = function() {
    function IgnoreElementsOperator2() {}
    IgnoreElementsOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator2;
  }();
  var IgnoreElementsSubscriber = function(_super) {
    __extends(IgnoreElementsSubscriber2, _super);
    function IgnoreElementsSubscriber2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber2.prototype._next = function(unused) {};
    return IgnoreElementsSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/isEmpty.js
  var IsEmptyOperator = function() {
    function IsEmptyOperator2() {}
    IsEmptyOperator2.prototype.call = function(observer, source) {
      return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator2;
  }();
  var IsEmptySubscriber = function(_super) {
    __extends(IsEmptySubscriber2, _super);
    function IsEmptySubscriber2(destination) {
      return _super.call(this, destination) || this;
    }
    IsEmptySubscriber2.prototype.notifyComplete = function(isEmpty2) {
      var destination = this.destination;
      destination.next(isEmpty2);
      destination.complete();
    };
    IsEmptySubscriber2.prototype._next = function(value) {
      this.notifyComplete(false);
    };
    IsEmptySubscriber2.prototype._complete = function() {
      this.notifyComplete(true);
    };
    return IsEmptySubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/takeLast.js
  function takeLast(count2) {
    return function takeLastOperatorFunction(source) {
      if (count2 === 0) {
        return empty2();
      } else {
        return source.lift(new TakeLastOperator(count2));
      }
    };
  }
  var TakeLastOperator = function() {
    function TakeLastOperator2(total) {
      this.total = total;
      if (this.total < 0) {
        throw new ArgumentOutOfRangeError();
      }
    }
    TakeLastOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator2;
  }();
  var TakeLastSubscriber = function(_super) {
    __extends(TakeLastSubscriber2, _super);
    function TakeLastSubscriber2(destination, total) {
      var _this = _super.call(this, destination) || this;
      _this.total = total;
      _this.ring = new Array();
      _this.count = 0;
      return _this;
    }
    TakeLastSubscriber2.prototype._next = function(value) {
      var ring = this.ring;
      var total = this.total;
      var count2 = this.count++;
      if (ring.length < total) {
        ring.push(value);
      } else {
        var index = count2 % total;
        ring[index] = value;
      }
    };
    TakeLastSubscriber2.prototype._complete = function() {
      var destination = this.destination;
      var count2 = this.count;
      if (count2 > 0) {
        var total = this.count >= this.total ? this.total : this.count;
        var ring = this.ring;
        for (var i = 0; i < total; i++) {
          var idx = count2++ % total;
          destination.next(ring[idx]);
        }
      }
      destination.complete();
    };
    return TakeLastSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/last.js
  function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(
          predicate ? filter(function(v, i) {
            return predicate(v, i, source);
          }) :
                      identity,
          takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
            return new EmptyError();
          }));
    };
  }

  // external/npm/node_modules/rxjs/_esm5/internal/operators/mapTo.js
  var MapToOperator = function() {
    function MapToOperator2(value) {
      this.value = value;
    }
    MapToOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator2;
  }();
  var MapToSubscriber = function(_super) {
    __extends(MapToSubscriber2, _super);
    function MapToSubscriber2(destination, value) {
      var _this = _super.call(this, destination) || this;
      _this.value = value;
      return _this;
    }
    MapToSubscriber2.prototype._next = function(x) {
      this.destination.next(this.value);
    };
    return MapToSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/materialize.js
  var MaterializeOperator = function() {
    function MaterializeOperator2() {}
    MaterializeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator2;
  }();
  var MaterializeSubscriber = function(_super) {
    __extends(MaterializeSubscriber2, _super);
    function MaterializeSubscriber2(destination) {
      return _super.call(this, destination) || this;
    }
    MaterializeSubscriber2.prototype._next = function(value) {
      this.destination.next(Notification.createNext(value));
    };
    MaterializeSubscriber2.prototype._error = function(err) {
      var destination = this.destination;
      destination.next(Notification.createError(err));
      destination.complete();
    };
    MaterializeSubscriber2.prototype._complete = function() {
      var destination = this.destination;
      destination.next(Notification.createComplete());
      destination.complete();
    };
    return MaterializeSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/scan.js
  function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
      hasSeed = true;
    }
    return function scanOperatorFunction(source) {
      return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
  }
  var ScanOperator = function() {
    function ScanOperator2(accumulator, seed, hasSeed) {
      if (hasSeed === void 0) {
        hasSeed = false;
      }
      this.accumulator = accumulator;
      this.seed = seed;
      this.hasSeed = hasSeed;
    }
    ScanOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(
          new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator2;
  }();
  var ScanSubscriber = function(_super) {
    __extends(ScanSubscriber2, _super);
    function ScanSubscriber2(destination, accumulator, _seed, hasSeed) {
      var _this = _super.call(this, destination) || this;
      _this.accumulator = accumulator;
      _this._seed = _seed;
      _this.hasSeed = hasSeed;
      _this.index = 0;
      return _this;
    }
    Object.defineProperty(ScanSubscriber2.prototype, 'seed', {
      get: function() {
        return this._seed;
      },
      set: function(value) {
        this.hasSeed = true;
        this._seed = value;
      },
      enumerable: true,
      configurable: true
    });
    ScanSubscriber2.prototype._next = function(value) {
      if (!this.hasSeed) {
        this.seed = value;
        this.destination.next(value);
      } else {
        return this._tryNext(value);
      }
    };
    ScanSubscriber2.prototype._tryNext = function(value) {
      var index = this.index++;
      var result;
      try {
        result = this.accumulator(this.seed, value, index);
      } catch (err) {
        this.destination.error(err);
      }
      this.seed = result;
      this.destination.next(result);
    };
    return ScanSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/mergeScan.js
  var MergeScanOperator = function() {
    function MergeScanOperator2(accumulator, seed, concurrent) {
      this.accumulator = accumulator;
      this.seed = seed;
      this.concurrent = concurrent;
    }
    MergeScanOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(
          new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator2;
  }();
  var MergeScanSubscriber = function(_super) {
    __extends(MergeScanSubscriber2, _super);
    function MergeScanSubscriber2(destination, accumulator, acc, concurrent) {
      var _this = _super.call(this, destination) || this;
      _this.accumulator = accumulator;
      _this.acc = acc;
      _this.concurrent = concurrent;
      _this.hasValue = false;
      _this.hasCompleted = false;
      _this.buffer = [];
      _this.active = 0;
      _this.index = 0;
      return _this;
    }
    MergeScanSubscriber2.prototype._next = function(value) {
      if (this.active < this.concurrent) {
        var index = this.index++;
        var destination = this.destination;
        var ish = void 0;
        try {
          var accumulator = this.accumulator;
          ish = accumulator(this.acc, value, index);
        } catch (e) {
          return destination.error(e);
        }
        this.active++;
        this._innerSub(ish);
      } else {
        this.buffer.push(value);
      }
    };
    MergeScanSubscriber2.prototype._innerSub = function(ish) {
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      var innerSubscription = innerSubscribe(ish, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        destination.add(innerSubscription);
      }
    };
    MergeScanSubscriber2.prototype._complete = function() {
      this.hasCompleted = true;
      if (this.active === 0 && this.buffer.length === 0) {
        if (this.hasValue === false) {
          this.destination.next(this.acc);
        }
        this.destination.complete();
      }
      this.unsubscribe();
    };
    MergeScanSubscriber2.prototype.notifyNext = function(innerValue) {
      var destination = this.destination;
      this.acc = innerValue;
      this.hasValue = true;
      destination.next(innerValue);
    };
    MergeScanSubscriber2.prototype.notifyComplete = function() {
      var buffer2 = this.buffer;
      this.active--;
      if (buffer2.length > 0) {
        this._next(buffer2.shift());
      } else if (this.active === 0 && this.hasCompleted) {
        if (this.hasValue === false) {
          this.destination.next(this.acc);
        }
        this.destination.complete();
      }
    };
    return MergeScanSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/multicast.js
  function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
      var subjectFactory;
      if (typeof subjectOrSubjectFactory === 'function') {
        subjectFactory = subjectOrSubjectFactory;
      } else {
        subjectFactory = function subjectFactory2() {
          return subjectOrSubjectFactory;
        };
      }
      if (typeof selector === 'function') {
        return source.lift(new MulticastOperator(subjectFactory, selector));
      }
      var connectable = Object.create(source, connectableObservableDescriptor);
      connectable.source = source;
      connectable.subjectFactory = subjectFactory;
      return connectable;
    };
  }
  var MulticastOperator = function() {
    function MulticastOperator2(subjectFactory, selector) {
      this.subjectFactory = subjectFactory;
      this.selector = selector;
    }
    MulticastOperator2.prototype.call = function(subscriber, source) {
      var selector = this.selector;
      var subject = this.subjectFactory();
      var subscription = selector(subject).subscribe(subscriber);
      subscription.add(source.subscribe(subject));
      return subscription;
    };
    return MulticastOperator2;
  }();

  // external/npm/node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js
  var OnErrorResumeNextOperator = function() {
    function OnErrorResumeNextOperator2(nextSources) {
      this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator2;
  }();
  var OnErrorResumeNextSubscriber = function(_super) {
    __extends(OnErrorResumeNextSubscriber2, _super);
    function OnErrorResumeNextSubscriber2(destination, nextSources) {
      var _this = _super.call(this, destination) || this;
      _this.destination = destination;
      _this.nextSources = nextSources;
      return _this;
    }
    OnErrorResumeNextSubscriber2.prototype.notifyError = function() {
      this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber2.prototype.notifyComplete = function() {
      this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber2.prototype._error = function(err) {
      this.subscribeToNextSource();
      this.unsubscribe();
    };
    OnErrorResumeNextSubscriber2.prototype._complete = function() {
      this.subscribeToNextSource();
      this.unsubscribe();
    };
    OnErrorResumeNextSubscriber2.prototype.subscribeToNextSource = function() {
      var next = this.nextSources.shift();
      if (!!next) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(next, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      } else {
        this.destination.complete();
      }
    };
    return OnErrorResumeNextSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/pairwise.js
  var PairwiseOperator = function() {
    function PairwiseOperator2() {}
    PairwiseOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator2;
  }();
  var PairwiseSubscriber = function(_super) {
    __extends(PairwiseSubscriber2, _super);
    function PairwiseSubscriber2(destination) {
      var _this = _super.call(this, destination) || this;
      _this.hasPrev = false;
      return _this;
    }
    PairwiseSubscriber2.prototype._next = function(value) {
      var pair;
      if (this.hasPrev) {
        pair = [this.prev, value];
      } else {
        this.hasPrev = true;
      }
      this.prev = value;
      if (pair) {
        this.destination.next(pair);
      }
    };
    return PairwiseSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/repeat.js
  var RepeatOperator = function() {
    function RepeatOperator2(count2, source) {
      this.count = count2;
      this.source = source;
    }
    RepeatOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator2;
  }();
  var RepeatSubscriber = function(_super) {
    __extends(RepeatSubscriber2, _super);
    function RepeatSubscriber2(destination, count2, source) {
      var _this = _super.call(this, destination) || this;
      _this.count = count2;
      _this.source = source;
      return _this;
    }
    RepeatSubscriber2.prototype.complete = function() {
      if (!this.isStopped) {
        var _a = this, source = _a.source, count2 = _a.count;
        if (count2 === 0) {
          return _super.prototype.complete.call(this);
        } else if (count2 > -1) {
          this.count = count2 - 1;
        }
        source.subscribe(this._unsubscribeAndRecycle());
      }
    };
    return RepeatSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/repeatWhen.js
  var RepeatWhenOperator = function() {
    function RepeatWhenOperator2(notifier) {
      this.notifier = notifier;
    }
    RepeatWhenOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator2;
  }();
  var RepeatWhenSubscriber = function(_super) {
    __extends(RepeatWhenSubscriber2, _super);
    function RepeatWhenSubscriber2(destination, notifier, source) {
      var _this = _super.call(this, destination) || this;
      _this.notifier = notifier;
      _this.source = source;
      _this.sourceIsBeingSubscribedTo = true;
      return _this;
    }
    RepeatWhenSubscriber2.prototype.notifyNext = function() {
      this.sourceIsBeingSubscribedTo = true;
      this.source.subscribe(this);
    };
    RepeatWhenSubscriber2.prototype.notifyComplete = function() {
      if (this.sourceIsBeingSubscribedTo === false) {
        return _super.prototype.complete.call(this);
      }
    };
    RepeatWhenSubscriber2.prototype.complete = function() {
      this.sourceIsBeingSubscribedTo = false;
      if (!this.isStopped) {
        if (!this.retries) {
          this.subscribeToRetries();
        }
        if (!this.retriesSubscription || this.retriesSubscription.closed) {
          return _super.prototype.complete.call(this);
        }
        this._unsubscribeAndRecycle();
        this.notifications.next(void 0);
      }
    };
    RepeatWhenSubscriber2.prototype._unsubscribe = function() {
      var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
      if (notifications) {
        notifications.unsubscribe();
        this.notifications = void 0;
      }
      if (retriesSubscription) {
        retriesSubscription.unsubscribe();
        this.retriesSubscription = void 0;
      }
      this.retries = void 0;
    };
    RepeatWhenSubscriber2.prototype._unsubscribeAndRecycle = function() {
      var _unsubscribe = this._unsubscribe;
      this._unsubscribe = null;
      _super.prototype._unsubscribeAndRecycle.call(this);
      this._unsubscribe = _unsubscribe;
      return this;
    };
    RepeatWhenSubscriber2.prototype.subscribeToRetries = function() {
      this.notifications = new Subject();
      var retries;
      try {
        var notifier = this.notifier;
        retries = notifier(this.notifications);
      } catch (e) {
        return _super.prototype.complete.call(this);
      }
      this.retries = retries;
      this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
    };
    return RepeatWhenSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/retry.js
  var RetryOperator = function() {
    function RetryOperator2(count2, source) {
      this.count = count2;
      this.source = source;
    }
    RetryOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator2;
  }();
  var RetrySubscriber = function(_super) {
    __extends(RetrySubscriber2, _super);
    function RetrySubscriber2(destination, count2, source) {
      var _this = _super.call(this, destination) || this;
      _this.count = count2;
      _this.source = source;
      return _this;
    }
    RetrySubscriber2.prototype.error = function(err) {
      if (!this.isStopped) {
        var _a = this, source = _a.source, count2 = _a.count;
        if (count2 === 0) {
          return _super.prototype.error.call(this, err);
        } else if (count2 > -1) {
          this.count = count2 - 1;
        }
        source.subscribe(this._unsubscribeAndRecycle());
      }
    };
    return RetrySubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/retryWhen.js
  var RetryWhenOperator = function() {
    function RetryWhenOperator2(notifier, source) {
      this.notifier = notifier;
      this.source = source;
    }
    RetryWhenOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator2;
  }();
  var RetryWhenSubscriber = function(_super) {
    __extends(RetryWhenSubscriber2, _super);
    function RetryWhenSubscriber2(destination, notifier, source) {
      var _this = _super.call(this, destination) || this;
      _this.notifier = notifier;
      _this.source = source;
      return _this;
    }
    RetryWhenSubscriber2.prototype.error = function(err) {
      if (!this.isStopped) {
        var errors = this.errors;
        var retries = this.retries;
        var retriesSubscription = this.retriesSubscription;
        if (!retries) {
          errors = new Subject();
          try {
            var notifier = this.notifier;
            retries = notifier(errors);
          } catch (e) {
            return _super.prototype.error.call(this, e);
          }
          retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
        } else {
          this.errors = void 0;
          this.retriesSubscription = void 0;
        }
        this._unsubscribeAndRecycle();
        this.errors = errors;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        errors.next(err);
      }
    };
    RetryWhenSubscriber2.prototype._unsubscribe = function() {
      var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
      if (errors) {
        errors.unsubscribe();
        this.errors = void 0;
      }
      if (retriesSubscription) {
        retriesSubscription.unsubscribe();
        this.retriesSubscription = void 0;
      }
      this.retries = void 0;
    };
    RetryWhenSubscriber2.prototype.notifyNext = function() {
      var _unsubscribe = this._unsubscribe;
      this._unsubscribe = null;
      this._unsubscribeAndRecycle();
      this._unsubscribe = _unsubscribe;
      this.source.subscribe(this);
    };
    return RetryWhenSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/sample.js
  var SampleOperator = function() {
    function SampleOperator2(notifier) {
      this.notifier = notifier;
    }
    SampleOperator2.prototype.call = function(subscriber, source) {
      var sampleSubscriber = new SampleSubscriber(subscriber);
      var subscription = source.subscribe(sampleSubscriber);
      subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));
      return subscription;
    };
    return SampleOperator2;
  }();
  var SampleSubscriber = function(_super) {
    __extends(SampleSubscriber2, _super);
    function SampleSubscriber2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.hasValue = false;
      return _this;
    }
    SampleSubscriber2.prototype._next = function(value) {
      this.value = value;
      this.hasValue = true;
    };
    SampleSubscriber2.prototype.notifyNext = function() {
      this.emitValue();
    };
    SampleSubscriber2.prototype.notifyComplete = function() {
      this.emitValue();
    };
    SampleSubscriber2.prototype.emitValue = function() {
      if (this.hasValue) {
        this.hasValue = false;
        this.destination.next(this.value);
      }
    };
    return SampleSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/sampleTime.js
  var SampleTimeOperator = function() {
    function SampleTimeOperator2(period, scheduler) {
      this.period = period;
      this.scheduler = scheduler;
    }
    SampleTimeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator2;
  }();
  var SampleTimeSubscriber = function(_super) {
    __extends(SampleTimeSubscriber2, _super);
    function SampleTimeSubscriber2(destination, period, scheduler) {
      var _this = _super.call(this, destination) || this;
      _this.period = period;
      _this.scheduler = scheduler;
      _this.hasValue = false;
      _this.add(scheduler.schedule(dispatchNotification, period, {subscriber: _this, period}));
      return _this;
    }
    SampleTimeSubscriber2.prototype._next = function(value) {
      this.lastValue = value;
      this.hasValue = true;
    };
    SampleTimeSubscriber2.prototype.notifyNext = function() {
      if (this.hasValue) {
        this.hasValue = false;
        this.destination.next(this.lastValue);
      }
    };
    return SampleTimeSubscriber2;
  }(Subscriber);
  function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
  }

  // external/npm/node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js
  var SequenceEqualOperator = function() {
    function SequenceEqualOperator2(compareTo, comparator) {
      this.compareTo = compareTo;
      this.comparator = comparator;
    }
    SequenceEqualOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(
          new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
    };
    return SequenceEqualOperator2;
  }();
  var SequenceEqualSubscriber = function(_super) {
    __extends(SequenceEqualSubscriber2, _super);
    function SequenceEqualSubscriber2(destination, compareTo, comparator) {
      var _this = _super.call(this, destination) || this;
      _this.compareTo = compareTo;
      _this.comparator = comparator;
      _this._a = [];
      _this._b = [];
      _this._oneComplete = false;
      _this.destination.add(
          compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
      return _this;
    }
    SequenceEqualSubscriber2.prototype._next = function(value) {
      if (this._oneComplete && this._b.length === 0) {
        this.emit(false);
      } else {
        this._a.push(value);
        this.checkValues();
      }
    };
    SequenceEqualSubscriber2.prototype._complete = function() {
      if (this._oneComplete) {
        this.emit(this._a.length === 0 && this._b.length === 0);
      } else {
        this._oneComplete = true;
      }
      this.unsubscribe();
    };
    SequenceEqualSubscriber2.prototype.checkValues = function() {
      var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator;
      while (_a.length > 0 && _b.length > 0) {
        var a = _a.shift();
        var b = _b.shift();
        var areEqual = false;
        try {
          areEqual = comparator ? comparator(a, b) : a === b;
        } catch (e) {
          this.destination.error(e);
        }
        if (!areEqual) {
          this.emit(false);
        }
      }
    };
    SequenceEqualSubscriber2.prototype.emit = function(value) {
      var destination = this.destination;
      destination.next(value);
      destination.complete();
    };
    SequenceEqualSubscriber2.prototype.nextB = function(value) {
      if (this._oneComplete && this._a.length === 0) {
        this.emit(false);
      } else {
        this._b.push(value);
        this.checkValues();
      }
    };
    SequenceEqualSubscriber2.prototype.completeB = function() {
      if (this._oneComplete) {
        this.emit(this._a.length === 0 && this._b.length === 0);
      } else {
        this._oneComplete = true;
      }
    };
    return SequenceEqualSubscriber2;
  }(Subscriber);
  var SequenceEqualCompareToSubscriber = function(_super) {
    __extends(SequenceEqualCompareToSubscriber2, _super);
    function SequenceEqualCompareToSubscriber2(destination, parent) {
      var _this = _super.call(this, destination) || this;
      _this.parent = parent;
      return _this;
    }
    SequenceEqualCompareToSubscriber2.prototype._next = function(value) {
      this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber2.prototype._error = function(err) {
      this.parent.error(err);
      this.unsubscribe();
    };
    SequenceEqualCompareToSubscriber2.prototype._complete = function() {
      this.parent.completeB();
      this.unsubscribe();
    };
    return SequenceEqualCompareToSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/share.js
  function shareSubjectFactory() {
    return new Subject();
  }
  function share() {
    return function(source) {
      return refCount()(multicast(shareSubjectFactory)(source));
    };
  }

  // external/npm/node_modules/rxjs/_esm5/internal/operators/single.js
  var SingleOperator = function() {
    function SingleOperator2(predicate, source) {
      this.predicate = predicate;
      this.source = source;
    }
    SingleOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator2;
  }();
  var SingleSubscriber = function(_super) {
    __extends(SingleSubscriber2, _super);
    function SingleSubscriber2(destination, predicate, source) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.source = source;
      _this.seenValue = false;
      _this.index = 0;
      return _this;
    }
    SingleSubscriber2.prototype.applySingleValue = function(value) {
      if (this.seenValue) {
        this.destination.error('Sequence contains more than one element');
      } else {
        this.seenValue = true;
        this.singleValue = value;
      }
    };
    SingleSubscriber2.prototype._next = function(value) {
      var index = this.index++;
      if (this.predicate) {
        this.tryNext(value, index);
      } else {
        this.applySingleValue(value);
      }
    };
    SingleSubscriber2.prototype.tryNext = function(value, index) {
      try {
        if (this.predicate(value, index, this.source)) {
          this.applySingleValue(value);
        }
      } catch (err) {
        this.destination.error(err);
      }
    };
    SingleSubscriber2.prototype._complete = function() {
      var destination = this.destination;
      if (this.index > 0) {
        destination.next(this.seenValue ? this.singleValue : void 0);
        destination.complete();
      } else {
        destination.error(new EmptyError());
      }
    };
    return SingleSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/skip.js
  var SkipOperator = function() {
    function SkipOperator2(total) {
      this.total = total;
    }
    SkipOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator2;
  }();
  var SkipSubscriber = function(_super) {
    __extends(SkipSubscriber2, _super);
    function SkipSubscriber2(destination, total) {
      var _this = _super.call(this, destination) || this;
      _this.total = total;
      _this.count = 0;
      return _this;
    }
    SkipSubscriber2.prototype._next = function(x) {
      if (++this.count > this.total) {
        this.destination.next(x);
      }
    };
    return SkipSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/skipLast.js
  var SkipLastOperator = function() {
    function SkipLastOperator2(_skipCount) {
      this._skipCount = _skipCount;
      if (this._skipCount < 0) {
        throw new ArgumentOutOfRangeError();
      }
    }
    SkipLastOperator2.prototype.call = function(subscriber, source) {
      if (this._skipCount === 0) {
        return source.subscribe(new Subscriber(subscriber));
      } else {
        return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
      }
    };
    return SkipLastOperator2;
  }();
  var SkipLastSubscriber = function(_super) {
    __extends(SkipLastSubscriber2, _super);
    function SkipLastSubscriber2(destination, _skipCount) {
      var _this = _super.call(this, destination) || this;
      _this._skipCount = _skipCount;
      _this._count = 0;
      _this._ring = new Array(_skipCount);
      return _this;
    }
    SkipLastSubscriber2.prototype._next = function(value) {
      var skipCount = this._skipCount;
      var count2 = this._count++;
      if (count2 < skipCount) {
        this._ring[count2] = value;
      } else {
        var currentIndex = count2 % skipCount;
        var ring = this._ring;
        var oldValue = ring[currentIndex];
        ring[currentIndex] = value;
        this.destination.next(oldValue);
      }
    };
    return SkipLastSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/skipUntil.js
  var SkipUntilOperator = function() {
    function SkipUntilOperator2(notifier) {
      this.notifier = notifier;
    }
    SkipUntilOperator2.prototype.call = function(destination, source) {
      return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
    };
    return SkipUntilOperator2;
  }();
  var SkipUntilSubscriber = function(_super) {
    __extends(SkipUntilSubscriber2, _super);
    function SkipUntilSubscriber2(destination, notifier) {
      var _this = _super.call(this, destination) || this;
      _this.hasValue = false;
      var innerSubscriber = new SimpleInnerSubscriber(_this);
      _this.add(innerSubscriber);
      _this.innerSubscription = innerSubscriber;
      var innerSubscription = innerSubscribe(notifier, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        _this.add(innerSubscription);
        _this.innerSubscription = innerSubscription;
      }
      return _this;
    }
    SkipUntilSubscriber2.prototype._next = function(value) {
      if (this.hasValue) {
        _super.prototype._next.call(this, value);
      }
    };
    SkipUntilSubscriber2.prototype.notifyNext = function() {
      this.hasValue = true;
      if (this.innerSubscription) {
        this.innerSubscription.unsubscribe();
      }
    };
    SkipUntilSubscriber2.prototype.notifyComplete = function() {};
    return SkipUntilSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/skipWhile.js
  var SkipWhileOperator = function() {
    function SkipWhileOperator2(predicate) {
      this.predicate = predicate;
    }
    SkipWhileOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator2;
  }();
  var SkipWhileSubscriber = function(_super) {
    __extends(SkipWhileSubscriber2, _super);
    function SkipWhileSubscriber2(destination, predicate) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.skipping = true;
      _this.index = 0;
      return _this;
    }
    SkipWhileSubscriber2.prototype._next = function(value) {
      var destination = this.destination;
      if (this.skipping) {
        this.tryCallPredicate(value);
      }
      if (!this.skipping) {
        destination.next(value);
      }
    };
    SkipWhileSubscriber2.prototype.tryCallPredicate = function(value) {
      try {
        var result = this.predicate(value, this.index++);
        this.skipping = Boolean(result);
      } catch (err) {
        this.destination.error(err);
      }
    };
    return SkipWhileSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/startWith.js
  function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      array[_i] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler(scheduler)) {
      array.pop();
      return function(source) {
        return concat(array, source, scheduler);
      };
    } else {
      return function(source) {
        return concat(array, source);
      };
    }
  }

  // external/npm/node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js
  var SubscribeOnObservable = function(_super) {
    __extends(SubscribeOnObservable2, _super);
    function SubscribeOnObservable2(source, delayTime, scheduler) {
      if (delayTime === void 0) {
        delayTime = 0;
      }
      if (scheduler === void 0) {
        scheduler = asap;
      }
      var _this = _super.call(this) || this;
      _this.source = source;
      _this.delayTime = delayTime;
      _this.scheduler = scheduler;
      if (!isNumeric(delayTime) || delayTime < 0) {
        _this.delayTime = 0;
      }
      if (!scheduler || typeof scheduler.schedule !== 'function') {
        _this.scheduler = asap;
      }
      return _this;
    }
    SubscribeOnObservable2.create = function(source, delay2, scheduler) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (scheduler === void 0) {
        scheduler = asap;
      }
      return new SubscribeOnObservable2(source, delay2, scheduler);
    };
    SubscribeOnObservable2.dispatch = function(arg) {
      var source = arg.source, subscriber = arg.subscriber;
      return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable2.prototype._subscribe = function(subscriber) {
      var delay2 = this.delayTime;
      var source = this.source;
      var scheduler = this.scheduler;
      return scheduler.schedule(SubscribeOnObservable2.dispatch, delay2, {source, subscriber});
    };
    return SubscribeOnObservable2;
  }(Observable);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/subscribeOn.js
  var SubscribeOnOperator = function() {
    function SubscribeOnOperator2(scheduler, delay2) {
      this.scheduler = scheduler;
      this.delay = delay2;
    }
    SubscribeOnOperator2.prototype.call = function(subscriber, source) {
      return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator2;
  }();

  // external/npm/node_modules/rxjs/_esm5/internal/operators/switchMap.js
  function switchMap(project, resultSelector) {
    if (typeof resultSelector === 'function') {
      return function(source) {
        return source.pipe(switchMap(function(a, i) {
          return from(project(a, i)).pipe(map(function(b, ii) {
            return resultSelector(a, b, i, ii);
          }));
        }));
      };
    }
    return function(source) {
      return source.lift(new SwitchMapOperator(project));
    };
  }
  var SwitchMapOperator = function() {
    function SwitchMapOperator2(project) {
      this.project = project;
    }
    SwitchMapOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator2;
  }();
  var SwitchMapSubscriber = function(_super) {
    __extends(SwitchMapSubscriber2, _super);
    function SwitchMapSubscriber2(destination, project) {
      var _this = _super.call(this, destination) || this;
      _this.project = project;
      _this.index = 0;
      return _this;
    }
    SwitchMapSubscriber2.prototype._next = function(value) {
      var result;
      var index = this.index++;
      try {
        result = this.project(value, index);
      } catch (error) {
        this.destination.error(error);
        return;
      }
      this._innerSub(result);
    };
    SwitchMapSubscriber2.prototype._innerSub = function(result) {
      var innerSubscription = this.innerSubscription;
      if (innerSubscription) {
        innerSubscription.unsubscribe();
      }
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      this.innerSubscription = innerSubscribe(result, innerSubscriber);
      if (this.innerSubscription !== innerSubscriber) {
        destination.add(this.innerSubscription);
      }
    };
    SwitchMapSubscriber2.prototype._complete = function() {
      var innerSubscription = this.innerSubscription;
      if (!innerSubscription || innerSubscription.closed) {
        _super.prototype._complete.call(this);
      }
      this.unsubscribe();
    };
    SwitchMapSubscriber2.prototype._unsubscribe = function() {
      this.innerSubscription = void 0;
    };
    SwitchMapSubscriber2.prototype.notifyComplete = function() {
      this.innerSubscription = void 0;
      if (this.isStopped) {
        _super.prototype._complete.call(this);
      }
    };
    SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
      this.destination.next(innerValue);
    };
    return SwitchMapSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/takeUntil.js
  var TakeUntilOperator = function() {
    function TakeUntilOperator2(notifier) {
      this.notifier = notifier;
    }
    TakeUntilOperator2.prototype.call = function(subscriber, source) {
      var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
      var notifierSubscription =
          innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
      if (notifierSubscription && !takeUntilSubscriber.seenValue) {
        takeUntilSubscriber.add(notifierSubscription);
        return source.subscribe(takeUntilSubscriber);
      }
      return takeUntilSubscriber;
    };
    return TakeUntilOperator2;
  }();
  var TakeUntilSubscriber = function(_super) {
    __extends(TakeUntilSubscriber2, _super);
    function TakeUntilSubscriber2(destination) {
      var _this = _super.call(this, destination) || this;
      _this.seenValue = false;
      return _this;
    }
    TakeUntilSubscriber2.prototype.notifyNext = function() {
      this.seenValue = true;
      this.complete();
    };
    TakeUntilSubscriber2.prototype.notifyComplete = function() {};
    return TakeUntilSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/takeWhile.js
  var TakeWhileOperator = function() {
    function TakeWhileOperator2(predicate, inclusive) {
      this.predicate = predicate;
      this.inclusive = inclusive;
    }
    TakeWhileOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
    };
    return TakeWhileOperator2;
  }();
  var TakeWhileSubscriber = function(_super) {
    __extends(TakeWhileSubscriber2, _super);
    function TakeWhileSubscriber2(destination, predicate, inclusive) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.inclusive = inclusive;
      _this.index = 0;
      return _this;
    }
    TakeWhileSubscriber2.prototype._next = function(value) {
      var destination = this.destination;
      var result;
      try {
        result = this.predicate(value, this.index++);
      } catch (err) {
        destination.error(err);
        return;
      }
      this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber2.prototype.nextOrComplete = function(value, predicateResult) {
      var destination = this.destination;
      if (Boolean(predicateResult)) {
        destination.next(value);
      } else {
        if (this.inclusive) {
          destination.next(value);
        }
        destination.complete();
      }
    };
    return TakeWhileSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/tap.js
  function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
      return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
  }
  var DoOperator = function() {
    function DoOperator2(nextOrObserver, error, complete) {
      this.nextOrObserver = nextOrObserver;
      this.error = error;
      this.complete = complete;
    }
    DoOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(
          new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator2;
  }();
  var TapSubscriber = function(_super) {
    __extends(TapSubscriber2, _super);
    function TapSubscriber2(destination, observerOrNext, error, complete) {
      var _this = _super.call(this, destination) || this;
      _this._tapNext = noop;
      _this._tapError = noop;
      _this._tapComplete = noop;
      _this._tapError = error || noop;
      _this._tapComplete = complete || noop;
      if (isFunction(observerOrNext)) {
        _this._context = _this;
        _this._tapNext = observerOrNext;
      } else if (observerOrNext) {
        _this._context = observerOrNext;
        _this._tapNext = observerOrNext.next || noop;
        _this._tapError = observerOrNext.error || noop;
        _this._tapComplete = observerOrNext.complete || noop;
      }
      return _this;
    }
    TapSubscriber2.prototype._next = function(value) {
      try {
        this._tapNext.call(this._context, value);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.destination.next(value);
    };
    TapSubscriber2.prototype._error = function(err) {
      try {
        this._tapError.call(this._context, err);
      } catch (err2) {
        this.destination.error(err2);
        return;
      }
      this.destination.error(err);
    };
    TapSubscriber2.prototype._complete = function() {
      try {
        this._tapComplete.call(this._context);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      return this.destination.complete();
    };
    return TapSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/throttle.js
  var ThrottleOperator = function() {
    function ThrottleOperator2(durationSelector, leading, trailing) {
      this.durationSelector = durationSelector;
      this.leading = leading;
      this.trailing = trailing;
    }
    ThrottleOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(
          new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator2;
  }();
  var ThrottleSubscriber = function(_super) {
    __extends(ThrottleSubscriber2, _super);
    function ThrottleSubscriber2(destination, durationSelector, _leading, _trailing) {
      var _this = _super.call(this, destination) || this;
      _this.destination = destination;
      _this.durationSelector = durationSelector;
      _this._leading = _leading;
      _this._trailing = _trailing;
      _this._hasValue = false;
      return _this;
    }
    ThrottleSubscriber2.prototype._next = function(value) {
      this._hasValue = true;
      this._sendValue = value;
      if (!this._throttled) {
        if (this._leading) {
          this.send();
        } else {
          this.throttle(value);
        }
      }
    };
    ThrottleSubscriber2.prototype.send = function() {
      var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
      if (_hasValue) {
        this.destination.next(_sendValue);
        this.throttle(_sendValue);
      }
      this._hasValue = false;
      this._sendValue = void 0;
    };
    ThrottleSubscriber2.prototype.throttle = function(value) {
      var duration = this.tryDurationSelector(value);
      if (!!duration) {
        this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
      }
    };
    ThrottleSubscriber2.prototype.tryDurationSelector = function(value) {
      try {
        return this.durationSelector(value);
      } catch (err) {
        this.destination.error(err);
        return null;
      }
    };
    ThrottleSubscriber2.prototype.throttlingDone = function() {
      var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
      if (_throttled) {
        _throttled.unsubscribe();
      }
      this._throttled = void 0;
      if (_trailing) {
        this.send();
      }
    };
    ThrottleSubscriber2.prototype.notifyNext = function() {
      this.throttlingDone();
    };
    ThrottleSubscriber2.prototype.notifyComplete = function() {
      this.throttlingDone();
    };
    return ThrottleSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/throttleTime.js
  var ThrottleTimeOperator = function() {
    function ThrottleTimeOperator2(duration, scheduler, leading, trailing) {
      this.duration = duration;
      this.scheduler = scheduler;
      this.leading = leading;
      this.trailing = trailing;
    }
    ThrottleTimeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new ThrottleTimeSubscriber(
          subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator2;
  }();
  var ThrottleTimeSubscriber = function(_super) {
    __extends(ThrottleTimeSubscriber2, _super);
    function ThrottleTimeSubscriber2(destination, duration, scheduler, leading, trailing) {
      var _this = _super.call(this, destination) || this;
      _this.duration = duration;
      _this.scheduler = scheduler;
      _this.leading = leading;
      _this.trailing = trailing;
      _this._hasTrailingValue = false;
      _this._trailingValue = null;
      return _this;
    }
    ThrottleTimeSubscriber2.prototype._next = function(value) {
      if (this.throttled) {
        if (this.trailing) {
          this._trailingValue = value;
          this._hasTrailingValue = true;
        }
      } else {
        this.add(
            this.throttled =
                this.scheduler.schedule(dispatchNext2, this.duration, {subscriber: this}));
        if (this.leading) {
          this.destination.next(value);
        } else if (this.trailing) {
          this._trailingValue = value;
          this._hasTrailingValue = true;
        }
      }
    };
    ThrottleTimeSubscriber2.prototype._complete = function() {
      if (this._hasTrailingValue) {
        this.destination.next(this._trailingValue);
        this.destination.complete();
      } else {
        this.destination.complete();
      }
    };
    ThrottleTimeSubscriber2.prototype.clearThrottle = function() {
      var throttled = this.throttled;
      if (throttled) {
        if (this.trailing && this._hasTrailingValue) {
          this.destination.next(this._trailingValue);
          this._trailingValue = null;
          this._hasTrailingValue = false;
        }
        throttled.unsubscribe();
        this.remove(throttled);
        this.throttled = null;
      }
    };
    return ThrottleTimeSubscriber2;
  }(Subscriber);
  function dispatchNext2(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
  }

  // external/npm/node_modules/rxjs/_esm5/internal/operators/timeInterval.js
  var TimeInterval = function() {
    function TimeInterval2(value, interval2) {
      this.value = value;
      this.interval = interval2;
    }
    return TimeInterval2;
  }();

  // external/npm/node_modules/rxjs/_esm5/internal/operators/timeoutWith.js
  var TimeoutWithOperator = function() {
    function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler) {
      this.waitFor = waitFor;
      this.absoluteTimeout = absoluteTimeout;
      this.withObservable = withObservable;
      this.scheduler = scheduler;
    }
    TimeoutWithOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new TimeoutWithSubscriber(
          subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator2;
  }();
  var TimeoutWithSubscriber = function(_super) {
    __extends(TimeoutWithSubscriber2, _super);
    function TimeoutWithSubscriber2(
        destination, absoluteTimeout, waitFor, withObservable, scheduler) {
      var _this = _super.call(this, destination) || this;
      _this.absoluteTimeout = absoluteTimeout;
      _this.waitFor = waitFor;
      _this.withObservable = withObservable;
      _this.scheduler = scheduler;
      _this.scheduleTimeout();
      return _this;
    }
    TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
      var withObservable = subscriber.withObservable;
      subscriber._unsubscribeAndRecycle();
      subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
    };
    TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
      var action = this.action;
      if (action) {
        this.action = action.schedule(this, this.waitFor);
      } else {
        this.add(
            this.action = this.scheduler.schedule(
                TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
      }
    };
    TimeoutWithSubscriber2.prototype._next = function(value) {
      if (!this.absoluteTimeout) {
        this.scheduleTimeout();
      }
      _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber2.prototype._unsubscribe = function() {
      this.action = void 0;
      this.scheduler = null;
      this.withObservable = null;
    };
    return TimeoutWithSubscriber2;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/timestamp.js
  var Timestamp = function() {
    function Timestamp2(value, timestamp2) {
      this.value = value;
      this.timestamp = timestamp2;
    }
    return Timestamp2;
  }();

  // external/npm/node_modules/rxjs/_esm5/internal/operators/window.js
  var WindowOperator = function() {
    function WindowOperator3(windowBoundaries) {
      this.windowBoundaries = windowBoundaries;
    }
    WindowOperator3.prototype.call = function(subscriber, source) {
      var windowSubscriber = new WindowSubscriber(subscriber);
      var sourceSubscription = source.subscribe(windowSubscriber);
      if (!sourceSubscription.closed) {
        windowSubscriber.add(
            innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));
      }
      return sourceSubscription;
    };
    return WindowOperator3;
  }();
  var WindowSubscriber = function(_super) {
    __extends(WindowSubscriber3, _super);
    function WindowSubscriber3(destination) {
      var _this = _super.call(this, destination) || this;
      _this.window = new Subject();
      destination.next(_this.window);
      return _this;
    }
    WindowSubscriber3.prototype.notifyNext = function() {
      this.openWindow();
    };
    WindowSubscriber3.prototype.notifyError = function(error) {
      this._error(error);
    };
    WindowSubscriber3.prototype.notifyComplete = function() {
      this._complete();
    };
    WindowSubscriber3.prototype._next = function(value) {
      this.window.next(value);
    };
    WindowSubscriber3.prototype._error = function(err) {
      this.window.error(err);
      this.destination.error(err);
    };
    WindowSubscriber3.prototype._complete = function() {
      this.window.complete();
      this.destination.complete();
    };
    WindowSubscriber3.prototype._unsubscribe = function() {
      this.window = null;
    };
    WindowSubscriber3.prototype.openWindow = function() {
      var prevWindow = this.window;
      if (prevWindow) {
        prevWindow.complete();
      }
      var destination = this.destination;
      var newWindow = this.window = new Subject();
      destination.next(newWindow);
    };
    return WindowSubscriber3;
  }(SimpleOuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/windowCount.js
  var WindowCountOperator = function() {
    function WindowCountOperator2(windowSize, startWindowEvery) {
      this.windowSize = windowSize;
      this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(
          new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator2;
  }();
  var WindowCountSubscriber = function(_super) {
    __extends(WindowCountSubscriber2, _super);
    function WindowCountSubscriber2(destination, windowSize, startWindowEvery) {
      var _this = _super.call(this, destination) || this;
      _this.destination = destination;
      _this.windowSize = windowSize;
      _this.startWindowEvery = startWindowEvery;
      _this.windows = [new Subject()];
      _this.count = 0;
      destination.next(_this.windows[0]);
      return _this;
    }
    WindowCountSubscriber2.prototype._next = function(value) {
      var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
      var destination = this.destination;
      var windowSize = this.windowSize;
      var windows = this.windows;
      var len = windows.length;
      for (var i = 0; i < len && !this.closed; i++) {
        windows[i].next(value);
      }
      var c = this.count - windowSize + 1;
      if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
        windows.shift().complete();
      }
      if (++this.count % startWindowEvery === 0 && !this.closed) {
        var window_1 = new Subject();
        windows.push(window_1);
        destination.next(window_1);
      }
    };
    WindowCountSubscriber2.prototype._error = function(err) {
      var windows = this.windows;
      if (windows) {
        while (windows.length > 0 && !this.closed) {
          windows.shift().error(err);
        }
      }
      this.destination.error(err);
    };
    WindowCountSubscriber2.prototype._complete = function() {
      var windows = this.windows;
      if (windows) {
        while (windows.length > 0 && !this.closed) {
          windows.shift().complete();
        }
      }
      this.destination.complete();
    };
    WindowCountSubscriber2.prototype._unsubscribe = function() {
      this.count = 0;
      this.windows = null;
    };
    return WindowCountSubscriber2;
  }(Subscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/windowTime.js
  var WindowTimeOperator = function() {
    function WindowTimeOperator2(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
      this.windowTimeSpan = windowTimeSpan;
      this.windowCreationInterval = windowCreationInterval;
      this.maxWindowSize = maxWindowSize;
      this.scheduler = scheduler;
    }
    WindowTimeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new WindowTimeSubscriber(
          subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize,
          this.scheduler));
    };
    return WindowTimeOperator2;
  }();
  var CountedSubject = function(_super) {
    __extends(CountedSubject2, _super);
    function CountedSubject2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._numberOfNextedValues = 0;
      return _this;
    }
    CountedSubject2.prototype.next = function(value) {
      this._numberOfNextedValues++;
      _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject2.prototype, 'numberOfNextedValues', {
      get: function() {
        return this._numberOfNextedValues;
      },
      enumerable: true,
      configurable: true
    });
    return CountedSubject2;
  }(Subject);
  var WindowTimeSubscriber = function(_super) {
    __extends(WindowTimeSubscriber2, _super);
    function WindowTimeSubscriber2(
        destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
      var _this = _super.call(this, destination) || this;
      _this.destination = destination;
      _this.windowTimeSpan = windowTimeSpan;
      _this.windowCreationInterval = windowCreationInterval;
      _this.maxWindowSize = maxWindowSize;
      _this.scheduler = scheduler;
      _this.windows = [];
      var window3 = _this.openWindow();
      if (windowCreationInterval !== null && windowCreationInterval >= 0) {
        var closeState = {subscriber: _this, window: window3, context: null};
        var creationState = {windowTimeSpan, windowCreationInterval, subscriber: _this, scheduler};
        _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
        _this.add(
            scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
      } else {
        var timeSpanOnlyState = {subscriber: _this, window: window3, windowTimeSpan};
        _this.add(
            scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
      }
      return _this;
    }
    WindowTimeSubscriber2.prototype._next = function(value) {
      var windows = this.windows;
      var len = windows.length;
      for (var i = 0; i < len; i++) {
        var window_1 = windows[i];
        if (!window_1.closed) {
          window_1.next(value);
          if (window_1.numberOfNextedValues >= this.maxWindowSize) {
            this.closeWindow(window_1);
          }
        }
      }
    };
    WindowTimeSubscriber2.prototype._error = function(err) {
      var windows = this.windows;
      while (windows.length > 0) {
        windows.shift().error(err);
      }
      this.destination.error(err);
    };
    WindowTimeSubscriber2.prototype._complete = function() {
      var windows = this.windows;
      while (windows.length > 0) {
        var window_2 = windows.shift();
        if (!window_2.closed) {
          window_2.complete();
        }
      }
      this.destination.complete();
    };
    WindowTimeSubscriber2.prototype.openWindow = function() {
      var window3 = new CountedSubject();
      this.windows.push(window3);
      var destination = this.destination;
      destination.next(window3);
      return window3;
    };
    WindowTimeSubscriber2.prototype.closeWindow = function(window3) {
      window3.complete();
      var windows = this.windows;
      windows.splice(windows.indexOf(window3), 1);
    };
    return WindowTimeSubscriber2;
  }(Subscriber);
  function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan,
        window3 = state.window;
    if (window3) {
      subscriber.closeWindow(window3);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
  }
  function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber,
        scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window3 = subscriber.openWindow();
    var action = this;
    var context = {action, subscription: null};
    var timeSpanState = {subscriber, window: window3, context};
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
  }
  function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window3 = state.window, context = state.context;
    if (context && context.action && context.subscription) {
      context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window3);
  }

  // external/npm/node_modules/rxjs/_esm5/internal/operators/windowToggle.js
  var WindowToggleOperator = function() {
    function WindowToggleOperator2(openings, closingSelector) {
      this.openings = openings;
      this.closingSelector = closingSelector;
    }
    WindowToggleOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(
          new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator2;
  }();
  var WindowToggleSubscriber = function(_super) {
    __extends(WindowToggleSubscriber2, _super);
    function WindowToggleSubscriber2(destination, openings, closingSelector) {
      var _this = _super.call(this, destination) || this;
      _this.openings = openings;
      _this.closingSelector = closingSelector;
      _this.contexts = [];
      _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
      return _this;
    }
    WindowToggleSubscriber2.prototype._next = function(value) {
      var contexts = this.contexts;
      if (contexts) {
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
          contexts[i].window.next(value);
        }
      }
    };
    WindowToggleSubscriber2.prototype._error = function(err) {
      var contexts = this.contexts;
      this.contexts = null;
      if (contexts) {
        var len = contexts.length;
        var index = -1;
        while (++index < len) {
          var context_1 = contexts[index];
          context_1.window.error(err);
          context_1.subscription.unsubscribe();
        }
      }
      _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber2.prototype._complete = function() {
      var contexts = this.contexts;
      this.contexts = null;
      if (contexts) {
        var len = contexts.length;
        var index = -1;
        while (++index < len) {
          var context_2 = contexts[index];
          context_2.window.complete();
          context_2.subscription.unsubscribe();
        }
      }
      _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber2.prototype._unsubscribe = function() {
      var contexts = this.contexts;
      this.contexts = null;
      if (contexts) {
        var len = contexts.length;
        var index = -1;
        while (++index < len) {
          var context_3 = contexts[index];
          context_3.window.unsubscribe();
          context_3.subscription.unsubscribe();
        }
      }
    };
    WindowToggleSubscriber2.prototype.notifyNext = function(
        outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      if (outerValue === this.openings) {
        var closingNotifier = void 0;
        try {
          var closingSelector = this.closingSelector;
          closingNotifier = closingSelector(innerValue);
        } catch (e) {
          return this.error(e);
        }
        var window_1 = new Subject();
        var subscription = new Subscription();
        var context_4 = {window: window_1, subscription};
        this.contexts.push(context_4);
        var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
        if (innerSubscription.closed) {
          this.closeWindow(this.contexts.length - 1);
        } else {
          innerSubscription.context = context_4;
          subscription.add(innerSubscription);
        }
        this.destination.next(window_1);
      } else {
        this.closeWindow(this.contexts.indexOf(outerValue));
      }
    };
    WindowToggleSubscriber2.prototype.notifyError = function(err) {
      this.error(err);
    };
    WindowToggleSubscriber2.prototype.notifyComplete = function(inner) {
      if (inner !== this.openSubscription) {
        this.closeWindow(this.contexts.indexOf(inner.context));
      }
    };
    WindowToggleSubscriber2.prototype.closeWindow = function(index) {
      if (index === -1) {
        return;
      }
      var contexts = this.contexts;
      var context = contexts[index];
      var window3 = context.window, subscription = context.subscription;
      contexts.splice(index, 1);
      window3.complete();
      subscription.unsubscribe();
    };
    return WindowToggleSubscriber2;
  }(OuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/windowWhen.js
  var WindowOperator2 = function() {
    function WindowOperator3(closingSelector) {
      this.closingSelector = closingSelector;
    }
    WindowOperator3.prototype.call = function(subscriber, source) {
      return source.subscribe(new WindowSubscriber2(subscriber, this.closingSelector));
    };
    return WindowOperator3;
  }();
  var WindowSubscriber2 = function(_super) {
    __extends(WindowSubscriber3, _super);
    function WindowSubscriber3(destination, closingSelector) {
      var _this = _super.call(this, destination) || this;
      _this.destination = destination;
      _this.closingSelector = closingSelector;
      _this.openWindow();
      return _this;
    }
    WindowSubscriber3.prototype.notifyNext = function(
        _outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
      this.openWindow(innerSub);
    };
    WindowSubscriber3.prototype.notifyError = function(error) {
      this._error(error);
    };
    WindowSubscriber3.prototype.notifyComplete = function(innerSub) {
      this.openWindow(innerSub);
    };
    WindowSubscriber3.prototype._next = function(value) {
      this.window.next(value);
    };
    WindowSubscriber3.prototype._error = function(err) {
      this.window.error(err);
      this.destination.error(err);
      this.unsubscribeClosingNotification();
    };
    WindowSubscriber3.prototype._complete = function() {
      this.window.complete();
      this.destination.complete();
      this.unsubscribeClosingNotification();
    };
    WindowSubscriber3.prototype.unsubscribeClosingNotification = function() {
      if (this.closingNotification) {
        this.closingNotification.unsubscribe();
      }
    };
    WindowSubscriber3.prototype.openWindow = function(innerSub) {
      if (innerSub === void 0) {
        innerSub = null;
      }
      if (innerSub) {
        this.remove(innerSub);
        innerSub.unsubscribe();
      }
      var prevWindow = this.window;
      if (prevWindow) {
        prevWindow.complete();
      }
      var window3 = this.window = new Subject();
      this.destination.next(window3);
      var closingNotifier;
      try {
        var closingSelector = this.closingSelector;
        closingNotifier = closingSelector();
      } catch (e) {
        this.destination.error(e);
        this.window.error(e);
        return;
      }
      this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
    };
    return WindowSubscriber3;
  }(OuterSubscriber);

  // external/npm/node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js
  var WithLatestFromOperator = function() {
    function WithLatestFromOperator2(observables, project) {
      this.observables = observables;
      this.project = project;
    }
    WithLatestFromOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(
          new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator2;
  }();
  var WithLatestFromSubscriber = function(_super) {
    __extends(WithLatestFromSubscriber2, _super);
    function WithLatestFromSubscriber2(destination, observables, project) {
      var _this = _super.call(this, destination) || this;
      _this.observables = observables;
      _this.project = project;
      _this.toRespond = [];
      var len = observables.length;
      _this.values = new Array(len);
      for (var i = 0; i < len; i++) {
        _this.toRespond.push(i);
      }
      for (var i = 0; i < len; i++) {
        var observable2 = observables[i];
        _this.add(subscribeToResult(_this, observable2, void 0, i));
      }
      return _this;
    }
    WithLatestFromSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
      this.values[outerIndex] = innerValue;
      var toRespond = this.toRespond;
      if (toRespond.length > 0) {
        var found = toRespond.indexOf(outerIndex);
        if (found !== -1) {
          toRespond.splice(found, 1);
        }
      }
    };
    WithLatestFromSubscriber2.prototype.notifyComplete = function() {};
    WithLatestFromSubscriber2.prototype._next = function(value) {
      if (this.toRespond.length === 0) {
        var args = [value].concat(this.values);
        if (this.project) {
          this._tryProject(args);
        } else {
          this.destination.next(args);
        }
      }
    };
    WithLatestFromSubscriber2.prototype._tryProject = function(args) {
      var result;
      try {
        result = this.project.apply(this, args);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.destination.next(result);
    };
    return WithLatestFromSubscriber2;
  }(OuterSubscriber);

  // external/npm/node_modules/@angular/core/fesm2015/core.js
  /**
   * @license Angular v11.0.9
   * (c) 2010-2020 Google LLC. https://angular.io/
   * License: MIT
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function getClosureSafeProperty(objWithPropertyToExtract) {
    for (let key in objWithPropertyToExtract) {
      if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
        return key;
      }
    }
    throw Error('Could not find renamed property on target object.');
  }
  function fillProperties(target, source) {
    for (const key in source) {
      if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
        target[key] = source[key];
      }
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function stringify(token) {
    if (typeof token === 'string') {
      return token;
    }
    if (Array.isArray(token)) {
      return '[' + token.map(stringify).join(', ') + ']';
    }
    if (token == null) {
      return '' + token;
    }
    if (token.overriddenName) {
      return `${token.overriddenName}`;
    }
    if (token.name) {
      return `${token.name}`;
    }
    const res = token.toString();
    if (res == null) {
      return '' + res;
    }
    const newLineIndex = res.indexOf('\n');
    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
  }
  function concatStringsWithSpace(before, after) {
    return before == null || before === '' ?
        after === null ? '' : after :
        after == null || after === '' ? before : before + ' ' + after;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __forward_ref__ = getClosureSafeProperty({__forward_ref__: getClosureSafeProperty});
  function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function() {
      return stringify(this());
    };
    return forwardRefFn;
  }
  function resolveForwardRef(type) {
    return isForwardRef(type) ? type() : type;
  }
  function isForwardRef(fn) {
    return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) &&
        fn.__forward_ref__ === forwardRef;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function assertNumber(actual, msg) {
    if (!(typeof actual === 'number')) {
      throwError2(msg, typeof actual, 'number', '===');
    }
  }
  function assertNumberInRange(actual, minInclusive, maxInclusive) {
    assertNumber(actual, 'Expected a number');
    assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');
    assertGreaterThanOrEqual(
        actual, minInclusive, 'Expected number to be greater than or equal to');
  }
  function assertString(actual, msg) {
    if (!(typeof actual === 'string')) {
      throwError2(msg, actual === null ? 'null' : typeof actual, 'string', '===');
    }
  }
  function assertFunction(actual, msg) {
    if (!(typeof actual === 'function')) {
      throwError2(msg, actual === null ? 'null' : typeof actual, 'function', '===');
    }
  }
  function assertEqual(actual, expected, msg) {
    if (!(actual == expected)) {
      throwError2(msg, actual, expected, '==');
    }
  }
  function assertNotEqual(actual, expected, msg) {
    if (!(actual != expected)) {
      throwError2(msg, actual, expected, '!=');
    }
  }
  function assertSame(actual, expected, msg) {
    if (!(actual === expected)) {
      throwError2(msg, actual, expected, '===');
    }
  }
  function assertNotSame(actual, expected, msg) {
    if (!(actual !== expected)) {
      throwError2(msg, actual, expected, '!==');
    }
  }
  function assertLessThan(actual, expected, msg) {
    if (!(actual < expected)) {
      throwError2(msg, actual, expected, '<');
    }
  }
  function assertLessThanOrEqual(actual, expected, msg) {
    if (!(actual <= expected)) {
      throwError2(msg, actual, expected, '<=');
    }
  }
  function assertGreaterThan(actual, expected, msg) {
    if (!(actual > expected)) {
      throwError2(msg, actual, expected, '>');
    }
  }
  function assertGreaterThanOrEqual(actual, expected, msg) {
    if (!(actual >= expected)) {
      throwError2(msg, actual, expected, '>=');
    }
  }
  function assertDefined(actual, msg) {
    if (actual == null) {
      throwError2(msg, actual, null, '!=');
    }
  }
  function throwError2(msg, actual, expected, comparison) {
    throw new Error(
        `ASSERTION ERROR: ${msg}` +
        (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
  }
  function assertDomNode(node) {
    if (!(typeof Node !== 'undefined' && node instanceof Node) &&
        !(typeof node === 'object' && node != null &&
          node.constructor.name === 'WebWorkerRenderNode')) {
      throwError2(
          `The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
    }
  }
  function assertIndexInRange(arr, index) {
    assertDefined(arr, 'Array must be defined.');
    const maxLen = arr.length;
    if (index < 0 || index >= maxLen) {
      throwError2(`Index expected to be less than ${maxLen} but got ${index}`);
    }
  }
  function assertOneOf(value, ...validValues) {
    if (validValues.indexOf(value) !== -1) return true;
    throwError2(`Expected value to be one of ${JSON.stringify(validValues)} but was ${
        JSON.stringify(value)}.`);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275defineInjectable(opts) {
    return {
      token: opts.token,
      providedIn: opts.providedIn || null,
      factory: opts.factory,
      value: void 0
    };
  }
  function \u0275\u0275defineInjector(options) {
    return {
      factory: options.factory,
      providers: options.providers || [],
      imports: options.imports || []
    };
  }
  function getInjectableDef(type) {
    return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);
  }
  function getOwnDefinition(type, field) {
    return type.hasOwnProperty(field) ? type[field] : null;
  }
  function getInheritedInjectableDef(type) {
    const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);
    if (def) {
      const typeName = getTypeName(type);
      console.warn(`DEPRECATED: DI is instantiating a token "${
          typeName}" that inherits its @Injectable decorator but does not provide one itself.
This will become an error in a future version of Angular. Please add @Injectable() to the "${
          typeName}" class.`);
      return def;
    } else {
      return null;
    }
  }
  function getTypeName(type) {
    if (type.hasOwnProperty('name')) {
      return type.name;
    }
    const match2 = ('' + type).match(/^function\s*([^\s(]+)/);
    return match2 === null ? '' : match2[1];
  }
  function getInjectorDef(type) {
    return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ?
        type[NG_INJ_DEF] :
        null;
  }
  var NG_PROV_DEF = getClosureSafeProperty({\u0275prov: getClosureSafeProperty});
  var NG_INJ_DEF = getClosureSafeProperty({\u0275inj: getClosureSafeProperty});
  var NG_INJECTABLE_DEF = getClosureSafeProperty({ngInjectableDef: getClosureSafeProperty});
  var NG_INJECTOR_DEF = getClosureSafeProperty({ngInjectorDef: getClosureSafeProperty});
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var InjectFlags;
  (function(InjectFlags2) {
    InjectFlags2[InjectFlags2['Default'] = 0] = 'Default';
    InjectFlags2[InjectFlags2['Host'] = 1] = 'Host';
    InjectFlags2[InjectFlags2['Self'] = 2] = 'Self';
    InjectFlags2[InjectFlags2['SkipSelf'] = 4] = 'SkipSelf';
    InjectFlags2[InjectFlags2['Optional'] = 8] = 'Optional';
  })(InjectFlags || (InjectFlags = {}));
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var _injectImplementation;
  function getInjectImplementation() {
    return _injectImplementation;
  }
  function setInjectImplementation(impl) {
    const previous = _injectImplementation;
    _injectImplementation = impl;
    return previous;
  }
  function injectRootLimpMode(token, notFoundValue, flags) {
    const injectableDef = getInjectableDef(token);
    if (injectableDef && injectableDef.providedIn == 'root') {
      return injectableDef.value === void 0 ? injectableDef.value = injectableDef.factory() :
                                              injectableDef.value;
    }
    if (flags & InjectFlags.Optional) return null;
    if (notFoundValue !== void 0) return notFoundValue;
    throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`);
  }
  function assertInjectImplementationNotEqual(fn) {
    ngDevMode &&
        assertNotEqual(
            _injectImplementation, fn, 'Calling \u0275\u0275inject would cause infinite recursion');
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function noSideEffects(fn) {
    return {toString: fn}.toString();
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ChangeDetectionStrategy;
  (function(ChangeDetectionStrategy2) {
    ChangeDetectionStrategy2[ChangeDetectionStrategy2['OnPush'] = 0] = 'OnPush';
    ChangeDetectionStrategy2[ChangeDetectionStrategy2['Default'] = 1] = 'Default';
  })(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
  var ChangeDetectorStatus;
  (function(ChangeDetectorStatus2) {
    ChangeDetectorStatus2[ChangeDetectorStatus2['CheckOnce'] = 0] = 'CheckOnce';
    ChangeDetectorStatus2[ChangeDetectorStatus2['Checked'] = 1] = 'Checked';
    ChangeDetectorStatus2[ChangeDetectorStatus2['CheckAlways'] = 2] = 'CheckAlways';
    ChangeDetectorStatus2[ChangeDetectorStatus2['Detached'] = 3] = 'Detached';
    ChangeDetectorStatus2[ChangeDetectorStatus2['Errored'] = 4] = 'Errored';
    ChangeDetectorStatus2[ChangeDetectorStatus2['Destroyed'] = 5] = 'Destroyed';
  })(ChangeDetectorStatus || (ChangeDetectorStatus = {}));
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ViewEncapsulation;
  (function(ViewEncapsulation2) {
    ViewEncapsulation2[ViewEncapsulation2['Emulated'] = 0] = 'Emulated';
    ViewEncapsulation2[ViewEncapsulation2['None'] = 2] = 'None';
    ViewEncapsulation2[ViewEncapsulation2['ShadowDom'] = 3] = 'ShadowDom';
  })(ViewEncapsulation || (ViewEncapsulation = {}));
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __globalThis = typeof globalThis !== 'undefined' && globalThis;
  var __window = typeof window !== 'undefined' && window;
  var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
      self instanceof WorkerGlobalScope && self;
  var __global = typeof global !== 'undefined' && global;
  var _global = __globalThis || __global || __window || __self;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function ngDevModeResetPerfCounters() {
    const locationString = typeof location !== 'undefined' ? location.toString() : '';
    const newCounters = {
      namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,
      firstCreatePass: 0,
      tNode: 0,
      tView: 0,
      rendererCreateTextNode: 0,
      rendererSetText: 0,
      rendererCreateElement: 0,
      rendererAddEventListener: 0,
      rendererSetAttribute: 0,
      rendererRemoveAttribute: 0,
      rendererSetProperty: 0,
      rendererSetClassName: 0,
      rendererAddClass: 0,
      rendererRemoveClass: 0,
      rendererSetStyle: 0,
      rendererRemoveStyle: 0,
      rendererDestroy: 0,
      rendererDestroyNode: 0,
      rendererMoveNode: 0,
      rendererRemoveNode: 0,
      rendererAppendChild: 0,
      rendererInsertBefore: 0,
      rendererCreateComment: 0
    };
    const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;
    _global['ngDevMode'] = allowNgDevModeTrue && newCounters;
    return newCounters;
  }
  function initNgDevMode() {
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      if (typeof ngDevMode !== 'object') {
        ngDevModeResetPerfCounters();
      }
      return typeof ngDevMode !== 'undefined' && !!ngDevMode;
    }
    return false;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var EMPTY_OBJ = {};
  var EMPTY_ARRAY = [];
  if ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {
    Object.freeze(EMPTY_OBJ);
    Object.freeze(EMPTY_ARRAY);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NG_COMP_DEF = getClosureSafeProperty({\u0275cmp: getClosureSafeProperty});
  var NG_DIR_DEF = getClosureSafeProperty({\u0275dir: getClosureSafeProperty});
  var NG_PIPE_DEF = getClosureSafeProperty({\u0275pipe: getClosureSafeProperty});
  var NG_MOD_DEF = getClosureSafeProperty({\u0275mod: getClosureSafeProperty});
  var NG_LOC_ID_DEF = getClosureSafeProperty({\u0275loc: getClosureSafeProperty});
  var NG_FACTORY_DEF = getClosureSafeProperty({\u0275fac: getClosureSafeProperty});
  var NG_ELEMENT_ID = getClosureSafeProperty({__NG_ELEMENT_ID__: getClosureSafeProperty});
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var _renderCompCount = 0;
  function \u0275\u0275defineComponent(componentDefinition) {
    return noSideEffects(() => {
      (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();
      const type = componentDefinition.type;
      const typePrototype = type.prototype;
      const declaredInputs = {};
      const def = {
        type,
        providersResolver: null,
        decls: componentDefinition.decls,
        vars: componentDefinition.vars,
        factory: null,
        template: componentDefinition.template || null,
        consts: componentDefinition.consts || null,
        ngContentSelectors: componentDefinition.ngContentSelectors,
        hostBindings: componentDefinition.hostBindings || null,
        hostVars: componentDefinition.hostVars || 0,
        hostAttrs: componentDefinition.hostAttrs || null,
        contentQueries: componentDefinition.contentQueries || null,
        declaredInputs,
        inputs: null,
        outputs: null,
        exportAs: componentDefinition.exportAs || null,
        onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
        directiveDefs: null,
        pipeDefs: null,
        selectors: componentDefinition.selectors || EMPTY_ARRAY,
        viewQuery: componentDefinition.viewQuery || null,
        features: componentDefinition.features || null,
        data: componentDefinition.data || {},
        encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,
        id: 'c',
        styles: componentDefinition.styles || EMPTY_ARRAY,
        _: null,
        setInput: null,
        schemas: componentDefinition.schemas || null,
        tView: null
      };
      const directiveTypes = componentDefinition.directives;
      const feature = componentDefinition.features;
      const pipeTypes = componentDefinition.pipes;
      def.id += _renderCompCount++;
      def.inputs = invertObject(componentDefinition.inputs, declaredInputs),
      def.outputs = invertObject(componentDefinition.outputs),
      feature && feature.forEach((fn) => fn(def));
      def.directiveDefs = directiveTypes ?
          () => (typeof directiveTypes === 'function' ? directiveTypes() : directiveTypes)
                    .map(extractDirectiveDef) :
          null;
      def.pipeDefs = pipeTypes ?
          () => (typeof pipeTypes === 'function' ? pipeTypes() : pipeTypes).map(extractPipeDef) :
          null;
      return def;
    });
  }
  function \u0275\u0275setComponentScope(type, directives, pipes) {
    const def = type.\u0275cmp;
    def.directiveDefs = () => directives.map(extractDirectiveDef);
    def.pipeDefs = () => pipes.map(extractPipeDef);
  }
  function extractDirectiveDef(type) {
    const def = getComponentDef(type) || getDirectiveDef(type);
    if (ngDevMode && !def) {
      throw new Error(`'${type.name}' is neither 'ComponentType' or 'DirectiveType'.`);
    }
    return def;
  }
  function extractPipeDef(type) {
    const def = getPipeDef(type);
    if (ngDevMode && !def) {
      throw new Error(`'${type.name}' is not a 'PipeType'.`);
    }
    return def;
  }
  var autoRegisterModuleById = {};
  function \u0275\u0275defineNgModule(def) {
    const res = {
      type: def.type,
      bootstrap: def.bootstrap || EMPTY_ARRAY,
      declarations: def.declarations || EMPTY_ARRAY,
      imports: def.imports || EMPTY_ARRAY,
      exports: def.exports || EMPTY_ARRAY,
      transitiveCompileScopes: null,
      schemas: def.schemas || null,
      id: def.id || null
    };
    if (def.id != null) {
      noSideEffects(() => {
        autoRegisterModuleById[def.id] = def.type;
      });
    }
    return res;
  }
  function \u0275\u0275setNgModuleScope(type, scope) {
    return noSideEffects(() => {
      const ngModuleDef = getNgModuleDef(type, true);
      ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;
      ngModuleDef.imports = scope.imports || EMPTY_ARRAY;
      ngModuleDef.exports = scope.exports || EMPTY_ARRAY;
    });
  }
  function invertObject(obj, secondary) {
    if (obj == null) return EMPTY_OBJ;
    const newLookup = {};
    for (const minifiedKey in obj) {
      if (obj.hasOwnProperty(minifiedKey)) {
        let publicName = obj[minifiedKey];
        let declaredName = publicName;
        if (Array.isArray(publicName)) {
          declaredName = publicName[1];
          publicName = publicName[0];
        }
        newLookup[publicName] = minifiedKey;
        if (secondary) {
          secondary[publicName] = declaredName;
        }
      }
    }
    return newLookup;
  }
  var \u0275\u0275defineDirective = \u0275\u0275defineComponent;
  function \u0275\u0275definePipe(pipeDef) {
    return {
      type: pipeDef.type,
      name: pipeDef.name,
      factory: null,
      pure: pipeDef.pure !== false,
      onDestroy: pipeDef.type.prototype.ngOnDestroy || null
    };
  }
  function getComponentDef(type) {
    return type[NG_COMP_DEF] || null;
  }
  function getDirectiveDef(type) {
    return type[NG_DIR_DEF] || null;
  }
  function getPipeDef(type) {
    return type[NG_PIPE_DEF] || null;
  }
  function getNgModuleDef(type, throwNotFound) {
    const ngModuleDef = type[NG_MOD_DEF] || null;
    if (!ngModuleDef && throwNotFound === true) {
      throw new Error(`Type ${stringify(type)} does not have '\u0275mod' property.`);
    }
    return ngModuleDef;
  }
  function getNgLocaleIdDef(type) {
    return type[NG_LOC_ID_DEF] || null;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var HOST = 0;
  var TVIEW = 1;
  var FLAGS = 2;
  var PARENT = 3;
  var NEXT = 4;
  var TRANSPLANTED_VIEWS_TO_REFRESH = 5;
  var T_HOST = 6;
  var CLEANUP = 7;
  var CONTEXT = 8;
  var INJECTOR = 9;
  var RENDERER_FACTORY = 10;
  var RENDERER = 11;
  var SANITIZER = 12;
  var CHILD_HEAD = 13;
  var CHILD_TAIL = 14;
  var DECLARATION_VIEW = 15;
  var DECLARATION_COMPONENT_VIEW = 16;
  var DECLARATION_LCONTAINER = 17;
  var PREORDER_HOOK_FLAGS = 18;
  var QUERIES = 19;
  var HEADER_OFFSET = 20;
  var TViewTypeAsString = ['Root', 'Component', 'Embedded'];
  var unusedValueExportToPlacateAjd = 1;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var TYPE = 1;
  var HAS_TRANSPLANTED_VIEWS = 2;
  var NATIVE = 7;
  var VIEW_REFS = 8;
  var MOVED_VIEWS = 9;
  var CONTAINER_HEADER_OFFSET = 10;
  var unusedValueExportToPlacateAjd$1 = 1;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function isLView(value) {
    return Array.isArray(value) && typeof value[TYPE] === 'object';
  }
  function isLContainer(value) {
    return Array.isArray(value) && value[TYPE] === true;
  }
  function isContentQueryHost(tNode) {
    return (tNode.flags & 8) !== 0;
  }
  function isComponentHost(tNode) {
    return (tNode.flags & 2) === 2;
  }
  function isDirectiveHost(tNode) {
    return (tNode.flags & 1) === 1;
  }
  function isComponentDef(def) {
    return def.template !== null;
  }
  function isRootView(target) {
    return (target[FLAGS] & 512) !== 0;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function assertTNodeForLView(tNode, lView) {
    assertTNodeForTView(tNode, lView[TVIEW]);
  }
  function assertTNodeForTView(tNode, tView) {
    assertTNode(tNode);
    tNode.hasOwnProperty('tView_') &&
        assertEqual(tNode.tView_, tView, 'This TNode does not belong to this TView.');
  }
  function assertTNode(tNode) {
    assertDefined(tNode, 'TNode must be defined');
    if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {
      throwError2('Not of type TNode, got: ' + tNode);
    }
  }
  function assertTIcu(tIcu) {
    assertDefined(tIcu, 'Expected TIcu to be defined');
    if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {
      throwError2('Object is not of TIcu type.');
    }
  }
  function assertComponentType(
      actual,
      msg = 'Type passed in is not ComponentType, it does not have \'\u0275cmp\' property.') {
    if (!getComponentDef(actual)) {
      throwError2(msg);
    }
  }
  function assertNgModuleType(
      actual,
      msg = 'Type passed in is not NgModuleType, it does not have \'\u0275mod\' property.') {
    if (!getNgModuleDef(actual)) {
      throwError2(msg);
    }
  }
  function assertHasParent(tNode) {
    assertDefined(tNode, 'currentTNode should exist!');
    assertDefined(tNode.parent, 'currentTNode should have a parent');
  }
  function assertLContainer(value) {
    assertDefined(value, 'LContainer must be defined');
    assertEqual(isLContainer(value), true, 'Expecting LContainer');
  }
  function assertLViewOrUndefined(value) {
    value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');
  }
  function assertLView(value) {
    assertDefined(value, 'LView must be defined');
    assertEqual(isLView(value), true, 'Expecting LView');
  }
  function assertFirstCreatePass(tView, errMessage) {
    assertEqual(
        tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');
  }
  function assertFirstUpdatePass(tView, errMessage) {
    assertEqual(
        tView.firstUpdatePass, true, errMessage || 'Should only be called in first update pass.');
  }
  function assertDirectiveDef(obj) {
    if (obj.type === void 0 || obj.selectors == void 0 || obj.inputs === void 0) {
      throwError2(
          `Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
    }
  }
  function assertIndexInDeclRange(lView, index) {
    const tView = lView[1];
    assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
  }
  function assertIndexInExpandoRange(lView, index) {
    const tView = lView[1];
    assertBetween(tView.expandoStartIndex, lView.length, index);
  }
  function assertBetween(lower, upper, index) {
    if (!(lower <= index && index < upper)) {
      throwError2(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);
    }
  }
  function assertNodeInjector(lView, injectorIndex) {
    assertIndexInExpandoRange(lView, injectorIndex);
    assertIndexInExpandoRange(lView, injectorIndex + 8);
    assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 8], 'injectorIndex should point to parent injector');
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function getFactoryDef(type, throwNotFound) {
    const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
    if (!hasFactoryDef && throwNotFound === true && ngDevMode) {
      throw new Error(`Type ${stringify(type)} does not have '\u0275fac' property.`);
    }
    return hasFactoryDef ? type[NG_FACTORY_DEF] : null;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var RuntimeError = class extends Error {
    constructor(code, message) {
      super(formatRuntimeError(code, message));
      this.code = code;
    }
  };
  function formatRuntimeError(code, message) {
    const fullCode = code ? `NG0${code}: ` : '';
    return `${fullCode}${message}`;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function renderStringify(value) {
    if (typeof value === 'string') return value;
    if (value == null) return '';
    return String(value);
  }
  function stringifyForError(value) {
    if (typeof value === 'function') return value.name || value.toString();
    if (typeof value === 'object' && value != null && typeof value.type === 'function') {
      return value.type.name || value.type.toString();
    }
    return renderStringify(value);
  }
  function throwCyclicDependencyError(token, path) {
    const depPath = path ? `. Dependency path: ${path.join(' > ')} > ${token}` : '';
    throw new RuntimeError('200', `Circular dependency in DI detected for ${token}${depPath}`);
  }
  function throwMixedMultiProviderError() {
    throw new Error(`Cannot mix multi providers and regular providers`);
  }
  function throwInvalidProviderError(ngModuleType, providers, provider) {
    let ngModuleDetail = '';
    if (ngModuleType && providers) {
      const providerDetail = providers.map((v) => v == provider ? '?' + provider + '?' : '...');
      ngModuleDetail =
          ` - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`;
    }
    throw new Error(
        `Invalid provider for the NgModule '${stringify(ngModuleType)}'` + ngModuleDetail);
  }
  function throwProviderNotFoundError(token, injectorName) {
    const injectorDetails = injectorName ? ` in ${injectorName}` : '';
    throw new RuntimeError(
        '201', `No provider for ${stringifyForError(token)} found${injectorDetails}`);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var SimpleChange = class {
    constructor(previousValue, currentValue, firstChange) {
      this.previousValue = previousValue;
      this.currentValue = currentValue;
      this.firstChange = firstChange;
    }
    isFirstChange() {
      return this.firstChange;
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275NgOnChangesFeature() {
    return NgOnChangesFeatureImpl;
  }
  function NgOnChangesFeatureImpl(definition) {
    if (definition.type.prototype.ngOnChanges) {
      definition.setInput = ngOnChangesSetInput;
    }
    return rememberChangeHistoryAndInvokeOnChangesHook;
  }
  \u0275\u0275NgOnChangesFeature.ngInherit = true;
  function rememberChangeHistoryAndInvokeOnChangesHook() {
    const simpleChangesStore = getSimpleChangesStore(this);
    const current = simpleChangesStore === null || simpleChangesStore === void 0 ?
        void 0 :
        simpleChangesStore.current;
    if (current) {
      const previous = simpleChangesStore.previous;
      if (previous === EMPTY_OBJ) {
        simpleChangesStore.previous = current;
      } else {
        for (let key in current) {
          previous[key] = current[key];
        }
      }
      simpleChangesStore.current = null;
      this.ngOnChanges(current);
    }
  }
  function ngOnChangesSetInput(instance, value, publicName, privateName) {
    const simpleChangesStore = getSimpleChangesStore(instance) ||
        setSimpleChangesStore(instance, {previous: EMPTY_OBJ, current: null});
    const current = simpleChangesStore.current || (simpleChangesStore.current = {});
    const previous = simpleChangesStore.previous;
    const declaredName = this.declaredInputs[publicName];
    const previousChange = previous[declaredName];
    current[declaredName] = new SimpleChange(
        previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);
    instance[privateName] = value;
  }
  var SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';
  function getSimpleChangesStore(instance) {
    return instance[SIMPLE_CHANGES_STORE] || null;
  }
  function setSimpleChangesStore(instance, store2) {
    return instance[SIMPLE_CHANGES_STORE] = store2;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  var MATH_ML_NAMESPACE = 'http://www.w3.org/1998/MathML/';
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var MONKEY_PATCH_KEY_NAME = '__ngContext__';
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var DOCUMENT = void 0;
  function setDocument(document2) {
    DOCUMENT = document2;
  }
  function getDocument() {
    if (DOCUMENT !== void 0) {
      return DOCUMENT;
    } else if (typeof document !== 'undefined') {
      return document;
    }
    return void 0;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var RendererStyleFlags3;
  (function(RendererStyleFlags32) {
    RendererStyleFlags32[RendererStyleFlags32['Important'] = 1] = 'Important';
    RendererStyleFlags32[RendererStyleFlags32['DashCase'] = 2] = 'DashCase';
  })(RendererStyleFlags3 || (RendererStyleFlags3 = {}));
  function isProceduralRenderer(renderer) {
    return !!renderer.listen;
  }
  var \u02750 = (hostElement, rendererType) => {
    return getDocument();
  };
  var domRendererFactory3 = {createRenderer: \u02750};
  var unusedValueExportToPlacateAjd$2 = 1;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function unwrapRNode(value) {
    while (Array.isArray(value)) {
      value = value[HOST];
    }
    return value;
  }
  function unwrapLView(value) {
    while (Array.isArray(value)) {
      if (typeof value[TYPE] === 'object') return value;
      value = value[HOST];
    }
    return null;
  }
  function getNativeByIndex(index, lView) {
    ngDevMode && assertIndexInRange(lView, index);
    ngDevMode &&
        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');
    return unwrapRNode(lView[index]);
  }
  function getNativeByTNode(tNode, lView) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    ngDevMode && assertIndexInRange(lView, tNode.index);
    const node = unwrapRNode(lView[tNode.index]);
    ngDevMode && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);
    return node;
  }
  function getTNode(tView, index) {
    ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');
    ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');
    const tNode = tView.data[index];
    ngDevMode && tNode !== null && assertTNode(tNode);
    return tNode;
  }
  function load(view, index) {
    ngDevMode && assertIndexInRange(view, index);
    return view[index];
  }
  function getComponentLViewByIndex(nodeIndex, hostView) {
    ngDevMode && assertIndexInRange(hostView, nodeIndex);
    const slotValue = hostView[nodeIndex];
    const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
    return lView;
  }
  function readPatchedData(target) {
    ngDevMode && assertDefined(target, 'Target expected');
    return target[MONKEY_PATCH_KEY_NAME] || null;
  }
  function readPatchedLView(target) {
    const value = readPatchedData(target);
    if (value) {
      return Array.isArray(value) ? value : value.lView;
    }
    return null;
  }
  function isCreationMode(view) {
    return (view[FLAGS] & 4) === 4;
  }
  function viewAttachedToChangeDetector(view) {
    return (view[FLAGS] & 128) === 128;
  }
  function viewAttachedToContainer(view) {
    return isLContainer(view[PARENT]);
  }
  function getConstant(consts, index) {
    if (index === null || index === void 0) return null;
    ngDevMode && assertIndexInRange(consts, index);
    return consts[index];
  }
  function resetPreOrderHookFlags(lView) {
    lView[PREORDER_HOOK_FLAGS] = 0;
  }
  function updateTransplantedViewCount(lContainer, amount) {
    lContainer[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;
    let viewOrContainer = lContainer;
    let parent = lContainer[PARENT];
    while (parent !== null &&
           (amount === 1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 1 ||
            amount === -1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 0)) {
      parent[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;
      viewOrContainer = parent;
      parent = parent[PARENT];
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var instructionState = {
    lFrame: createLFrame(null),
    bindingsEnabled: true,
    isInCheckNoChangesMode: false
  };
  function getElementDepthCount() {
    return instructionState.lFrame.elementDepthCount;
  }
  function increaseElementDepthCount() {
    instructionState.lFrame.elementDepthCount++;
  }
  function decreaseElementDepthCount() {
    instructionState.lFrame.elementDepthCount--;
  }
  function getBindingsEnabled() {
    return instructionState.bindingsEnabled;
  }
  function \u0275\u0275enableBindings() {
    instructionState.bindingsEnabled = true;
  }
  function \u0275\u0275disableBindings() {
    instructionState.bindingsEnabled = false;
  }
  function getLView() {
    return instructionState.lFrame.lView;
  }
  function getTView() {
    return instructionState.lFrame.tView;
  }
  function \u0275\u0275restoreView(viewToRestore) {
    instructionState.lFrame.contextLView = viewToRestore;
  }
  function getCurrentTNode() {
    let currentTNode = getCurrentTNodePlaceholderOk();
    while (currentTNode !== null && currentTNode.type === 64) {
      currentTNode = currentTNode.parent;
    }
    return currentTNode;
  }
  function getCurrentTNodePlaceholderOk() {
    return instructionState.lFrame.currentTNode;
  }
  function getCurrentParentTNode() {
    const lFrame = instructionState.lFrame;
    const currentTNode = lFrame.currentTNode;
    return lFrame.isParent ? currentTNode : currentTNode.parent;
  }
  function setCurrentTNode(tNode, isParent) {
    ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
    const lFrame = instructionState.lFrame;
    lFrame.currentTNode = tNode;
    lFrame.isParent = isParent;
  }
  function isCurrentTNodeParent() {
    return instructionState.lFrame.isParent;
  }
  function setCurrentTNodeAsNotParent() {
    instructionState.lFrame.isParent = false;
  }
  function getContextLView() {
    return instructionState.lFrame.contextLView;
  }
  function isInCheckNoChangesMode() {
    return instructionState.isInCheckNoChangesMode;
  }
  function setIsInCheckNoChangesMode(mode) {
    instructionState.isInCheckNoChangesMode = mode;
  }
  function getBindingRoot() {
    const lFrame = instructionState.lFrame;
    let index = lFrame.bindingRootIndex;
    if (index === -1) {
      index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
    }
    return index;
  }
  function getBindingIndex() {
    return instructionState.lFrame.bindingIndex;
  }
  function setBindingIndex(value) {
    return instructionState.lFrame.bindingIndex = value;
  }
  function nextBindingIndex() {
    return instructionState.lFrame.bindingIndex++;
  }
  function incrementBindingIndex(count2) {
    const lFrame = instructionState.lFrame;
    const index = lFrame.bindingIndex;
    lFrame.bindingIndex = lFrame.bindingIndex + count2;
    return index;
  }
  function isInI18nBlock() {
    return instructionState.lFrame.inI18n;
  }
  function setInI18nBlock(isInI18nBlock2) {
    instructionState.lFrame.inI18n = isInI18nBlock2;
  }
  function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
    const lFrame = instructionState.lFrame;
    lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
    setCurrentDirectiveIndex(currentDirectiveIndex);
  }
  function getCurrentDirectiveIndex() {
    return instructionState.lFrame.currentDirectiveIndex;
  }
  function setCurrentDirectiveIndex(currentDirectiveIndex) {
    instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
  }
  function getCurrentDirectiveDef(tData) {
    const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
    return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
  }
  function getCurrentQueryIndex() {
    return instructionState.lFrame.currentQueryIndex;
  }
  function setCurrentQueryIndex(value) {
    instructionState.lFrame.currentQueryIndex = value;
  }
  function getDeclarationTNode(lView) {
    const tView = lView[TVIEW];
    if (tView.type === 2) {
      ngDevMode &&
          assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');
      return tView.declTNode;
    }
    if (tView.type === 1) {
      return lView[T_HOST];
    }
    return null;
  }
  function enterDI(lView, tNode, flags) {
    ngDevMode && assertLViewOrUndefined(lView);
    if (flags & InjectFlags.SkipSelf) {
      ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);
      let parentTNode = tNode;
      let parentLView = lView;
      while (true) {
        ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');
        parentTNode = parentTNode.parent;
        if (parentTNode === null && !(flags & InjectFlags.Host)) {
          parentTNode = getDeclarationTNode(parentLView);
          if (parentTNode === null) break;
          ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');
          parentLView = parentLView[DECLARATION_VIEW];
          if (parentTNode.type & (2 | 8)) {
            break;
          }
        } else {
          break;
        }
      }
      if (parentTNode === null) {
        return false;
      } else {
        tNode = parentTNode;
        lView = parentLView;
      }
    }
    ngDevMode && assertTNodeForLView(tNode, lView);
    const lFrame = instructionState.lFrame = allocLFrame();
    lFrame.currentTNode = tNode;
    lFrame.lView = lView;
    return true;
  }
  function enterView(newView) {
    ngDevMode && assertNotEqual(newView[0], newView[1], '????');
    ngDevMode && assertLViewOrUndefined(newView);
    const newLFrame = allocLFrame();
    if (ngDevMode) {
      assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');
      assertEqual(newLFrame.lView, null, 'Expected clean LFrame');
      assertEqual(newLFrame.tView, null, 'Expected clean LFrame');
      assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');
      assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');
      assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');
      assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');
      assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');
      assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');
    }
    const tView = newView[TVIEW];
    instructionState.lFrame = newLFrame;
    ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
    newLFrame.currentTNode = tView.firstChild;
    newLFrame.lView = newView;
    newLFrame.tView = tView;
    newLFrame.contextLView = newView;
    newLFrame.bindingIndex = tView.bindingStartIndex;
    newLFrame.inI18n = false;
  }
  function allocLFrame() {
    const currentLFrame = instructionState.lFrame;
    const childLFrame = currentLFrame === null ? null : currentLFrame.child;
    const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
    return newLFrame;
  }
  function createLFrame(parent) {
    const lFrame = {
      currentTNode: null,
      isParent: true,
      lView: null,
      tView: null,
      selectedIndex: -1,
      contextLView: null,
      elementDepthCount: 0,
      currentNamespace: null,
      currentDirectiveIndex: -1,
      bindingRootIndex: -1,
      bindingIndex: -1,
      currentQueryIndex: 0,
      parent,
      child: null,
      inI18n: false
    };
    parent !== null && (parent.child = lFrame);
    return lFrame;
  }
  function leaveViewLight() {
    const oldLFrame = instructionState.lFrame;
    instructionState.lFrame = oldLFrame.parent;
    oldLFrame.currentTNode = null;
    oldLFrame.lView = null;
    return oldLFrame;
  }
  var leaveDI = leaveViewLight;
  function leaveView() {
    const oldLFrame = leaveViewLight();
    oldLFrame.isParent = true;
    oldLFrame.tView = null;
    oldLFrame.selectedIndex = -1;
    oldLFrame.contextLView = null;
    oldLFrame.elementDepthCount = 0;
    oldLFrame.currentDirectiveIndex = -1;
    oldLFrame.currentNamespace = null;
    oldLFrame.bindingRootIndex = -1;
    oldLFrame.bindingIndex = -1;
    oldLFrame.currentQueryIndex = 0;
  }
  function nextContextImpl(level) {
    const contextLView = instructionState.lFrame.contextLView =
        walkUpViews(level, instructionState.lFrame.contextLView);
    return contextLView[CONTEXT];
  }
  function walkUpViews(nestingLevel, currentView) {
    while (nestingLevel > 0) {
      ngDevMode &&
          assertDefined(
              currentView[DECLARATION_VIEW],
              'Declaration view should be defined if nesting level is greater than 0.');
      currentView = currentView[DECLARATION_VIEW];
      nestingLevel--;
    }
    return currentView;
  }
  function getSelectedIndex() {
    return instructionState.lFrame.selectedIndex;
  }
  function setSelectedIndex(index) {
    ngDevMode && index !== -1 &&
        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');
    ngDevMode &&
        assertLessThan(
            index, instructionState.lFrame.lView.length, 'Can\'t set index passed end of LView');
    instructionState.lFrame.selectedIndex = index;
  }
  function getSelectedTNode() {
    const lFrame = instructionState.lFrame;
    return getTNode(lFrame.tView, lFrame.selectedIndex);
  }
  function \u0275\u0275namespaceSVG() {
    instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
  }
  function \u0275\u0275namespaceMathML() {
    instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
  }
  function \u0275\u0275namespaceHTML() {
    namespaceHTMLInternal();
  }
  function namespaceHTMLInternal() {
    instructionState.lFrame.currentNamespace = null;
  }
  function getNamespace() {
    return instructionState.lFrame.currentNamespace;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
    ngDevMode && assertFirstCreatePass(tView);
    const {ngOnChanges, ngOnInit, ngDoCheck} = directiveDef.type.prototype;
    if (ngOnChanges) {
      const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
      (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, wrappedOnChanges);
      (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = []))
          .push(directiveIndex, wrappedOnChanges);
    }
    if (ngOnInit) {
      (tView.preOrderHooks || (tView.preOrderHooks = [])).push(0 - directiveIndex, ngOnInit);
    }
    if (ngDoCheck) {
      (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, ngDoCheck);
      (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, ngDoCheck);
    }
  }
  function registerPostOrderHooks(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView);
    for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
      const directiveDef = tView.data[i];
      ngDevMode && assertDefined(directiveDef, 'Expecting DirectiveDef');
      const lifecycleHooks = directiveDef.type.prototype;
      const {
        ngAfterContentInit,
        ngAfterContentChecked,
        ngAfterViewInit,
        ngAfterViewChecked,
        ngOnDestroy
      } = lifecycleHooks;
      if (ngAfterContentInit) {
        (tView.contentHooks || (tView.contentHooks = [])).push(-i, ngAfterContentInit);
      }
      if (ngAfterContentChecked) {
        (tView.contentHooks || (tView.contentHooks = [])).push(i, ngAfterContentChecked);
        (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, ngAfterContentChecked);
      }
      if (ngAfterViewInit) {
        (tView.viewHooks || (tView.viewHooks = [])).push(-i, ngAfterViewInit);
      }
      if (ngAfterViewChecked) {
        (tView.viewHooks || (tView.viewHooks = [])).push(i, ngAfterViewChecked);
        (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, ngAfterViewChecked);
      }
      if (ngOnDestroy != null) {
        (tView.destroyHooks || (tView.destroyHooks = [])).push(i, ngOnDestroy);
      }
    }
  }
  function executeCheckHooks(lView, hooks, nodeIndex) {
    callHooks(lView, hooks, 3, nodeIndex);
  }
  function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
    ngDevMode &&
        assertNotEqual(initPhase, 3, 'Init pre-order hooks should not be called more than once');
    if ((lView[FLAGS] & 3) === initPhase) {
      callHooks(lView, hooks, initPhase, nodeIndex);
    }
  }
  function incrementInitPhaseFlags(lView, initPhase) {
    ngDevMode &&
        assertNotEqual(
            initPhase, 3,
            'Init hooks phase should not be incremented after all init hooks have been run.');
    let flags = lView[FLAGS];
    if ((flags & 3) === initPhase) {
      flags &= 2047;
      flags += 1;
      lView[FLAGS] = flags;
    }
  }
  function callHooks(currentView, arr, initPhase, currentNodeIndex) {
    ngDevMode &&
        assertEqual(
            isInCheckNoChangesMode(), false,
            'Hooks should never be run when in check no changes mode.');
    const startIndex = currentNodeIndex !== void 0 ? currentView[PREORDER_HOOK_FLAGS] & 65535 : 0;
    const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
    const max2 = arr.length - 1;
    let lastNodeIndexFound = 0;
    for (let i = startIndex; i < max2; i++) {
      const hook = arr[i + 1];
      if (typeof hook === 'number') {
        lastNodeIndexFound = arr[i];
        if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
          break;
        }
      } else {
        const isInitHook = arr[i] < 0;
        if (isInitHook) currentView[PREORDER_HOOK_FLAGS] += 65536;
        if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
          callHook(currentView, initPhase, arr, i);
          currentView[PREORDER_HOOK_FLAGS] =
              (currentView[PREORDER_HOOK_FLAGS] & 4294901760) + i + 2;
        }
        i++;
      }
    }
  }
  function callHook(currentView, initPhase, arr, i) {
    const isInitHook = arr[i] < 0;
    const hook = arr[i + 1];
    const directiveIndex = isInitHook ? -arr[i] : arr[i];
    const directive = currentView[directiveIndex];
    if (isInitHook) {
      const indexWithintInitPhase = currentView[FLAGS] >> 11;
      if (indexWithintInitPhase<currentView[PREORDER_HOOK_FLAGS]> > 16 &&
          (currentView[FLAGS] & 3) === initPhase) {
        currentView[FLAGS] += 2048;
        hook.call(directive);
      }
    } else {
      hook.call(directive);
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NO_PARENT_INJECTOR = -1;
  var NodeInjectorFactory = class {
    constructor(factory, isViewProvider, injectImplementation) {
      this.factory = factory;
      this.resolving = false;
      ngDevMode && assertDefined(factory, 'Factory not specified');
      ngDevMode && assertEqual(typeof factory, 'function', 'Expected factory function.');
      this.canSeeViewProviders = isViewProvider;
      this.injectImpl = injectImplementation;
    }
  };
  function isFactory(obj) {
    return obj instanceof NodeInjectorFactory;
  }
  var unusedValueExportToPlacateAjd$3 = 1;
  function toTNodeTypeAsString(tNodeType) {
    let text = '';
    tNodeType&1 && (text += '|Text');
    tNodeType&2 && (text += '|Element');
    tNodeType&4 && (text += '|Container');
    tNodeType&8 && (text += '|ElementContainer');
    tNodeType&16 && (text += '|Projection');
    tNodeType&32 && (text += '|IcuContainer');
    tNodeType&64 && (text += '|Placeholder');
    return text.length > 0 ? text.substring(1) : text;
  }
  var unusedValueExportToPlacateAjd$4 = 1;
  function hasClassInput(tNode) {
    return (tNode.flags & 16) !== 0;
  }
  function hasStyleInput(tNode) {
    return (tNode.flags & 32) !== 0;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function assertTNodeType(tNode, expectedTypes, message) {
    assertDefined(tNode, 'should be called with a TNode');
    if ((tNode.type & expectedTypes) === 0) {
      throwError2(
          message ||
          `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${
              toTNodeTypeAsString(tNode.type)}.`);
    }
  }
  function assertPureTNodeType(type) {
    if (!(type === 2 || type === 1 || type === 4 || type === 8 || type === 32 || type === 16 ||
          type === 64)) {
      throwError2(`Expected TNodeType to have only a single type selected, but got ${
          toTNodeTypeAsString(type)}.`);
    }
  }
  function setUpAttributes(renderer, native, attrs) {
    const isProc = isProceduralRenderer(renderer);
    let i = 0;
    while (i < attrs.length) {
      const value = attrs[i];
      if (typeof value === 'number') {
        if (value !== 0) {
          break;
        }
        i++;
        const namespaceURI = attrs[i++];
        const attrName = attrs[i++];
        const attrVal = attrs[i++];
        ngDevMode && ngDevMode.rendererSetAttribute++;
        isProc ? renderer.setAttribute(native, attrName, attrVal, namespaceURI) :
                 native.setAttributeNS(namespaceURI, attrName, attrVal);
      } else {
        const attrName = value;
        const attrVal = attrs[++i];
        ngDevMode && ngDevMode.rendererSetAttribute++;
        if (isAnimationProp(attrName)) {
          if (isProc) {
            renderer.setProperty(native, attrName, attrVal);
          }
        } else {
          isProc ? renderer.setAttribute(native, attrName, attrVal) :
                   native.setAttribute(attrName, attrVal);
        }
        i++;
      }
    }
    return i;
  }
  function isNameOnlyAttributeMarker(marker) {
    return marker === 3 || marker === 4 || marker === 6;
  }
  function isAnimationProp(name) {
    return name.charCodeAt(0) === 64;
  }
  function mergeHostAttrs(dst, src) {
    if (src === null || src.length === 0) {
    } else if (dst === null || dst.length === 0) {
      dst = src.slice();
    } else {
      let srcMarker = -1;
      for (let i = 0; i < src.length; i++) {
        const item = src[i];
        if (typeof item === 'number') {
          srcMarker = item;
        } else {
          if (srcMarker === 0) {
          } else if (srcMarker === -1 || srcMarker === 2) {
            mergeHostAttribute(dst, srcMarker, item, null, src[++i]);
          } else {
            mergeHostAttribute(dst, srcMarker, item, null, null);
          }
        }
      }
    }
    return dst;
  }
  function mergeHostAttribute(dst, marker, key1, key2, value) {
    let i = 0;
    let markerInsertPosition = dst.length;
    if (marker === -1) {
      markerInsertPosition = -1;
    } else {
      while (i < dst.length) {
        const dstValue = dst[i++];
        if (typeof dstValue === 'number') {
          if (dstValue === marker) {
            markerInsertPosition = -1;
            break;
          } else if (dstValue > marker) {
            markerInsertPosition = i - 1;
            break;
          }
        }
      }
    }
    while (i < dst.length) {
      const item = dst[i];
      if (typeof item === 'number') {
        break;
      } else if (item === key1) {
        if (key2 === null) {
          if (value !== null) {
            dst[i + 1] = value;
          }
          return;
        } else if (key2 === dst[i + 1]) {
          dst[i + 2] = value;
          return;
        }
      }
      i++;
      if (key2 !== null) i++;
      if (value !== null) i++;
    }
    if (markerInsertPosition !== -1) {
      dst.splice(markerInsertPosition, 0, marker);
      i = markerInsertPosition + 1;
    }
    dst.splice(i++, 0, key1);
    if (key2 !== null) {
      dst.splice(i++, 0, key2);
    }
    if (value !== null) {
      dst.splice(i++, 0, value);
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function hasParentInjector(parentLocation) {
    return parentLocation !== NO_PARENT_INJECTOR;
  }
  function getParentInjectorIndex(parentLocation) {
    ngDevMode && assertNumber(parentLocation, 'Number expected');
    ngDevMode && assertNotEqual(parentLocation, -1, 'Not a valid state.');
    const parentInjectorIndex = parentLocation & 32767;
    ngDevMode &&
        assertGreaterThan(
            parentInjectorIndex, HEADER_OFFSET,
            'Parent injector must be pointing past HEADER_OFFSET.');
    return parentLocation & 32767;
  }
  function getParentInjectorViewOffset(parentLocation) {
    return parentLocation >> 16;
  }
  function getParentInjectorView(location2, startView) {
    let viewOffset = getParentInjectorViewOffset(location2);
    let parentView = startView;
    while (viewOffset > 0) {
      parentView = parentView[DECLARATION_VIEW];
      viewOffset--;
    }
    return parentView;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var includeViewProviders = true;
  function setIncludeViewProviders(v) {
    const oldValue = includeViewProviders;
    includeViewProviders = v;
    return oldValue;
  }
  var BLOOM_SIZE = 256;
  var BLOOM_MASK = BLOOM_SIZE - 1;
  var nextNgElementId = 0;
  function bloomAdd(injectorIndex, tView, type) {
    ngDevMode && assertEqual(tView.firstCreatePass, true, 'expected firstCreatePass to be true');
    let id;
    if (typeof type === 'string') {
      id = type.charCodeAt(0) || 0;
    } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {
      id = type[NG_ELEMENT_ID];
    }
    if (id == null) {
      id = type[NG_ELEMENT_ID] = nextNgElementId++;
    }
    const bloomBit = id & BLOOM_MASK;
    const mask = 1 << bloomBit;
    const b7 = bloomBit & 128;
    const b6 = bloomBit & 64;
    const b5 = bloomBit & 32;
    const tData = tView.data;
    if (b7) {
      b6 ? b5 ? tData[injectorIndex + 7] |= mask : tData[injectorIndex + 6] |= mask :
           b5 ? tData[injectorIndex + 5] |= mask : tData[injectorIndex + 4] |= mask;
    } else {
      b6 ? b5 ? tData[injectorIndex + 3] |= mask : tData[injectorIndex + 2] |= mask :
           b5 ? tData[injectorIndex + 1] |= mask : tData[injectorIndex] |= mask;
    }
  }
  function getOrCreateNodeInjectorForNode(tNode, lView) {
    const existingInjectorIndex = getInjectorIndex(tNode, lView);
    if (existingInjectorIndex !== -1) {
      return existingInjectorIndex;
    }
    const tView = lView[TVIEW];
    if (tView.firstCreatePass) {
      tNode.injectorIndex = lView.length;
      insertBloom(tView.data, tNode);
      insertBloom(lView, null);
      insertBloom(tView.blueprint, null);
    }
    const parentLoc = getParentInjectorLocation(tNode, lView);
    const injectorIndex = tNode.injectorIndex;
    if (hasParentInjector(parentLoc)) {
      const parentIndex = getParentInjectorIndex(parentLoc);
      const parentLView = getParentInjectorView(parentLoc, lView);
      const parentData = parentLView[TVIEW].data;
      for (let i = 0; i < 8; i++) {
        lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
      }
    }
    lView[injectorIndex + 8] = parentLoc;
    return injectorIndex;
  }
  function insertBloom(arr, footer) {
    arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
  }
  function getInjectorIndex(tNode, lView) {
    if (tNode.injectorIndex === -1 ||
        tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex ||
        lView[tNode.injectorIndex + 8] === null) {
      return -1;
    } else {
      ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);
      return tNode.injectorIndex;
    }
  }
  function getParentInjectorLocation(tNode, lView) {
    if (tNode.parent && tNode.parent.injectorIndex !== -1) {
      return tNode.parent.injectorIndex;
    }
    let declarationViewOffset = 0;
    let parentTNode = null;
    let lViewCursor = lView;
    while (lViewCursor !== null) {
      const tView = lViewCursor[TVIEW];
      const tViewType = tView.type;
      if (tViewType === 2) {
        ngDevMode &&
            assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');
        parentTNode = tView.declTNode;
      } else if (tViewType === 1) {
        parentTNode = lViewCursor[T_HOST];
      } else {
        ngDevMode && assertEqual(tView.type, 0, 'Root type expected');
        parentTNode = null;
      }
      if (parentTNode === null) {
        return NO_PARENT_INJECTOR;
      }
      ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);
      declarationViewOffset++;
      lViewCursor = lViewCursor[DECLARATION_VIEW];
      if (parentTNode.injectorIndex !== -1) {
        return parentTNode.injectorIndex | declarationViewOffset << 16;
      }
    }
    return NO_PARENT_INJECTOR;
  }
  function diPublicInInjector(injectorIndex, tView, token) {
    bloomAdd(injectorIndex, tView, token);
  }
  function injectAttributeImpl(tNode, attrNameToInject) {
    ngDevMode && assertTNodeType(tNode, 12 | 3);
    ngDevMode && assertDefined(tNode, 'expecting tNode');
    if (attrNameToInject === 'class') {
      return tNode.classes;
    }
    if (attrNameToInject === 'style') {
      return tNode.styles;
    }
    const attrs = tNode.attrs;
    if (attrs) {
      const attrsLength = attrs.length;
      let i = 0;
      while (i < attrsLength) {
        const value = attrs[i];
        if (isNameOnlyAttributeMarker(value)) break;
        if (value === 0) {
          i = i + 2;
        } else if (typeof value === 'number') {
          i++;
          while (i < attrsLength && typeof attrs[i] === 'string') {
            i++;
          }
        } else if (value === attrNameToInject) {
          return attrs[i + 1];
        } else {
          i = i + 2;
        }
      }
    }
    return null;
  }
  function notFoundValueOrThrow(notFoundValue, token, flags) {
    if (flags & InjectFlags.Optional) {
      return notFoundValue;
    } else {
      throwProviderNotFoundError(token, 'NodeInjector');
    }
  }
  function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
    if (flags & InjectFlags.Optional && notFoundValue === void 0) {
      notFoundValue = null;
    }
    if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {
      const moduleInjector = lView[INJECTOR];
      const previousInjectImplementation = setInjectImplementation(void 0);
      try {
        if (moduleInjector) {
          return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);
        } else {
          return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
        }
      } finally {
        setInjectImplementation(previousInjectImplementation);
      }
    }
    return notFoundValueOrThrow(notFoundValue, token, flags);
  }
  function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
    if (tNode !== null) {
      const bloomHash = bloomHashBitOrFactory(token);
      if (typeof bloomHash === 'function') {
        if (!enterDI(lView, tNode, flags)) {
          return flags & InjectFlags.Host ?
              notFoundValueOrThrow(notFoundValue, token, flags) :
              lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
        }
        try {
          const value = bloomHash();
          if (value == null && !(flags & InjectFlags.Optional)) {
            throwProviderNotFoundError(token);
          } else {
            return value;
          }
        } finally {
          leaveDI();
        }
      } else if (typeof bloomHash === 'number') {
        let previousTView = null;
        let injectorIndex = getInjectorIndex(tNode, lView);
        let parentLocation = NO_PARENT_INJECTOR;
        let hostTElementNode =
            flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;
        if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {
          parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) :
                                                  lView[injectorIndex + 8];
          if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
            injectorIndex = -1;
          } else {
            previousTView = lView[TVIEW];
            injectorIndex = getParentInjectorIndex(parentLocation);
            lView = getParentInjectorView(parentLocation, lView);
          }
        }
        while (injectorIndex !== -1) {
          ngDevMode && assertNodeInjector(lView, injectorIndex);
          const tView = lView[TVIEW];
          ngDevMode && assertTNodeForLView(tView.data[injectorIndex + 8], lView);
          if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
            const instance = searchTokensOnInjector(
                injectorIndex, lView, token, previousTView, flags, hostTElementNode);
            if (instance !== NOT_FOUND) {
              return instance;
            }
          }
          parentLocation = lView[injectorIndex + 8];
          if (parentLocation !== NO_PARENT_INJECTOR &&
              shouldSearchParent(
                  flags, lView[TVIEW].data[injectorIndex + 8] === hostTElementNode) &&
              bloomHasToken(bloomHash, injectorIndex, lView)) {
            previousTView = tView;
            injectorIndex = getParentInjectorIndex(parentLocation);
            lView = getParentInjectorView(parentLocation, lView);
          } else {
            injectorIndex = -1;
          }
        }
      }
    }
    return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
  }
  var NOT_FOUND = {};
  function createNodeInjector() {
    return new NodeInjector(getCurrentTNode(), getLView());
  }
  function searchTokensOnInjector(
      injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
    const currentTView = lView[TVIEW];
    const tNode = currentTView.data[injectorIndex + 8];
    const canAccessViewProviders = previousTView == null ?
        isComponentHost(tNode) && includeViewProviders :
        previousTView != currentTView && (tNode.type & 3) !== 0;
    const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;
    const injectableIdx = locateDirectiveOrProvider(
        tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
    if (injectableIdx !== null) {
      return getNodeInjectable(lView, currentTView, injectableIdx, tNode);
    } else {
      return NOT_FOUND;
    }
  }
  function locateDirectiveOrProvider(
      tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
    const nodeProviderIndexes = tNode.providerIndexes;
    const tInjectables = tView.data;
    const injectablesStart = nodeProviderIndexes & 1048575;
    const directivesStart = tNode.directiveStart;
    const directiveEnd = tNode.directiveEnd;
    const cptViewProvidersCount = nodeProviderIndexes >> 20;
    const startingIndex =
        canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
    const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
    for (let i = startingIndex; i < endIndex; i++) {
      const providerTokenOrDef = tInjectables[i];
      if (i < directivesStart && token === providerTokenOrDef ||
          i >= directivesStart && providerTokenOrDef.type === token) {
        return i;
      }
    }
    if (isHostSpecialCase) {
      const dirDef = tInjectables[directivesStart];
      if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {
        return directivesStart;
      }
    }
    return null;
  }
  function getNodeInjectable(lView, tView, index, tNode) {
    let value = lView[index];
    const tData = tView.data;
    if (isFactory(value)) {
      const factory = value;
      if (factory.resolving) {
        throwCyclicDependencyError(stringifyForError(tData[index]));
      }
      const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
      factory.resolving = true;
      const previousInjectImplementation =
          factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;
      const success = enterDI(lView, tNode, InjectFlags.Default);
      ngDevMode &&
          assertEqual(
              success, true,
              'Because flags do not contain `SkipSelf\' we expect this to always succeed.');
      try {
        value = lView[index] = factory.factory(void 0, tData, lView, tNode);
        if (tView.firstCreatePass && index >= tNode.directiveStart) {
          ngDevMode && assertDirectiveDef(tData[index]);
          registerPreOrderHooks(index, tData[index], tView);
        }
      } finally {
        previousInjectImplementation !== null &&
            setInjectImplementation(previousInjectImplementation);
        setIncludeViewProviders(previousIncludeViewProviders);
        factory.resolving = false;
        leaveDI();
      }
    }
    return value;
  }
  function bloomHashBitOrFactory(token) {
    ngDevMode && assertDefined(token, 'token must be defined');
    if (typeof token === 'string') {
      return token.charCodeAt(0) || 0;
    }
    const tokenId = token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : void 0;
    if (typeof tokenId === 'number') {
      if (tokenId >= 0) {
        return tokenId & BLOOM_MASK;
      } else {
        ngDevMode && assertEqual(tokenId, -1, 'Expecting to get Special Injector Id');
        return createNodeInjector;
      }
    } else {
      return tokenId;
    }
  }
  function bloomHasToken(bloomHash, injectorIndex, injectorView) {
    const mask = 1 << bloomHash;
    const b7 = bloomHash & 128;
    const b6 = bloomHash & 64;
    const b5 = bloomHash & 32;
    let value;
    if (b7) {
      value = b6 ? b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6] :
                   b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4];
    } else {
      value = b6 ? b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2] :
                   b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex];
    }
    return !!(value & mask);
  }
  function shouldSearchParent(flags, isFirstHostTNode) {
    return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);
  }
  var NodeInjector = class {
    constructor(_tNode, _lView) {
      this._tNode = _tNode;
      this._lView = _lView;
    }
    get(token, notFoundValue) {
      return getOrCreateInjectable(this._tNode, this._lView, token, void 0, notFoundValue);
    }
  };
  function \u0275\u0275getFactoryOf(type) {
    const typeAny = type;
    if (isForwardRef(type)) {
      return () => {
        const factory2 = \u0275\u0275getFactoryOf(resolveForwardRef(typeAny));
        return factory2 ? factory2() : null;
      };
    }
    let factory = getFactoryDef(typeAny);
    if (factory === null) {
      const injectorDef = getInjectorDef(typeAny);
      factory = injectorDef && injectorDef.factory;
    }
    return factory || null;
  }
  function \u0275\u0275getInheritedFactory(type) {
    return noSideEffects(() => {
      const ownConstructor = type.prototype.constructor;
      const ownFactory = ownConstructor[NG_FACTORY_DEF] || \u0275\u0275getFactoryOf(ownConstructor);
      const objectPrototype = Object.prototype;
      let parent = Object.getPrototypeOf(type.prototype).constructor;
      while (parent && parent !== objectPrototype) {
        const factory = parent[NG_FACTORY_DEF] || \u0275\u0275getFactoryOf(parent);
        if (factory && factory !== ownFactory) {
          return factory;
        }
        parent = Object.getPrototypeOf(parent);
      }
      return (t) => new t();
    });
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275injectAttribute(attrNameToInject) {
    return injectAttributeImpl(getCurrentTNode(), attrNameToInject);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ANNOTATIONS = '__annotations__';
  var PARAMETERS = '__parameters__';
  var PROP_METADATA = '__prop__metadata__';
  function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
    return noSideEffects(() => {
      const metaCtor = makeMetadataCtor(props);
      function DecoratorFactory(...args) {
        if (this instanceof DecoratorFactory) {
          metaCtor.call(this, ...args);
          return this;
        }
        const annotationInstance = new DecoratorFactory(...args);
        return function TypeDecorator(cls) {
          if (typeFn) typeFn(cls, ...args);
          const annotations = cls.hasOwnProperty(ANNOTATIONS) ?
              cls[ANNOTATIONS] :
              Object.defineProperty(cls, ANNOTATIONS, {value: []})[ANNOTATIONS];
          annotations.push(annotationInstance);
          if (additionalProcessing) additionalProcessing(cls);
          return cls;
        };
      }
      if (parentClass) {
        DecoratorFactory.prototype = Object.create(parentClass.prototype);
      }
      DecoratorFactory.prototype.ngMetadataName = name;
      DecoratorFactory.annotationCls = DecoratorFactory;
      return DecoratorFactory;
    });
  }
  function makeMetadataCtor(props) {
    return function ctor(...args) {
      if (props) {
        const values = props(...args);
        for (const propName in values) {
          this[propName] = values[propName];
        }
      }
    };
  }
  function makeParamDecorator(name, props, parentClass) {
    return noSideEffects(() => {
      const metaCtor = makeMetadataCtor(props);
      function ParamDecoratorFactory(...args) {
        if (this instanceof ParamDecoratorFactory) {
          metaCtor.apply(this, args);
          return this;
        }
        const annotationInstance = new ParamDecoratorFactory(...args);
        ParamDecorator.annotation = annotationInstance;
        return ParamDecorator;
        function ParamDecorator(cls, unusedKey, index) {
          const parameters = cls.hasOwnProperty(PARAMETERS) ?
              cls[PARAMETERS] :
              Object.defineProperty(cls, PARAMETERS, {value: []})[PARAMETERS];
          while (parameters.length <= index) {
            parameters.push(null);
          }
          (parameters[index] = parameters[index] || []).push(annotationInstance);
          return cls;
        }
      }
      if (parentClass) {
        ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
      }
      ParamDecoratorFactory.prototype.ngMetadataName = name;
      ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
      return ParamDecoratorFactory;
    });
  }
  function makePropDecorator(name, props, parentClass, additionalProcessing) {
    return noSideEffects(() => {
      const metaCtor = makeMetadataCtor(props);
      function PropDecoratorFactory(...args) {
        if (this instanceof PropDecoratorFactory) {
          metaCtor.apply(this, args);
          return this;
        }
        const decoratorInstance = new PropDecoratorFactory(...args);
        function PropDecorator(target, name2) {
          const constructor = target.constructor;
          const meta = constructor.hasOwnProperty(PROP_METADATA) ?
              constructor[PROP_METADATA] :
              Object.defineProperty(constructor, PROP_METADATA, {value: {}})[PROP_METADATA];
          meta[name2] = meta.hasOwnProperty(name2) && meta[name2] || [];
          meta[name2].unshift(decoratorInstance);
          if (additionalProcessing) additionalProcessing(target, name2, ...args);
        }
        return PropDecorator;
      }
      if (parentClass) {
        PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
      }
      PropDecoratorFactory.prototype.ngMetadataName = name;
      PropDecoratorFactory.annotationCls = PropDecoratorFactory;
      return PropDecoratorFactory;
    });
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function CREATE_ATTRIBUTE_DECORATOR__POST_R3__() {
    return makeParamDecorator(
        'Attribute',
        (attributeName) =>
            ({attributeName, __NG_ELEMENT_ID__: () => \u0275\u0275injectAttribute(attributeName)}));
  }
  var CREATE_ATTRIBUTE_DECORATOR_IMPL = CREATE_ATTRIBUTE_DECORATOR__POST_R3__;
  var Attribute = CREATE_ATTRIBUTE_DECORATOR_IMPL();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var InjectionToken = class {
    constructor(_desc, options) {
      this._desc = _desc;
      this.ngMetadataName = 'InjectionToken';
      this.\u0275prov = void 0;
      if (typeof options == 'number') {
        (typeof ngDevMode === 'undefined' || ngDevMode) &&
            assertLessThan(options, 0, 'Only negative numbers are supported here');
        this.__NG_ELEMENT_ID__ = options;
      } else if (options !== void 0) {
        this.\u0275prov = \u0275\u0275defineInjectable(
            {token: this, providedIn: options.providedIn || 'root', factory: options.factory});
      }
    }
    toString() {
      return `InjectionToken ${this._desc}`;
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken('AnalyzeForEntryComponents');
  var Query = class {};
  var \u02750$1 = (selector, data = {}) =>
      Object.assign({selector, first: false, isViewQuery: false, descendants: false}, data);
  var ContentChildren = makePropDecorator('ContentChildren', \u02750$1, Query);
  var \u02751 = (selector, data = {}) =>
      Object.assign({selector, first: true, isViewQuery: false, descendants: true}, data);
  var ContentChild = makePropDecorator('ContentChild', \u02751, Query);
  var \u02752 = (selector, data = {}) =>
      Object.assign({selector, first: false, isViewQuery: true, descendants: true}, data);
  var ViewChildren = makePropDecorator('ViewChildren', \u02752, Query);
  var \u02753 = (selector, data) =>
      Object.assign({selector, first: true, isViewQuery: true, descendants: true}, data);
  var ViewChild = makePropDecorator('ViewChild', \u02753, Query);
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var R3ResolvedDependencyType;
  (function(R3ResolvedDependencyType2) {
    R3ResolvedDependencyType2[R3ResolvedDependencyType2['Token'] = 0] = 'Token';
    R3ResolvedDependencyType2[R3ResolvedDependencyType2['Attribute'] = 1] = 'Attribute';
    R3ResolvedDependencyType2[R3ResolvedDependencyType2['ChangeDetectorRef'] = 2] =
        'ChangeDetectorRef';
    R3ResolvedDependencyType2[R3ResolvedDependencyType2['Invalid'] = 3] = 'Invalid';
  })(R3ResolvedDependencyType || (R3ResolvedDependencyType = {}));
  var R3FactoryTarget;
  (function(R3FactoryTarget2) {
    R3FactoryTarget2[R3FactoryTarget2['Directive'] = 0] = 'Directive';
    R3FactoryTarget2[R3FactoryTarget2['Component'] = 1] = 'Component';
    R3FactoryTarget2[R3FactoryTarget2['Injectable'] = 2] = 'Injectable';
    R3FactoryTarget2[R3FactoryTarget2['Pipe'] = 3] = 'Pipe';
    R3FactoryTarget2[R3FactoryTarget2['NgModule'] = 4] = 'NgModule';
  })(R3FactoryTarget || (R3FactoryTarget = {}));
  var ViewEncapsulation$1;
  (function(ViewEncapsulation2) {
    ViewEncapsulation2[ViewEncapsulation2['Emulated'] = 0] = 'Emulated';
    ViewEncapsulation2[ViewEncapsulation2['None'] = 2] = 'None';
    ViewEncapsulation2[ViewEncapsulation2['ShadowDom'] = 3] = 'ShadowDom';
  })(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function getCompilerFacade() {
    const globalNg = _global['ng'];
    if (!globalNg || !globalNg.\u0275compilerFacade) {
      throw new Error(`Angular JIT compilation failed: '@angular/compiler' not loaded!
  - JIT compilation is discouraged for production use-cases! Consider AOT mode instead.
  - Did you bootstrap using '@angular/platform-browser-dynamic' or '@angular/platform-server'?
  - Alternatively provide the compiler with 'import "@angular/compiler";' before bootstrapping.`);
    }
    return globalNg.\u0275compilerFacade;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var Type = Function;
  function isType(v) {
    return typeof v === 'function';
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function flatten(list, dst) {
    if (dst === void 0) dst = list;
    for (let i = 0; i < list.length; i++) {
      let item = list[i];
      if (Array.isArray(item)) {
        if (dst === list) {
          dst = list.slice(0, i);
        }
        flatten(item, dst);
      } else if (dst !== list) {
        dst.push(item);
      }
    }
    return dst;
  }
  function deepForEach(input, fn) {
    input.forEach((value) => Array.isArray(value) ? deepForEach(value, fn) : fn(value));
  }
  function addToArray(arr, index, value) {
    if (index >= arr.length) {
      arr.push(value);
    } else {
      arr.splice(index, 0, value);
    }
  }
  function removeFromArray(arr, index) {
    if (index >= arr.length - 1) {
      return arr.pop();
    } else {
      return arr.splice(index, 1)[0];
    }
  }
  function newArray(size, value) {
    const list = [];
    for (let i = 0; i < size; i++) {
      list.push(value);
    }
    return list;
  }
  function arrayInsert2(array, index, value1, value2) {
    ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\'t insert past array end.');
    let end = array.length;
    if (end == index) {
      array.push(value1, value2);
    } else if (end === 1) {
      array.push(value2, array[0]);
      array[0] = value1;
    } else {
      end--;
      array.push(array[end - 1], array[end]);
      while (end > index) {
        const previousEnd = end - 2;
        array[end] = array[previousEnd];
        end--;
      }
      array[index] = value1;
      array[index + 1] = value2;
    }
  }
  function keyValueArraySet(keyValueArray, key, value) {
    let index = keyValueArrayIndexOf(keyValueArray, key);
    if (index >= 0) {
      keyValueArray[index | 1] = value;
    } else {
      index = ~index;
      arrayInsert2(keyValueArray, index, key, value);
    }
    return index;
  }
  function keyValueArrayGet(keyValueArray, key) {
    const index = keyValueArrayIndexOf(keyValueArray, key);
    if (index >= 0) {
      return keyValueArray[index | 1];
    }
    return void 0;
  }
  function keyValueArrayIndexOf(keyValueArray, key) {
    return _arrayIndexOfSorted(keyValueArray, key, 1);
  }
  function _arrayIndexOfSorted(array, value, shift) {
    ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');
    let start = 0;
    let end = array.length >> shift;
    while (end !== start) {
      const middle = start + (end - start >> 1);
      const current = array[middle << shift];
      if (value === current) {
        return middle << shift;
      } else if (current > value) {
        end = middle;
      } else {
        start = middle + 1;
      }
    }
    return ~(end << shift);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ES5_DELEGATE_CTOR =
      /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|[^()]+\(arguments\))\)/;
  var ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
  var ES2015_INHERITED_CLASS_WITH_CTOR =
      /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
  var ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR =
      /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{\s*super\(\.\.\.arguments\)/;
  function isDelegateCtor(typeStr) {
    return ES5_DELEGATE_CTOR.test(typeStr) ||
        ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) ||
        ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
  }
  var ReflectionCapabilities = class {
    constructor(reflect) {
      this._reflect = reflect || _global['Reflect'];
    }
    isReflectionEnabled() {
      return true;
    }
    factory(t) {
      return (...args) => new t(...args);
    }
    _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
      let result;
      if (typeof paramTypes === 'undefined') {
        result = newArray(paramAnnotations.length);
      } else {
        result = newArray(paramTypes.length);
      }
      for (let i = 0; i < result.length; i++) {
        if (typeof paramTypes === 'undefined') {
          result[i] = [];
        } else if (paramTypes[i] && paramTypes[i] != Object) {
          result[i] = [paramTypes[i]];
        } else {
          result[i] = [];
        }
        if (paramAnnotations && paramAnnotations[i] != null) {
          result[i] = result[i].concat(paramAnnotations[i]);
        }
      }
      return result;
    }
    _ownParameters(type, parentCtor) {
      const typeStr = type.toString();
      if (isDelegateCtor(typeStr)) {
        return null;
      }
      if (type.parameters && type.parameters !== parentCtor.parameters) {
        return type.parameters;
      }
      const tsickleCtorParams = type.ctorParameters;
      if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
        const ctorParameters =
            typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;
        const paramTypes2 = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);
        const paramAnnotations2 = ctorParameters.map(
            (ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
        return this._zipTypesAndAnnotations(paramTypes2, paramAnnotations2);
      }
      const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];
      const paramTypes = this._reflect && this._reflect.getOwnMetadata &&
          this._reflect.getOwnMetadata('design:paramtypes', type);
      if (paramTypes || paramAnnotations) {
        return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
      }
      return newArray(type.length);
    }
    parameters(type) {
      if (!isType(type)) {
        return [];
      }
      const parentCtor = getParentCtor(type);
      let parameters = this._ownParameters(type, parentCtor);
      if (!parameters && parentCtor !== Object) {
        parameters = this.parameters(parentCtor);
      }
      return parameters || [];
    }
    _ownAnnotations(typeOrFunc, parentCtor) {
      if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
        let annotations = typeOrFunc.annotations;
        if (typeof annotations === 'function' && annotations.annotations) {
          annotations = annotations.annotations;
        }
        return annotations;
      }
      if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
        return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
      }
      if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
        return typeOrFunc[ANNOTATIONS];
      }
      return null;
    }
    annotations(typeOrFunc) {
      if (!isType(typeOrFunc)) {
        return [];
      }
      const parentCtor = getParentCtor(typeOrFunc);
      const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
      const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
      return parentAnnotations.concat(ownAnnotations);
    }
    _ownPropMetadata(typeOrFunc, parentCtor) {
      if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
        let propMetadata = typeOrFunc.propMetadata;
        if (typeof propMetadata === 'function' && propMetadata.propMetadata) {
          propMetadata = propMetadata.propMetadata;
        }
        return propMetadata;
      }
      if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
        const propDecorators = typeOrFunc.propDecorators;
        const propMetadata = {};
        Object.keys(propDecorators).forEach((prop) => {
          propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
        });
        return propMetadata;
      }
      if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
        return typeOrFunc[PROP_METADATA];
      }
      return null;
    }
    propMetadata(typeOrFunc) {
      if (!isType(typeOrFunc)) {
        return {};
      }
      const parentCtor = getParentCtor(typeOrFunc);
      const propMetadata = {};
      if (parentCtor !== Object) {
        const parentPropMetadata = this.propMetadata(parentCtor);
        Object.keys(parentPropMetadata).forEach((propName) => {
          propMetadata[propName] = parentPropMetadata[propName];
        });
      }
      const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
      if (ownPropMetadata) {
        Object.keys(ownPropMetadata).forEach((propName) => {
          const decorators = [];
          if (propMetadata.hasOwnProperty(propName)) {
            decorators.push(...propMetadata[propName]);
          }
          decorators.push(...ownPropMetadata[propName]);
          propMetadata[propName] = decorators;
        });
      }
      return propMetadata;
    }
    ownPropMetadata(typeOrFunc) {
      if (!isType(typeOrFunc)) {
        return {};
      }
      return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
    }
    hasLifecycleHook(type, lcProperty) {
      return type instanceof Type && lcProperty in type.prototype;
    }
    guards(type) {
      return {};
    }
    getter(name) {
      return new Function('o', 'return o.' + name + ';');
    }
    setter(name) {
      return new Function('o', 'v', 'return o.' + name + ' = v;');
    }
    method(name) {
      const functionBody = `if (!o.${name}) throw new Error('"${name}" is undefined');
        return o.${name}.apply(o, args);`;
      return new Function('o', 'args', functionBody);
    }
    importUri(type) {
      if (typeof type === 'object' && type['filePath']) {
        return type['filePath'];
      }
      return `./${stringify(type)}`;
    }
    resourceUri(type) {
      return `./${stringify(type)}`;
    }
    resolveIdentifier(name, moduleUrl, members, runtime) {
      return runtime;
    }
    resolveEnum(enumIdentifier, name) {
      return enumIdentifier[name];
    }
  };
  function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
    if (!decoratorInvocations) {
      return [];
    }
    return decoratorInvocations.map((decoratorInvocation) => {
      const decoratorType = decoratorInvocation.type;
      const annotationCls = decoratorType.annotationCls;
      const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
      return new annotationCls(...annotationArgs);
    });
  }
  function getParentCtor(ctor) {
    const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
    const parentCtor = parentProto ? parentProto.constructor : null;
    return parentCtor || Object;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var \u02750$2 = (token) => ({token});
  var Inject = makeParamDecorator('Inject', \u02750$2);
  var Optional = makeParamDecorator('Optional');
  var Self = makeParamDecorator('Self');
  var SkipSelf = makeParamDecorator('SkipSelf');
  var Host = makeParamDecorator('Host');
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var _reflect = null;
  function getReflect() {
    return _reflect = _reflect || new ReflectionCapabilities();
  }
  function reflectDependencies(type) {
    return convertDependencies(getReflect().parameters(type));
  }
  function convertDependencies(deps) {
    const compiler = getCompilerFacade();
    return deps.map((dep) => reflectDependency(compiler, dep));
  }
  function reflectDependency(compiler, dep) {
    const meta = {
      token: null,
      host: false,
      optional: false,
      resolved: compiler.R3ResolvedDependencyType.Token,
      self: false,
      skipSelf: false
    };
    function setTokenAndResolvedType(token) {
      meta.resolved = compiler.R3ResolvedDependencyType.Token;
      meta.token = token;
    }
    if (Array.isArray(dep) && dep.length > 0) {
      for (let j = 0; j < dep.length; j++) {
        const param = dep[j];
        if (param === void 0) {
          continue;
        }
        const proto = Object.getPrototypeOf(param);
        if (param instanceof Optional || proto.ngMetadataName === 'Optional') {
          meta.optional = true;
        } else if (param instanceof SkipSelf || proto.ngMetadataName === 'SkipSelf') {
          meta.skipSelf = true;
        } else if (param instanceof Self || proto.ngMetadataName === 'Self') {
          meta.self = true;
        } else if (param instanceof Host || proto.ngMetadataName === 'Host') {
          meta.host = true;
        } else if (param instanceof Inject) {
          meta.token = param.token;
        } else if (param instanceof Attribute) {
          if (param.attributeName === void 0) {
            throw new Error(`Attribute name must be defined.`);
          }
          meta.token = param.attributeName;
          meta.resolved = compiler.R3ResolvedDependencyType.Attribute;
        } else if (param.__ChangeDetectorRef__ === true) {
          meta.token = param;
          meta.resolved = compiler.R3ResolvedDependencyType.ChangeDetectorRef;
        } else {
          setTokenAndResolvedType(param);
        }
      }
    } else if (dep === void 0 || Array.isArray(dep) && dep.length === 0) {
      meta.token = void 0;
      meta.resolved = R3ResolvedDependencyType.Invalid;
    } else {
      setTokenAndResolvedType(dep);
    }
    return meta;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function resolveComponentResources(resourceResolver) {
    const componentResolved = [];
    const urlMap = new Map();
    function cachedResourceResolve(url) {
      let promise2 = urlMap.get(url);
      if (!promise2) {
        const resp = resourceResolver(url);
        urlMap.set(url, promise2 = resp.then(unwrapResponse));
      }
      return promise2;
    }
    componentResourceResolutionQueue.forEach((component, type) => {
      const promises = [];
      if (component.templateUrl) {
        promises.push(cachedResourceResolve(component.templateUrl).then((template) => {
          component.template = template;
        }));
      }
      const styleUrls = component.styleUrls;
      const styles = component.styles || (component.styles = []);
      const styleOffset = component.styles.length;
      styleUrls && styleUrls.forEach((styleUrl, index) => {
        styles.push('');
        promises.push(cachedResourceResolve(styleUrl).then((style) => {
          styles[styleOffset + index] = style;
          styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
          if (styleUrls.length == 0) {
            component.styleUrls = void 0;
          }
        }));
      });
      const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));
      componentResolved.push(fullyResolved);
    });
    clearResolutionOfComponentResourcesQueue();
    return Promise.all(componentResolved).then(() => void 0);
  }
  var componentResourceResolutionQueue = new Map();
  var componentDefPendingResolution = new Set();
  function maybeQueueResolutionOfComponentResources(type, metadata) {
    if (componentNeedsResolution(metadata)) {
      componentResourceResolutionQueue.set(type, metadata);
      componentDefPendingResolution.add(type);
    }
  }
  function componentNeedsResolution(component) {
    return !!(
        component.templateUrl && !component.hasOwnProperty('template') ||
        component.styleUrls && component.styleUrls.length);
  }
  function clearResolutionOfComponentResourcesQueue() {
    const old = componentResourceResolutionQueue;
    componentResourceResolutionQueue = new Map();
    return old;
  }
  function isComponentResourceResolutionQueueEmpty() {
    return componentResourceResolutionQueue.size === 0;
  }
  function unwrapResponse(response) {
    return typeof response == 'string' ? response : response.text();
  }
  function componentDefResolved(type) {
    componentDefPendingResolution.delete(type);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var _THROW_IF_NOT_FOUND = {};
  var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
  var NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';
  var NG_TOKEN_PATH = 'ngTokenPath';
  var NEW_LINE = /\n/gm;
  var NO_NEW_LINE = '\u0275';
  var SOURCE = '__source';
  var \u02750$3 = getClosureSafeProperty;
  var USE_VALUE = getClosureSafeProperty({provide: String, useValue: \u02750$3});
  var _currentInjector = void 0;
  function setCurrentInjector(injector) {
    const former = _currentInjector;
    _currentInjector = injector;
    return former;
  }
  function injectInjectorOnly(token, flags = InjectFlags.Default) {
    if (_currentInjector === void 0) {
      throw new Error(`inject() must be called from an injection context`);
    } else if (_currentInjector === null) {
      return injectRootLimpMode(token, void 0, flags);
    } else {
      return _currentInjector.get(token, flags & InjectFlags.Optional ? null : void 0, flags);
    }
  }
  function \u0275\u0275inject(token, flags = InjectFlags.Default) {
    return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
  }
  function \u0275\u0275invalidFactoryDep(index) {
    const msg = ngDevMode ?
        `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${
            index} of the parameter list is invalid.
This can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.

Please check that 1) the type for the parameter at index ${
            index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.` :
        'invalid';
    throw new Error(msg);
  }
  function injectArgs(types) {
    const args = [];
    for (let i = 0; i < types.length; i++) {
      const arg = resolveForwardRef(types[i]);
      if (Array.isArray(arg)) {
        if (arg.length === 0) {
          throw new Error('Arguments array must have arguments.');
        }
        let type = void 0;
        let flags = InjectFlags.Default;
        for (let j = 0; j < arg.length; j++) {
          const meta = arg[j];
          if (meta instanceof Optional || meta.ngMetadataName === 'Optional' || meta === Optional) {
            flags |= InjectFlags.Optional;
          } else if (
              meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf' || meta === SkipSelf) {
            flags |= InjectFlags.SkipSelf;
          } else if (meta instanceof Self || meta.ngMetadataName === 'Self' || meta === Self) {
            flags |= InjectFlags.Self;
          } else if (meta instanceof Host || meta.ngMetadataName === 'Host' || meta === Host) {
            flags |= InjectFlags.Host;
          } else if (meta instanceof Inject || meta === Inject) {
            type = meta.token;
          } else {
            type = meta;
          }
        }
        args.push(\u0275\u0275inject(type, flags));
      } else {
        args.push(\u0275\u0275inject(arg));
      }
    }
    return args;
  }
  function catchInjectorError(e, token, injectorErrorName, source) {
    const tokenPath = e[NG_TEMP_TOKEN_PATH];
    if (token[SOURCE]) {
      tokenPath.unshift(token[SOURCE]);
    }
    e.message = formatError('\n' + e.message, tokenPath, injectorErrorName, source);
    e[NG_TOKEN_PATH] = tokenPath;
    e[NG_TEMP_TOKEN_PATH] = null;
    throw e;
  }
  function formatError(text, obj, injectorErrorName, source = null) {
    text = text && text.charAt(0) === '\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;
    let context = stringify(obj);
    if (Array.isArray(obj)) {
      context = obj.map(stringify).join(' -> ');
    } else if (typeof obj === 'object') {
      let parts = [];
      for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
          let value = obj[key];
          parts.push(
              key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));
        }
      }
      context = `{${parts.join(', ')}}`;
    }
    return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${
        text.replace(NEW_LINE, '\n  ')}`;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var policy;
  function getPolicy() {
    if (policy === void 0) {
      policy = null;
      if (_global.trustedTypes) {
        try {
          policy = _global.trustedTypes.createPolicy(
              'angular', {createHTML: (s) => s, createScript: (s) => s, createScriptURL: (s) => s});
        } catch (_a) {
        }
      }
    }
    return policy;
  }
  function trustedHTMLFromString(html) {
    var _a;
    return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createHTML(html)) || html;
  }
  function trustedScriptFromString(script) {
    var _a;
    return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScript(script)) ||
        script;
  }
  function trustedScriptURLFromString(url) {
    var _a;
    return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScriptURL(url)) || url;
  }
  function newTrustedFunctionForDev(...args) {
    if (typeof ngDevMode === 'undefined') {
      throw new Error('newTrustedFunctionForDev should never be called in production');
    }
    if (!_global.trustedTypes) {
      return new Function(...args);
    }
    const fnArgs = args.slice(0, -1).join(',');
    const fnBody = args.pop().toString();
    const body = `(function anonymous(${fnArgs}
) { ${fnBody}
})`;
    const fn = _global['eval'](trustedScriptFromString(body));
    fn.toString = () => body;
    return fn.bind(_global);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var SafeValueImpl = class {
    constructor(changingThisBreaksApplicationSecurity) {
      this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
    }
    toString() {
      return `SafeValue must use [property]=binding: ${
          this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`;
    }
  };
  var SafeHtmlImpl = class extends SafeValueImpl {
    getTypeName() {
      return 'HTML';
    }
  };
  var SafeStyleImpl = class extends SafeValueImpl {
    getTypeName() {
      return 'Style';
    }
  };
  var SafeScriptImpl = class extends SafeValueImpl {
    getTypeName() {
      return 'Script';
    }
  };
  var SafeUrlImpl = class extends SafeValueImpl {
    getTypeName() {
      return 'URL';
    }
  };
  var SafeResourceUrlImpl = class extends SafeValueImpl {
    getTypeName() {
      return 'ResourceURL';
    }
  };
  function unwrapSafeValue(value) {
    return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
  }
  function allowSanitizationBypassAndThrow(value, type) {
    const actualType = getSanitizationBypassType(value);
    if (actualType != null && actualType !== type) {
      if (actualType === 'ResourceURL' && type === 'URL') return true;
      throw new Error(
          `Required a safe ${type}, got a ${actualType} (see https://g.co/ng/security#xss)`);
    }
    return actualType === type;
  }
  function getSanitizationBypassType(value) {
    return value instanceof SafeValueImpl && value.getTypeName() || null;
  }
  function bypassSanitizationTrustHtml(trustedHtml) {
    return new SafeHtmlImpl(trustedHtml);
  }
  function bypassSanitizationTrustStyle(trustedStyle) {
    return new SafeStyleImpl(trustedStyle);
  }
  function bypassSanitizationTrustScript(trustedScript) {
    return new SafeScriptImpl(trustedScript);
  }
  function bypassSanitizationTrustUrl(trustedUrl) {
    return new SafeUrlImpl(trustedUrl);
  }
  function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
    return new SafeResourceUrlImpl(trustedResourceUrl);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function getInertBodyHelper(defaultDoc) {
    const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
    return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
  }
  var DOMParserHelper = class {
    constructor(inertDocumentHelper) {
      this.inertDocumentHelper = inertDocumentHelper;
    }
    getInertBodyElement(html) {
      html = '<body><remove></remove>' + html;
      try {
        const body =
            new window.DOMParser().parseFromString(trustedHTMLFromString(html), 'text/html').body;
        if (body === null) {
          return this.inertDocumentHelper.getInertBodyElement(html);
        }
        body.removeChild(body.firstChild);
        return body;
      } catch (_a) {
        return null;
      }
    }
  };
  var InertDocumentHelper = class {
    constructor(defaultDoc) {
      this.defaultDoc = defaultDoc;
      this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');
      if (this.inertDocument.body == null) {
        const inertHtml = this.inertDocument.createElement('html');
        this.inertDocument.appendChild(inertHtml);
        const inertBodyElement = this.inertDocument.createElement('body');
        inertHtml.appendChild(inertBodyElement);
      }
    }
    getInertBodyElement(html) {
      const templateEl = this.inertDocument.createElement('template');
      if ('content' in templateEl) {
        templateEl.innerHTML = trustedHTMLFromString(html);
        return templateEl;
      }
      const inertBody = this.inertDocument.createElement('body');
      inertBody.innerHTML = trustedHTMLFromString(html);
      if (this.defaultDoc.documentMode) {
        this.stripCustomNsAttrs(inertBody);
      }
      return inertBody;
    }
    stripCustomNsAttrs(el) {
      const elAttrs = el.attributes;
      for (let i = elAttrs.length - 1; 0 < i; i--) {
        const attrib = elAttrs.item(i);
        const attrName = attrib.name;
        if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
          el.removeAttribute(attrName);
        }
      }
      let childNode = el.firstChild;
      while (childNode) {
        if (childNode.nodeType === Node.ELEMENT_NODE) this.stripCustomNsAttrs(childNode);
        childNode = childNode.nextSibling;
      }
    }
  };
  function isDOMParserAvailable() {
    try {
      return !!new window.DOMParser().parseFromString(trustedHTMLFromString(''), 'text/html');
    } catch (_a) {
      return false;
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;
  var DATA_URL_PATTERN =
      /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
  function _sanitizeUrl(url) {
    url = String(url);
    if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN)) return url;
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      console.warn(
          `WARNING: sanitizing unsafe URL value ${url} (see https://g.co/ng/security#xss)`);
    }
    return 'unsafe:' + url;
  }
  function sanitizeSrcset(srcset) {
    srcset = String(srcset);
    return srcset.split(',').map((srcset2) => _sanitizeUrl(srcset2.trim())).join(', ');
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function tagSet(tags) {
    const res = {};
    for (const t of tags.split(',')) res[t] = true;
    return res;
  }
  function merge3(...sets) {
    const res = {};
    for (const s of sets) {
      for (const v in s) {
        if (s.hasOwnProperty(v)) res[v] = true;
      }
    }
    return res;
  }
  var VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
  var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
  var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
  var OPTIONAL_END_TAG_ELEMENTS =
      merge3(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
  var BLOCK_ELEMENTS = merge3(
      OPTIONAL_END_TAG_BLOCK_ELEMENTS,
      tagSet(
          'address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
  var INLINE_ELEMENTS = merge3(
      OPTIONAL_END_TAG_INLINE_ELEMENTS,
      tagSet(
          'a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
  var VALID_ELEMENTS =
      merge3(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
  var URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
  var SRCSET_ATTRS = tagSet('srcset');
  var HTML_ATTRS = tagSet(
      'abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width');
  var ARIA_ATTRS = tagSet(
      'aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext');
  var VALID_ATTRS = merge3(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS, ARIA_ATTRS);
  var SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');
  var SanitizingHtmlSerializer = class {
    constructor() {
      this.sanitizedSomething = false;
      this.buf = [];
    }
    sanitizeChildren(el) {
      let current = el.firstChild;
      let traverseContent = true;
      while (current) {
        if (current.nodeType === Node.ELEMENT_NODE) {
          traverseContent = this.startElement(current);
        } else if (current.nodeType === Node.TEXT_NODE) {
          this.chars(current.nodeValue);
        } else {
          this.sanitizedSomething = true;
        }
        if (traverseContent && current.firstChild) {
          current = current.firstChild;
          continue;
        }
        while (current) {
          if (current.nodeType === Node.ELEMENT_NODE) {
            this.endElement(current);
          }
          let next = this.checkClobberedElement(current, current.nextSibling);
          if (next) {
            current = next;
            break;
          }
          current = this.checkClobberedElement(current, current.parentNode);
        }
      }
      return this.buf.join('');
    }
    startElement(element) {
      const tagName = element.nodeName.toLowerCase();
      if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
        this.sanitizedSomething = true;
        return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
      }
      this.buf.push('<');
      this.buf.push(tagName);
      const elAttrs = element.attributes;
      for (let i = 0; i < elAttrs.length; i++) {
        const elAttr = elAttrs.item(i);
        const attrName = elAttr.name;
        const lower = attrName.toLowerCase();
        if (!VALID_ATTRS.hasOwnProperty(lower)) {
          this.sanitizedSomething = true;
          continue;
        }
        let value = elAttr.value;
        if (URI_ATTRS[lower]) value = _sanitizeUrl(value);
        if (SRCSET_ATTRS[lower]) value = sanitizeSrcset(value);
        this.buf.push(' ', attrName, '="', encodeEntities(value), '"');
      }
      this.buf.push('>');
      return true;
    }
    endElement(current) {
      const tagName = current.nodeName.toLowerCase();
      if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
        this.buf.push('</');
        this.buf.push(tagName);
        this.buf.push('>');
      }
    }
    chars(chars) {
      this.buf.push(encodeEntities(chars));
    }
    checkClobberedElement(node, nextNode) {
      if (nextNode &&
          (node.compareDocumentPosition(nextNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) ===
              Node.DOCUMENT_POSITION_CONTAINED_BY) {
        throw new Error(
            `Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
      }
      return nextNode;
    }
  };
  var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
  function encodeEntities(value) {
    return value.replace(/&/g, '&amp;')
        .replace(
            SURROGATE_PAIR_REGEXP,
            function(match2) {
              const hi = match2.charCodeAt(0);
              const low = match2.charCodeAt(1);
              return '&#' + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ';';
            })
        .replace(
            NON_ALPHANUMERIC_REGEXP,
            function(match2) {
              return '&#' + match2.charCodeAt(0) + ';';
            })
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
  }
  var inertBodyHelper;
  function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
    let inertBodyElement = null;
    try {
      inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
      let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
      let mXSSAttempts = 5;
      let parsedHtml = unsafeHtml;
      do {
        if (mXSSAttempts === 0) {
          throw new Error('Failed to sanitize html because the input is unstable');
        }
        mXSSAttempts--;
        unsafeHtml = parsedHtml;
        parsedHtml = inertBodyElement.innerHTML;
        inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
      } while (unsafeHtml !== parsedHtml);
      const sanitizer = new SanitizingHtmlSerializer();
      const safeHtml =
          sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
      if ((typeof ngDevMode === 'undefined' || ngDevMode) && sanitizer.sanitizedSomething) {
        console.warn(
            'WARNING: sanitizing HTML stripped some content, see https://g.co/ng/security#xss');
      }
      return safeHtml;
    } finally {
      if (inertBodyElement) {
        const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
        while (parent.firstChild) {
          parent.removeChild(parent.firstChild);
        }
      }
    }
  }
  function getTemplateContent(el) {
    return 'content' in el && isTemplateElement(el) ? el.content : null;
  }
  function isTemplateElement(el) {
    return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var SecurityContext;
  (function(SecurityContext2) {
    SecurityContext2[SecurityContext2['NONE'] = 0] = 'NONE';
    SecurityContext2[SecurityContext2['HTML'] = 1] = 'HTML';
    SecurityContext2[SecurityContext2['STYLE'] = 2] = 'STYLE';
    SecurityContext2[SecurityContext2['SCRIPT'] = 3] = 'SCRIPT';
    SecurityContext2[SecurityContext2['URL'] = 4] = 'URL';
    SecurityContext2[SecurityContext2['RESOURCE_URL'] = 5] = 'RESOURCE_URL';
  })(SecurityContext || (SecurityContext = {}));
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275sanitizeHtml(unsafeHtml) {
    const sanitizer = getSanitizer();
    if (sanitizer) {
      return sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || '';
    }
    if (allowSanitizationBypassAndThrow(unsafeHtml, 'HTML')) {
      return unwrapSafeValue(unsafeHtml);
    }
    return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
  }
  function \u0275\u0275sanitizeStyle(unsafeStyle) {
    const sanitizer = getSanitizer();
    if (sanitizer) {
      return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || '';
    }
    if (allowSanitizationBypassAndThrow(unsafeStyle, 'Style')) {
      return unwrapSafeValue(unsafeStyle);
    }
    return renderStringify(unsafeStyle);
  }
  function \u0275\u0275sanitizeUrl(unsafeUrl) {
    const sanitizer = getSanitizer();
    if (sanitizer) {
      return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || '';
    }
    if (allowSanitizationBypassAndThrow(unsafeUrl, 'URL')) {
      return unwrapSafeValue(unsafeUrl);
    }
    return _sanitizeUrl(renderStringify(unsafeUrl));
  }
  function \u0275\u0275sanitizeResourceUrl(unsafeResourceUrl) {
    const sanitizer = getSanitizer();
    if (sanitizer) {
      return sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '';
    }
    if (allowSanitizationBypassAndThrow(unsafeResourceUrl, 'ResourceURL')) {
      return unwrapSafeValue(unsafeResourceUrl);
    }
    throw new Error(
        'unsafe value used in a resource URL context (see https://g.co/ng/security#xss)');
  }
  function \u0275\u0275sanitizeScript(unsafeScript) {
    const sanitizer = getSanitizer();
    if (sanitizer) {
      return sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || '';
    }
    if (allowSanitizationBypassAndThrow(unsafeScript, 'Script')) {
      return unwrapSafeValue(unsafeScript);
    }
    throw new Error('unsafe value used in a script context');
  }
  function \u0275\u0275trustConstantHtml(html) {
    return trustedHTMLFromString(html);
  }
  function \u0275\u0275trustConstantScript(script) {
    return trustedScriptFromString(script);
  }
  function \u0275\u0275trustConstantResourceUrl(url) {
    return trustedScriptURLFromString(url);
  }
  function getUrlSanitizer(tag, prop) {
    if (prop === 'src' &&
            (tag === 'embed' || tag === 'frame' || tag === 'iframe' || tag === 'media' ||
             tag === 'script') ||
        prop === 'href' && (tag === 'base' || tag === 'link')) {
      return \u0275\u0275sanitizeResourceUrl;
    }
    return \u0275\u0275sanitizeUrl;
  }
  function \u0275\u0275sanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
    return getUrlSanitizer(tag, prop)(unsafeUrl);
  }
  function validateAgainstEventProperties(name) {
    if (name.toLowerCase().startsWith('on')) {
      const msg = `Binding to event property '${
          name}' is disallowed for security reasons, please use (${name.slice(2)})=...
If '${name}' is a directive input, make sure the directive is imported by the current module.`;
      throw new Error(msg);
    }
  }
  function validateAgainstEventAttributes(name) {
    if (name.toLowerCase().startsWith('on')) {
      const msg = `Binding to event attribute '${
          name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;
      throw new Error(msg);
    }
  }
  function getSanitizer() {
    const lView = getLView();
    return lView && lView[SANITIZER];
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ERROR_DEBUG_CONTEXT = 'ngDebugContext';
  var ERROR_ORIGINAL_ERROR = 'ngOriginalError';
  var ERROR_LOGGER = 'ngErrorLogger';
  function wrappedError(message, originalError) {
    const msg = `${message} caused by: ${
        originalError instanceof Error ? originalError.message : originalError}`;
    const error = Error(msg);
    error[ERROR_ORIGINAL_ERROR] = originalError;
    return error;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function getDebugContext(error) {
    return error[ERROR_DEBUG_CONTEXT];
  }
  function getOriginalError(error) {
    return error[ERROR_ORIGINAL_ERROR];
  }
  function getErrorLogger(error) {
    return error[ERROR_LOGGER] || defaultErrorLogger;
  }
  function defaultErrorLogger(console2, ...values) {
    console2.error(...values);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ErrorHandler = class {
    constructor() {
      this._console = console;
    }
    handleError(error) {
      const originalError = this._findOriginalError(error);
      const context = this._findContext(error);
      const errorLogger = getErrorLogger(error);
      errorLogger(this._console, `ERROR`, error);
      if (originalError) {
        errorLogger(this._console, `ORIGINAL ERROR`, originalError);
      }
      if (context) {
        errorLogger(this._console, 'ERROR CONTEXT', context);
      }
    }
    _findContext(error) {
      if (error) {
        return getDebugContext(error) ? getDebugContext(error) :
                                        this._findContext(getOriginalError(error));
      }
      return null;
    }
    _findOriginalError(error) {
      let e = getOriginalError(error);
      while (e && getOriginalError(e)) {
        e = getOriginalError(e);
      }
      return e;
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var CUSTOM_ELEMENTS_SCHEMA = {name: 'custom-elements'};
  var NO_ERRORS_SCHEMA = {name: 'no-errors-schema'};
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var END_COMMENT = /-->/g;
  var END_COMMENT_ESCAPED = '-\u200B-\u200B>';
  function escapeCommentText(value) {
    return value.replace(END_COMMENT, END_COMMENT_ESCAPED);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function createNamedArrayType(name) {
    if (ngDevMode) {
      try {
        return newTrustedFunctionForDev('Array', `return class ${name} extends Array{}`)(Array);
      } catch (e) {
        return Array;
      }
    } else {
      throw new Error(
          'Looks like we are in \'prod mode\', but we are creating a named Array type, which is wrong! Check your code');
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function normalizeDebugBindingName(name) {
    name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));
    return `ng-reflect-${name}`;
  }
  var CAMEL_CASE_REGEXP = /([A-Z])/g;
  function camelCaseToDashCase(input) {
    return input.replace(CAMEL_CASE_REGEXP, (...m) => '-' + m[1].toLowerCase());
  }
  function normalizeDebugBindingValue(value) {
    try {
      return value != null ? value.toString().slice(0, 30) : value;
    } catch (e) {
      return '[ERROR] Exception while trying to serialize the value';
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function getLContext(target) {
    let mpValue = readPatchedData(target);
    if (mpValue) {
      if (Array.isArray(mpValue)) {
        const lView = mpValue;
        let nodeIndex;
        let component = void 0;
        let directives = void 0;
        if (isComponentInstance(target)) {
          nodeIndex = findViaComponent(lView, target);
          if (nodeIndex == -1) {
            throw new Error('The provided component was not found in the application');
          }
          component = target;
        } else if (isDirectiveInstance(target)) {
          nodeIndex = findViaDirective(lView, target);
          if (nodeIndex == -1) {
            throw new Error('The provided directive was not found in the application');
          }
          directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);
        } else {
          nodeIndex = findViaNativeElement(lView, target);
          if (nodeIndex == -1) {
            return null;
          }
        }
        const native = unwrapRNode(lView[nodeIndex]);
        const existingCtx = readPatchedData(native);
        const context = existingCtx && !Array.isArray(existingCtx) ?
            existingCtx :
            createLContext(lView, nodeIndex, native);
        if (component && context.component === void 0) {
          context.component = component;
          attachPatchData(context.component, context);
        }
        if (directives && context.directives === void 0) {
          context.directives = directives;
          for (let i = 0; i < directives.length; i++) {
            attachPatchData(directives[i], context);
          }
        }
        attachPatchData(context.native, context);
        mpValue = context;
      }
    } else {
      const rElement = target;
      ngDevMode && assertDomNode(rElement);
      let parent = rElement;
      while (parent = parent.parentNode) {
        const parentContext = readPatchedData(parent);
        if (parentContext) {
          let lView;
          if (Array.isArray(parentContext)) {
            lView = parentContext;
          } else {
            lView = parentContext.lView;
          }
          if (!lView) {
            return null;
          }
          const index = findViaNativeElement(lView, rElement);
          if (index >= 0) {
            const native = unwrapRNode(lView[index]);
            const context = createLContext(lView, index, native);
            attachPatchData(native, context);
            mpValue = context;
            break;
          }
        }
      }
    }
    return mpValue || null;
  }
  function createLContext(lView, nodeIndex, native) {
    return {lView, nodeIndex, native, component: void 0, directives: void 0, localRefs: void 0};
  }
  function getComponentViewByInstance(componentInstance) {
    let lView = readPatchedData(componentInstance);
    let view;
    if (Array.isArray(lView)) {
      const nodeIndex = findViaComponent(lView, componentInstance);
      view = getComponentLViewByIndex(nodeIndex, lView);
      const context = createLContext(lView, nodeIndex, view[HOST]);
      context.component = componentInstance;
      attachPatchData(componentInstance, context);
      attachPatchData(context.native, context);
    } else {
      const context = lView;
      view = getComponentLViewByIndex(context.nodeIndex, context.lView);
    }
    return view;
  }
  function attachPatchData(target, data) {
    target[MONKEY_PATCH_KEY_NAME] = data;
  }
  function isComponentInstance(instance) {
    return instance && instance.constructor && instance.constructor.\u0275cmp;
  }
  function isDirectiveInstance(instance) {
    return instance && instance.constructor && instance.constructor.\u0275dir;
  }
  function findViaNativeElement(lView, target) {
    const tView = lView[TVIEW];
    for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
      if (unwrapRNode(lView[i]) === target) {
        return i;
      }
    }
    return -1;
  }
  function traverseNextElement(tNode) {
    if (tNode.child) {
      return tNode.child;
    } else if (tNode.next) {
      return tNode.next;
    } else {
      while (tNode.parent && !tNode.parent.next) {
        tNode = tNode.parent;
      }
      return tNode.parent && tNode.parent.next;
    }
  }
  function findViaComponent(lView, componentInstance) {
    const componentIndices = lView[TVIEW].components;
    if (componentIndices) {
      for (let i = 0; i < componentIndices.length; i++) {
        const elementComponentIndex = componentIndices[i];
        const componentView = getComponentLViewByIndex(elementComponentIndex, lView);
        if (componentView[CONTEXT] === componentInstance) {
          return elementComponentIndex;
        }
      }
    } else {
      const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);
      const rootComponent = rootComponentView[CONTEXT];
      if (rootComponent === componentInstance) {
        return HEADER_OFFSET;
      }
    }
    return -1;
  }
  function findViaDirective(lView, directiveInstance) {
    let tNode = lView[TVIEW].firstChild;
    while (tNode) {
      const directiveIndexStart = tNode.directiveStart;
      const directiveIndexEnd = tNode.directiveEnd;
      for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {
        if (lView[i] === directiveInstance) {
          return tNode.index;
        }
      }
      tNode = traverseNextElement(tNode);
    }
    return -1;
  }
  function getDirectivesAtNodeIndex(nodeIndex, lView, includeComponents) {
    const tNode = lView[TVIEW].data[nodeIndex];
    let directiveStartIndex = tNode.directiveStart;
    if (directiveStartIndex == 0) return EMPTY_ARRAY;
    const directiveEndIndex = tNode.directiveEnd;
    if (!includeComponents && tNode.flags & 2) directiveStartIndex++;
    return lView.slice(directiveStartIndex, directiveEndIndex);
  }
  function getComponentAtNodeIndex(nodeIndex, lView) {
    const tNode = lView[TVIEW].data[nodeIndex];
    let directiveStartIndex = tNode.directiveStart;
    return tNode.flags & 2 ? lView[directiveStartIndex] : null;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var \u02750$4 = () =>
      (typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame || setTimeout)
          .bind(_global);
  var defaultScheduler = \u02750$4();
  function \u0275\u0275resolveWindow(element) {
    return {name: 'window', target: element.ownerDocument.defaultView};
  }
  function \u0275\u0275resolveDocument(element) {
    return {name: 'document', target: element.ownerDocument};
  }
  function \u0275\u0275resolveBody(element) {
    return {name: 'body', target: element.ownerDocument.body};
  }
  var INTERPOLATION_DELIMITER = `\uFFFD`;
  function maybeUnwrapFn(value) {
    if (value instanceof Function) {
      return value();
    } else {
      return value;
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function throwMultipleComponentError(tNode) {
    throw new RuntimeError('300', `Multiple components match node with tagname ${tNode.value}`);
  }
  function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName) {
    const field = propName ? ` for '${propName}'` : '';
    let msg =
        `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${
            field}: '${oldValue}'. Current value: '${currValue}'.`;
    if (creationMode) {
      msg +=
          ` It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?`;
    }
    throw new RuntimeError('100', msg);
  }
  function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {
    const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);
    let oldValue = prefix, newValue = prefix;
    for (let i = 0; i < chunks.length; i++) {
      const slotIdx = rootIndex + i;
      oldValue += `${lView[slotIdx]}${chunks[i]}`;
      newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;
    }
    return {propName, oldValue, newValue};
  }
  function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
    const tData = lView[TVIEW].data;
    const metadata = tData[bindingIndex];
    if (typeof metadata === 'string') {
      if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {
        return constructDetailsForInterpolation(
            lView, bindingIndex, bindingIndex, metadata, newValue);
      }
      return {propName: metadata, oldValue, newValue};
    }
    if (metadata === null) {
      let idx = bindingIndex - 1;
      while (typeof tData[idx] !== 'string' && tData[idx + 1] === null) {
        idx--;
      }
      const meta = tData[idx];
      if (typeof meta === 'string') {
        const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, 'g'));
        if (matches && matches.length - 1 > bindingIndex - idx) {
          return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);
        }
      }
    }
    return {propName: void 0, oldValue, newValue};
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var RendererStyleFlags2;
  (function(RendererStyleFlags22) {
    RendererStyleFlags22[RendererStyleFlags22['Important'] = 1] = 'Important';
    RendererStyleFlags22[RendererStyleFlags22['DashCase'] = 2] = 'DashCase';
  })(RendererStyleFlags2 || (RendererStyleFlags2 = {}));
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var _icuContainerIterate;
  function icuContainerIterate(tIcuContainerNode, lView) {
    return _icuContainerIterate(tIcuContainerNode, lView);
  }
  function ensureIcuContainerVisitorLoaded(loader) {
    if (_icuContainerIterate === void 0) {
      _icuContainerIterate = loader();
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var unusedValueExportToPlacateAjd$5 = 1;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function getLViewParent(lView) {
    ngDevMode && assertLView(lView);
    const parent = lView[PARENT];
    return isLContainer(parent) ? parent[PARENT] : parent;
  }
  function getRootView(componentOrLView) {
    ngDevMode && assertDefined(componentOrLView, 'component');
    let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
    while (lView && !(lView[FLAGS] & 512)) {
      lView = getLViewParent(lView);
    }
    ngDevMode && assertLView(lView);
    return lView;
  }
  function getRootContext(viewOrComponent) {
    const rootView = getRootView(viewOrComponent);
    ngDevMode &&
        assertDefined(rootView[CONTEXT], 'RootView has no context. Perhaps it is disconnected?');
    return rootView[CONTEXT];
  }
  function getFirstLContainer(lView) {
    return getNearestLContainer(lView[CHILD_HEAD]);
  }
  function getNextLContainer(container) {
    return getNearestLContainer(container[NEXT]);
  }
  function getNearestLContainer(viewOrContainer) {
    while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {
      viewOrContainer = viewOrContainer[NEXT];
    }
    return viewOrContainer;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var unusedValueToPlacateAjd = unusedValueExportToPlacateAjd$1 + unusedValueExportToPlacateAjd$4 +
      unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd$2 +
      unusedValueExportToPlacateAjd;
  function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
    if (lNodeToHandle != null) {
      let lContainer;
      let isComponent = false;
      if (isLContainer(lNodeToHandle)) {
        lContainer = lNodeToHandle;
      } else if (isLView(lNodeToHandle)) {
        isComponent = true;
        ngDevMode &&
            assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');
        lNodeToHandle = lNodeToHandle[HOST];
      }
      const rNode = unwrapRNode(lNodeToHandle);
      ngDevMode && !isProceduralRenderer(renderer) && assertDomNode(rNode);
      if (action === 0 && parent !== null) {
        if (beforeNode == null) {
          nativeAppendChild(renderer, parent, rNode);
        } else {
          nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
        }
      } else if (action === 1 && parent !== null) {
        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
      } else if (action === 2) {
        nativeRemoveNode(renderer, rNode, isComponent);
      } else if (action === 3) {
        ngDevMode && ngDevMode.rendererDestroyNode++;
        renderer.destroyNode(rNode);
      }
      if (lContainer != null) {
        applyContainer(renderer, action, lContainer, parent, beforeNode);
      }
    }
  }
  function createTextNode(renderer, value) {
    ngDevMode && ngDevMode.rendererCreateTextNode++;
    ngDevMode && ngDevMode.rendererSetText++;
    return isProceduralRenderer(renderer) ? renderer.createText(value) :
                                            renderer.createTextNode(value);
  }
  function updateTextNode(renderer, rNode, value) {
    ngDevMode && ngDevMode.rendererSetText++;
    isProceduralRenderer(renderer) ? renderer.setValue(rNode, value) : rNode.textContent = value;
  }
  function createCommentNode(renderer, value) {
    ngDevMode && ngDevMode.rendererCreateComment++;
    return renderer.createComment(escapeCommentText(value));
  }
  function createElementNode(renderer, name, namespace) {
    ngDevMode && ngDevMode.rendererCreateElement++;
    if (isProceduralRenderer(renderer)) {
      return renderer.createElement(name, namespace);
    } else {
      return namespace === null ? renderer.createElement(name) :
                                  renderer.createElementNS(namespace, name);
    }
  }
  function removeViewFromContainer(tView, lView) {
    const renderer = lView[RENDERER];
    applyView(tView, lView, renderer, 2, null, null);
    lView[HOST] = null;
    lView[T_HOST] = null;
  }
  function addViewToContainer(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
    lView[HOST] = parentNativeNode;
    lView[T_HOST] = parentTNode;
    applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);
  }
  function renderDetachView(tView, lView) {
    applyView(tView, lView, lView[RENDERER], 2, null, null);
  }
  function destroyViewTree(rootView) {
    let lViewOrLContainer = rootView[CHILD_HEAD];
    if (!lViewOrLContainer) {
      return cleanUpView(rootView[TVIEW], rootView);
    }
    while (lViewOrLContainer) {
      let next = null;
      if (isLView(lViewOrLContainer)) {
        next = lViewOrLContainer[CHILD_HEAD];
      } else {
        ngDevMode && assertLContainer(lViewOrLContainer);
        const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
        if (firstView) next = firstView;
      }
      if (!next) {
        while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {
          if (isLView(lViewOrLContainer)) {
            cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
          }
          lViewOrLContainer = lViewOrLContainer[PARENT];
        }
        if (lViewOrLContainer === null) lViewOrLContainer = rootView;
        if (isLView(lViewOrLContainer)) {
          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
        }
        next = lViewOrLContainer && lViewOrLContainer[NEXT];
      }
      lViewOrLContainer = next;
    }
  }
  function insertView(tView, lView, lContainer, index) {
    ngDevMode && assertLView(lView);
    ngDevMode && assertLContainer(lContainer);
    const indexInContainer = CONTAINER_HEADER_OFFSET + index;
    const containerLength = lContainer.length;
    if (index > 0) {
      lContainer[indexInContainer - 1][NEXT] = lView;
    }
    if (index < containerLength - CONTAINER_HEADER_OFFSET) {
      lView[NEXT] = lContainer[indexInContainer];
      addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);
    } else {
      lContainer.push(lView);
      lView[NEXT] = null;
    }
    lView[PARENT] = lContainer;
    const declarationLContainer = lView[DECLARATION_LCONTAINER];
    if (declarationLContainer !== null && lContainer !== declarationLContainer) {
      trackMovedView(declarationLContainer, lView);
    }
    const lQueries = lView[QUERIES];
    if (lQueries !== null) {
      lQueries.insertView(tView);
    }
    lView[FLAGS] |= 128;
  }
  function trackMovedView(declarationContainer, lView) {
    ngDevMode && assertDefined(lView, 'LView required');
    ngDevMode && assertLContainer(declarationContainer);
    const movedViews = declarationContainer[MOVED_VIEWS];
    const insertedLContainer = lView[PARENT];
    ngDevMode && assertLContainer(insertedLContainer);
    const insertedComponentLView = insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(insertedComponentLView, 'Missing insertedComponentLView');
    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(declaredComponentLView, 'Missing declaredComponentLView');
    if (declaredComponentLView !== insertedComponentLView) {
      declarationContainer[HAS_TRANSPLANTED_VIEWS] = true;
    }
    if (movedViews === null) {
      declarationContainer[MOVED_VIEWS] = [lView];
    } else {
      movedViews.push(lView);
    }
  }
  function detachMovedView(declarationContainer, lView) {
    ngDevMode && assertLContainer(declarationContainer);
    ngDevMode &&
        assertDefined(
            declarationContainer[MOVED_VIEWS],
            'A projected view should belong to a non-empty projected views collection');
    const movedViews = declarationContainer[MOVED_VIEWS];
    const declarationViewIndex = movedViews.indexOf(lView);
    const insertionLContainer = lView[PARENT];
    ngDevMode && assertLContainer(insertionLContainer);
    if (lView[FLAGS] & 1024) {
      lView[FLAGS] &= ~1024;
      updateTransplantedViewCount(insertionLContainer, -1);
    }
    movedViews.splice(declarationViewIndex, 1);
  }
  function detachView(lContainer, removeIndex) {
    if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;
    const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;
    const viewToDetach = lContainer[indexInContainer];
    if (viewToDetach) {
      const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
      if (declarationLContainer !== null && declarationLContainer !== lContainer) {
        detachMovedView(declarationLContainer, viewToDetach);
      }
      if (removeIndex > 0) {
        lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];
      }
      const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
      removeViewFromContainer(viewToDetach[TVIEW], viewToDetach);
      const lQueries = removedLView[QUERIES];
      if (lQueries !== null) {
        lQueries.detachView(removedLView[TVIEW]);
      }
      viewToDetach[PARENT] = null;
      viewToDetach[NEXT] = null;
      viewToDetach[FLAGS] &= ~128;
    }
    return viewToDetach;
  }
  function destroyLView(tView, lView) {
    if (!(lView[FLAGS] & 256)) {
      const renderer = lView[RENDERER];
      if (isProceduralRenderer(renderer) && renderer.destroyNode) {
        applyView(tView, lView, renderer, 3, null, null);
      }
      destroyViewTree(lView);
    }
  }
  function cleanUpView(tView, lView) {
    if (!(lView[FLAGS] & 256)) {
      lView[FLAGS] &= ~128;
      lView[FLAGS] |= 256;
      executeOnDestroys(tView, lView);
      processCleanups(tView, lView);
      if (lView[TVIEW].type === 1 && isProceduralRenderer(lView[RENDERER])) {
        ngDevMode && ngDevMode.rendererDestroy++;
        lView[RENDERER].destroy();
      }
      const declarationContainer = lView[DECLARATION_LCONTAINER];
      if (declarationContainer !== null && isLContainer(lView[PARENT])) {
        if (declarationContainer !== lView[PARENT]) {
          detachMovedView(declarationContainer, lView);
        }
        const lQueries = lView[QUERIES];
        if (lQueries !== null) {
          lQueries.detachView(tView);
        }
      }
    }
  }
  function processCleanups(tView, lView) {
    const tCleanup = tView.cleanup;
    const lCleanup = lView[CLEANUP];
    let lastLCleanupIndex = -1;
    if (tCleanup !== null) {
      for (let i = 0; i < tCleanup.length - 1; i += 2) {
        if (typeof tCleanup[i] === 'string') {
          const idxOrTargetGetter = tCleanup[i + 1];
          const target = typeof idxOrTargetGetter === 'function' ?
              idxOrTargetGetter(lView) :
              unwrapRNode(lView[idxOrTargetGetter]);
          const listener = lCleanup[lastLCleanupIndex = tCleanup[i + 2]];
          const useCaptureOrSubIdx = tCleanup[i + 3];
          if (typeof useCaptureOrSubIdx === 'boolean') {
            target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);
          } else {
            if (useCaptureOrSubIdx >= 0) {
              lCleanup[lastLCleanupIndex = useCaptureOrSubIdx]();
            } else {
              lCleanup[lastLCleanupIndex = -useCaptureOrSubIdx].unsubscribe();
            }
          }
          i += 2;
        } else {
          const context = lCleanup[lastLCleanupIndex = tCleanup[i + 1]];
          tCleanup[i].call(context);
        }
      }
    }
    if (lCleanup !== null) {
      for (let i = lastLCleanupIndex + 1; i < lCleanup.length; i++) {
        const instanceCleanupFn = lCleanup[i];
        ngDevMode && assertFunction(instanceCleanupFn, 'Expecting instance cleanup function.');
        instanceCleanupFn();
      }
      lView[CLEANUP] = null;
    }
  }
  function executeOnDestroys(tView, lView) {
    let destroyHooks;
    if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
      for (let i = 0; i < destroyHooks.length; i += 2) {
        const context = lView[destroyHooks[i]];
        if (!(context instanceof NodeInjectorFactory)) {
          const toCall = destroyHooks[i + 1];
          if (Array.isArray(toCall)) {
            for (let j = 0; j < toCall.length; j += 2) {
              toCall[j + 1].call(context[toCall[j]]);
            }
          } else {
            toCall.call(context);
          }
        }
      }
    }
  }
  function getParentRElement(tView, tNode, lView) {
    return getClosestRElement(tView, tNode.parent, lView);
  }
  function getClosestRElement(tView, tNode, lView) {
    let parentTNode = tNode;
    while (parentTNode !== null && parentTNode.type & (8 | 32)) {
      tNode = parentTNode;
      parentTNode = tNode.parent;
    }
    if (parentTNode === null) {
      return lView[HOST];
    } else {
      ngDevMode && assertTNodeType(parentTNode, 3 | 4);
      if (parentTNode.flags & 2) {
        ngDevMode && assertTNodeForLView(parentTNode, lView);
        const encapsulation = tView.data[parentTNode.directiveStart].encapsulation;
        if (encapsulation === ViewEncapsulation.None ||
            encapsulation === ViewEncapsulation.Emulated) {
          return null;
        }
      }
      return getNativeByTNode(parentTNode, lView);
    }
  }
  function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
    ngDevMode && ngDevMode.rendererInsertBefore++;
    if (isProceduralRenderer(renderer)) {
      renderer.insertBefore(parent, child, beforeNode, isMove);
    } else {
      parent.insertBefore(child, beforeNode, isMove);
    }
  }
  function nativeAppendChild(renderer, parent, child) {
    ngDevMode && ngDevMode.rendererAppendChild++;
    ngDevMode && assertDefined(parent, 'parent node must be defined');
    if (isProceduralRenderer(renderer)) {
      renderer.appendChild(parent, child);
    } else {
      parent.appendChild(child);
    }
  }
  function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {
    if (beforeNode !== null) {
      nativeInsertBefore(renderer, parent, child, beforeNode, isMove);
    } else {
      nativeAppendChild(renderer, parent, child);
    }
  }
  function nativeRemoveChild(renderer, parent, child, isHostElement) {
    if (isProceduralRenderer(renderer)) {
      renderer.removeChild(parent, child, isHostElement);
    } else {
      parent.removeChild(child);
    }
  }
  function nativeParentNode(renderer, node) {
    return isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode;
  }
  function nativeNextSibling(renderer, node) {
    return isProceduralRenderer(renderer) ? renderer.nextSibling(node) : node.nextSibling;
  }
  function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
    return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
  }
  function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
    if (parentTNode.type & (8 | 32)) {
      return getNativeByTNode(parentTNode, lView);
    }
    return null;
  }
  var _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
  var _processI18nInsertBefore;
  function setI18nHandling(getInsertInFrontOfRNodeWithI18n2, processI18nInsertBefore2) {
    _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n2;
    _processI18nInsertBefore = processI18nInsertBefore2;
  }
  function appendChild(tView, lView, childRNode, childTNode) {
    const parentRNode = getParentRElement(tView, childTNode, lView);
    const renderer = lView[RENDERER];
    const parentTNode = childTNode.parent || lView[T_HOST];
    const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
    if (parentRNode != null) {
      if (Array.isArray(childRNode)) {
        for (let i = 0; i < childRNode.length; i++) {
          nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);
        }
      } else {
        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
      }
    }
    _processI18nInsertBefore !== void 0 &&
        _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
  }
  function getFirstNativeNode(lView, tNode) {
    if (tNode !== null) {
      ngDevMode && assertTNodeType(tNode, 3 | 12 | 32 | 16);
      const tNodeType = tNode.type;
      if (tNodeType & 3) {
        return getNativeByTNode(tNode, lView);
      } else if (tNodeType & 4) {
        return getBeforeNodeForView(-1, lView[tNode.index]);
      } else if (tNodeType & 8) {
        const elIcuContainerChild = tNode.child;
        if (elIcuContainerChild !== null) {
          return getFirstNativeNode(lView, elIcuContainerChild);
        } else {
          const rNodeOrLContainer = lView[tNode.index];
          if (isLContainer(rNodeOrLContainer)) {
            return getBeforeNodeForView(-1, rNodeOrLContainer);
          } else {
            return unwrapRNode(rNodeOrLContainer);
          }
        }
      } else if (tNodeType & 32) {
        let nextRNode = icuContainerIterate(tNode, lView);
        let rNode = nextRNode();
        return rNode || unwrapRNode(lView[tNode.index]);
      } else {
        const componentView = lView[DECLARATION_COMPONENT_VIEW];
        const componentHost = componentView[T_HOST];
        const parentView = getLViewParent(componentView);
        const firstProjectedTNode = componentHost.projection[tNode.projection];
        if (firstProjectedTNode != null) {
          return getFirstNativeNode(parentView, firstProjectedTNode);
        } else {
          return getFirstNativeNode(lView, tNode.next);
        }
      }
    }
    return null;
  }
  function getBeforeNodeForView(viewIndexInContainer, lContainer) {
    const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
    if (nextViewIndex < lContainer.length) {
      const lView = lContainer[nextViewIndex];
      const firstTNodeOfView = lView[TVIEW].firstChild;
      if (firstTNodeOfView !== null) {
        return getFirstNativeNode(lView, firstTNodeOfView);
      }
    }
    return lContainer[NATIVE];
  }
  function nativeRemoveNode(renderer, rNode, isHostElement) {
    ngDevMode && ngDevMode.rendererRemoveNode++;
    const nativeParent = nativeParentNode(renderer, rNode);
    if (nativeParent) {
      nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);
    }
  }
  function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
    while (tNode != null) {
      ngDevMode && assertTNodeForLView(tNode, lView);
      ngDevMode && assertTNodeType(tNode, 3 | 12 | 16 | 32);
      const rawSlotValue = lView[tNode.index];
      const tNodeType = tNode.type;
      if (isProjection) {
        if (action === 0) {
          rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);
          tNode.flags |= 4;
        }
      }
      if ((tNode.flags & 64) !== 64) {
        if (tNodeType & 8) {
          applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
          applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
        } else if (tNodeType & 32) {
          const nextRNode = icuContainerIterate(tNode, lView);
          let rNode;
          while (rNode = nextRNode()) {
            applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
          }
          applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
        } else if (tNodeType & 16) {
          applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
        } else {
          ngDevMode && assertTNodeType(tNode, 3 | 4);
          applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
        }
      }
      tNode = isProjection ? tNode.projectionNext : tNode.next;
    }
  }
  function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
    applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
  }
  function applyProjection(tView, lView, tProjectionNode) {
    const renderer = lView[RENDERER];
    const parentRNode = getParentRElement(tView, tProjectionNode, lView);
    const parentTNode = tProjectionNode.parent || lView[T_HOST];
    let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
    applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);
  }
  function applyProjectionRecursive(
      renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
    const componentLView = lView[DECLARATION_COMPONENT_VIEW];
    const componentNode = componentLView[T_HOST];
    ngDevMode &&
        assertEqual(typeof tProjectionNode.projection, 'number', 'expecting projection index');
    const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
    if (Array.isArray(nodeToProjectOrRNodes)) {
      for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {
        const rNode = nodeToProjectOrRNodes[i];
        applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
      }
    } else {
      let nodeToProject = nodeToProjectOrRNodes;
      const projectedComponentLView = componentLView[PARENT];
      applyNodes(
          renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode,
          true);
    }
  }
  function applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {
    ngDevMode && assertLContainer(lContainer);
    const anchor = lContainer[NATIVE];
    const native = unwrapRNode(lContainer);
    if (anchor !== native) {
      applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);
    }
    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
      const lView = lContainer[i];
      applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);
    }
  }
  function applyStyling(renderer, isClassBased, rNode, prop, value) {
    const isProcedural = isProceduralRenderer(renderer);
    if (isClassBased) {
      if (!value) {
        ngDevMode && ngDevMode.rendererRemoveClass++;
        if (isProcedural) {
          renderer.removeClass(rNode, prop);
        } else {
          rNode.classList.remove(prop);
        }
      } else {
        ngDevMode && ngDevMode.rendererAddClass++;
        if (isProcedural) {
          renderer.addClass(rNode, prop);
        } else {
          ngDevMode && assertDefined(rNode.classList, 'HTMLElement expected');
          rNode.classList.add(prop);
        }
      }
    } else {
      let flags = prop.indexOf('-') === -1 ? void 0 : RendererStyleFlags2.DashCase;
      if (value == null) {
        ngDevMode && ngDevMode.rendererRemoveStyle++;
        if (isProcedural) {
          renderer.removeStyle(rNode, prop, flags);
        } else {
          rNode.style.removeProperty(prop);
        }
      } else {
        const isImportant = typeof value === 'string' ? value.endsWith('!important') : false;
        if (isImportant) {
          value = value.slice(0, -10);
          flags |= RendererStyleFlags2.Important;
        }
        ngDevMode && ngDevMode.rendererSetStyle++;
        if (isProcedural) {
          renderer.setStyle(rNode, prop, value, flags);
        } else {
          ngDevMode && assertDefined(rNode.style, 'HTMLElement expected');
          rNode.style.setProperty(prop, value, isImportant ? 'important' : '');
        }
      }
    }
  }
  function writeDirectStyle(renderer, element, newValue) {
    ngDevMode && assertString(newValue, '\'newValue\' should be a string');
    if (isProceduralRenderer(renderer)) {
      renderer.setAttribute(element, 'style', newValue);
    } else {
      element.style.cssText = newValue;
    }
    ngDevMode && ngDevMode.rendererSetStyle++;
  }
  function writeDirectClass(renderer, element, newValue) {
    ngDevMode && assertString(newValue, '\'newValue\' should be a string');
    if (isProceduralRenderer(renderer)) {
      if (newValue === '') {
        renderer.removeAttribute(element, 'class');
      } else {
        renderer.setAttribute(element, 'class', newValue);
      }
    } else {
      element.className = newValue;
    }
    ngDevMode && ngDevMode.rendererSetClassName++;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function classIndexOf(className, classToSearch, startingIndex) {
    ngDevMode && assertNotEqual(classToSearch, '', 'can not look for "" string.');
    let end = className.length;
    while (true) {
      const foundIndex = className.indexOf(classToSearch, startingIndex);
      if (foundIndex === -1) return foundIndex;
      if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
        const length = classToSearch.length;
        if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) {
          return foundIndex;
        }
      }
      startingIndex = foundIndex + 1;
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var unusedValueToPlacateAjd$1 = unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$5;
  var NG_TEMPLATE_SELECTOR = 'ng-template';
  function isCssClassMatching(attrs, cssClassToMatch, isProjectionMode) {
    ngDevMode &&
        assertEqual(
            cssClassToMatch, cssClassToMatch.toLowerCase(), 'Class name expected to be lowercase.');
    let i = 0;
    while (i < attrs.length) {
      let item = attrs[i++];
      if (isProjectionMode && item === 'class') {
        item = attrs[i];
        if (classIndexOf(item.toLowerCase(), cssClassToMatch, 0) !== -1) {
          return true;
        }
      } else if (item === 1) {
        while (i < attrs.length && typeof (item = attrs[i++]) == 'string') {
          if (item.toLowerCase() === cssClassToMatch) return true;
        }
        return false;
      }
    }
    return false;
  }
  function isInlineTemplate(tNode) {
    return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
  }
  function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
    const tagNameToCompare =
        tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
    return currentSelector === tagNameToCompare;
  }
  function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
    ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');
    let mode = 4;
    const nodeAttrs = tNode.attrs || [];
    const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);
    let skipToNextSelector = false;
    for (let i = 0; i < selector.length; i++) {
      const current = selector[i];
      if (typeof current === 'number') {
        if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
          return false;
        }
        if (skipToNextSelector && isPositive(current)) continue;
        skipToNextSelector = false;
        mode = current | mode & 1;
        continue;
      }
      if (skipToNextSelector) continue;
      if (mode & 4) {
        mode = 2 | mode & 1;
        if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) ||
            current === '' && selector.length === 1) {
          if (isPositive(mode)) return false;
          skipToNextSelector = true;
        }
      } else {
        const selectorAttrValue = mode & 8 ? current : selector[++i];
        if (mode & 8 && tNode.attrs !== null) {
          if (!isCssClassMatching(tNode.attrs, selectorAttrValue, isProjectionMode)) {
            if (isPositive(mode)) return false;
            skipToNextSelector = true;
          }
          continue;
        }
        const attrName = mode & 8 ? 'class' : current;
        const attrIndexInNode =
            findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
        if (attrIndexInNode === -1) {
          if (isPositive(mode)) return false;
          skipToNextSelector = true;
          continue;
        }
        if (selectorAttrValue !== '') {
          let nodeAttrValue;
          if (attrIndexInNode > nameOnlyMarkerIdx) {
            nodeAttrValue = '';
          } else {
            ngDevMode &&
                assertNotEqual(
                    nodeAttrs[attrIndexInNode], 0,
                    'We do not match directives on namespaced attributes');
            nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
          }
          const compareAgainstClassName = mode & 8 ? nodeAttrValue : null;
          if (compareAgainstClassName &&
                  classIndexOf(compareAgainstClassName, selectorAttrValue, 0) !== -1 ||
              mode & 2 && selectorAttrValue !== nodeAttrValue) {
            if (isPositive(mode)) return false;
            skipToNextSelector = true;
          }
        }
      }
    }
    return isPositive(mode) || skipToNextSelector;
  }
  function isPositive(mode) {
    return (mode & 1) === 0;
  }
  function findAttrIndexInNode(name, attrs, isInlineTemplate2, isProjectionMode) {
    if (attrs === null) return -1;
    let i = 0;
    if (isProjectionMode || !isInlineTemplate2) {
      let bindingsMode = false;
      while (i < attrs.length) {
        const maybeAttrName = attrs[i];
        if (maybeAttrName === name) {
          return i;
        } else if (maybeAttrName === 3 || maybeAttrName === 6) {
          bindingsMode = true;
        } else if (maybeAttrName === 1 || maybeAttrName === 2) {
          let value = attrs[++i];
          while (typeof value === 'string') {
            value = attrs[++i];
          }
          continue;
        } else if (maybeAttrName === 4) {
          break;
        } else if (maybeAttrName === 0) {
          i += 4;
          continue;
        }
        i += bindingsMode ? 1 : 2;
      }
      return -1;
    } else {
      return matchTemplateAttribute(attrs, name);
    }
  }
  function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
    for (let i = 0; i < selector.length; i++) {
      if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {
        return true;
      }
    }
    return false;
  }
  function getProjectAsAttrValue(tNode) {
    const nodeAttrs = tNode.attrs;
    if (nodeAttrs != null) {
      const ngProjectAsAttrIdx = nodeAttrs.indexOf(5);
      if ((ngProjectAsAttrIdx & 1) === 0) {
        return nodeAttrs[ngProjectAsAttrIdx + 1];
      }
    }
    return null;
  }
  function getNameOnlyMarkerIndex(nodeAttrs) {
    for (let i = 0; i < nodeAttrs.length; i++) {
      const nodeAttr = nodeAttrs[i];
      if (isNameOnlyAttributeMarker(nodeAttr)) {
        return i;
      }
    }
    return nodeAttrs.length;
  }
  function matchTemplateAttribute(attrs, name) {
    let i = attrs.indexOf(4);
    if (i > -1) {
      i++;
      while (i < attrs.length) {
        const attr = attrs[i];
        if (typeof attr === 'number') return -1;
        if (attr === name) return i;
        i++;
      }
    }
    return -1;
  }
  function isSelectorInSelectorList(selector, list) {
    selectorListLoop: for (let i = 0; i < list.length; i++) {
      const currentSelectorInList = list[i];
      if (selector.length !== currentSelectorInList.length) {
        continue;
      }
      for (let j = 0; j < selector.length; j++) {
        if (selector[j] !== currentSelectorInList[j]) {
          continue selectorListLoop;
        }
      }
      return true;
    }
    return false;
  }
  function maybeWrapInNotSelector(isNegativeMode, chunk) {
    return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;
  }
  function stringifyCSSSelector(selector) {
    let result = selector[0];
    let i = 1;
    let mode = 2;
    let currentChunk = '';
    let isNegativeMode = false;
    while (i < selector.length) {
      let valueOrMarker = selector[i];
      if (typeof valueOrMarker === 'string') {
        if (mode & 2) {
          const attrValue = selector[++i];
          currentChunk +=
              '[' + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : '') + ']';
        } else if (mode & 8) {
          currentChunk += '.' + valueOrMarker;
        } else if (mode & 4) {
          currentChunk += ' ' + valueOrMarker;
        }
      } else {
        if (currentChunk !== '' && !isPositive(valueOrMarker)) {
          result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
          currentChunk = '';
        }
        mode = valueOrMarker;
        isNegativeMode = isNegativeMode || !isPositive(mode);
      }
      i++;
    }
    if (currentChunk !== '') {
      result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
    }
    return result;
  }
  function stringifyCSSSelectorList(selectorList) {
    return selectorList.map(stringifyCSSSelector).join(',');
  }
  function extractAttrsAndClassesFromSelector(selector) {
    const attrs = [];
    const classes = [];
    let i = 1;
    let mode = 2;
    while (i < selector.length) {
      let valueOrMarker = selector[i];
      if (typeof valueOrMarker === 'string') {
        if (mode === 2) {
          if (valueOrMarker !== '') {
            attrs.push(valueOrMarker, selector[++i]);
          }
        } else if (mode === 8) {
          classes.push(valueOrMarker);
        }
      } else {
        if (!isPositive(mode)) break;
        mode = valueOrMarker;
      }
      i++;
    }
    return {attrs, classes};
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NO_CHANGE = typeof ngDevMode === 'undefined' || ngDevMode ? {__brand__: 'NO_CHANGE'} : {};
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275advance(delta) {
    ngDevMode && assertGreaterThan(delta, 0, 'Can only advance forward');
    selectIndexInternal(
        getTView(), getLView(), getSelectedIndex() + delta, isInCheckNoChangesMode());
  }
  function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
    ngDevMode && assertIndexInDeclRange(lView, index);
    if (!checkNoChangesMode) {
      const hooksInitPhaseCompleted = (lView[FLAGS] & 3) === 3;
      if (hooksInitPhaseCompleted) {
        const preOrderCheckHooks = tView.preOrderCheckHooks;
        if (preOrderCheckHooks !== null) {
          executeCheckHooks(lView, preOrderCheckHooks, index);
        }
      } else {
        const preOrderHooks = tView.preOrderHooks;
        if (preOrderHooks !== null) {
          executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
        }
      }
    }
    setSelectedIndex(index);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function toTStylingRange(prev, next) {
    ngDevMode && assertNumberInRange(prev, 0, 32767);
    ngDevMode && assertNumberInRange(next, 0, 32767);
    return prev << 17 | next << 2;
  }
  function getTStylingRangePrev(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    return tStylingRange >> 17 & 32767;
  }
  function getTStylingRangePrevDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    return (tStylingRange & 2) == 2;
  }
  function setTStylingRangePrev(tStylingRange, previous) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    ngDevMode && assertNumberInRange(previous, 0, 32767);
    return tStylingRange & ~4294836224 | previous << 17;
  }
  function setTStylingRangePrevDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    return tStylingRange | 2;
  }
  function getTStylingRangeNext(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    return (tStylingRange & 131068) >> 2;
  }
  function setTStylingRangeNext(tStylingRange, next) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    ngDevMode && assertNumberInRange(next, 0, 32767);
    return tStylingRange & ~131068 | next << 2;
  }
  function getTStylingRangeNextDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    return (tStylingRange & 1) === 1;
  }
  function setTStylingRangeNextDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    return tStylingRange | 1;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function attachDebugObject(obj, debug) {
    if (ngDevMode) {
      Object.defineProperty(obj, 'debug', {value: debug, enumerable: false});
    } else {
      throw new Error(
          'This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');
    }
  }
  function attachDebugGetter(obj, debugGetter) {
    if (ngDevMode) {
      Object.defineProperty(obj, 'debug', {get: debugGetter, enumerable: false});
    } else {
      throw new Error(
          'This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NG_DEV_MODE = (typeof ngDevMode === 'undefined' || !!ngDevMode) && initNgDevMode();
  var LVIEW_COMPONENT_CACHE;
  var LVIEW_EMBEDDED_CACHE;
  var LVIEW_ROOT;
  function cloneToLViewFromTViewBlueprint(tView) {
    const debugTView = tView;
    const lView = getLViewToClone(debugTView.type, tView.template && tView.template.name);
    return lView.concat(tView.blueprint);
  }
  function getLViewToClone(type, name) {
    switch (type) {
      case 0:
        if (LVIEW_ROOT === void 0) LVIEW_ROOT = new (createNamedArrayType('LRootView'))();
        return LVIEW_ROOT;
      case 1:
        if (LVIEW_COMPONENT_CACHE === void 0) LVIEW_COMPONENT_CACHE = new Map();
        let componentArray = LVIEW_COMPONENT_CACHE.get(name);
        if (componentArray === void 0) {
          componentArray = new (createNamedArrayType('LComponentView' + nameSuffix(name)))();
          LVIEW_COMPONENT_CACHE.set(name, componentArray);
        }
        return componentArray;
      case 2:
        if (LVIEW_EMBEDDED_CACHE === void 0) LVIEW_EMBEDDED_CACHE = new Map();
        let embeddedArray = LVIEW_EMBEDDED_CACHE.get(name);
        if (embeddedArray === void 0) {
          embeddedArray = new (createNamedArrayType('LEmbeddedView' + nameSuffix(name)))();
          LVIEW_EMBEDDED_CACHE.set(name, embeddedArray);
        }
        return embeddedArray;
    }
    throw new Error('unreachable code');
  }
  function nameSuffix(text) {
    if (text == null) return '';
    const index = text.lastIndexOf('_Template');
    return '_' + (index === -1 ? text : text.substr(0, index));
  }
  var TViewConstructor = class TView {
    constructor(
        type, blueprint, template, queries, viewQuery, declTNode, data, bindingStartIndex,
        expandoStartIndex, hostBindingOpCodes, firstCreatePass, firstUpdatePass, staticViewQueries,
        staticContentQueries, preOrderHooks, preOrderCheckHooks, contentHooks, contentCheckHooks,
        viewHooks, viewCheckHooks, destroyHooks, cleanup, contentQueries, components,
        directiveRegistry, pipeRegistry, firstChild, schemas, consts, incompleteFirstPass, _decls,
        _vars) {
      this.type = type;
      this.blueprint = blueprint;
      this.template = template;
      this.queries = queries;
      this.viewQuery = viewQuery;
      this.declTNode = declTNode;
      this.data = data;
      this.bindingStartIndex = bindingStartIndex;
      this.expandoStartIndex = expandoStartIndex;
      this.hostBindingOpCodes = hostBindingOpCodes;
      this.firstCreatePass = firstCreatePass;
      this.firstUpdatePass = firstUpdatePass;
      this.staticViewQueries = staticViewQueries;
      this.staticContentQueries = staticContentQueries;
      this.preOrderHooks = preOrderHooks;
      this.preOrderCheckHooks = preOrderCheckHooks;
      this.contentHooks = contentHooks;
      this.contentCheckHooks = contentCheckHooks;
      this.viewHooks = viewHooks;
      this.viewCheckHooks = viewCheckHooks;
      this.destroyHooks = destroyHooks;
      this.cleanup = cleanup;
      this.contentQueries = contentQueries;
      this.components = components;
      this.directiveRegistry = directiveRegistry;
      this.pipeRegistry = pipeRegistry;
      this.firstChild = firstChild;
      this.schemas = schemas;
      this.consts = consts;
      this.incompleteFirstPass = incompleteFirstPass;
      this._decls = _decls;
      this._vars = _vars;
    }
    get template_() {
      const buf = [];
      processTNodeChildren(this.firstChild, buf);
      return buf.join('');
    }
    get type_() {
      return TViewTypeAsString[this.type] || `TViewType.?${this.type}?`;
    }
  };
  var TNode = class {
    constructor(
        tView_, type, index, insertBeforeIndex, injectorIndex, directiveStart, directiveEnd,
        directiveStylingLast, propertyBindings, flags, providerIndexes, value, attrs, mergedAttrs,
        localNames, initialInputs, inputs, outputs, tViews, next, projectionNext, child, parent,
        projection, styles, stylesWithoutHost, residualStyles, classes, classesWithoutHost,
        residualClasses, classBindings, styleBindings) {
      this.tView_ = tView_;
      this.type = type;
      this.index = index;
      this.insertBeforeIndex = insertBeforeIndex;
      this.injectorIndex = injectorIndex;
      this.directiveStart = directiveStart;
      this.directiveEnd = directiveEnd;
      this.directiveStylingLast = directiveStylingLast;
      this.propertyBindings = propertyBindings;
      this.flags = flags;
      this.providerIndexes = providerIndexes;
      this.value = value;
      this.attrs = attrs;
      this.mergedAttrs = mergedAttrs;
      this.localNames = localNames;
      this.initialInputs = initialInputs;
      this.inputs = inputs;
      this.outputs = outputs;
      this.tViews = tViews;
      this.next = next;
      this.projectionNext = projectionNext;
      this.child = child;
      this.parent = parent;
      this.projection = projection;
      this.styles = styles;
      this.stylesWithoutHost = stylesWithoutHost;
      this.residualStyles = residualStyles;
      this.classes = classes;
      this.classesWithoutHost = classesWithoutHost;
      this.residualClasses = residualClasses;
      this.classBindings = classBindings;
      this.styleBindings = styleBindings;
    }
    debugNodeInjectorPath(lView) {
      const path = [];
      let injectorIndex = getInjectorIndex(this, lView);
      ngDevMode && assertNodeInjector(lView, injectorIndex);
      while (injectorIndex !== -1) {
        const tNode = lView[TVIEW].data[injectorIndex + 8];
        path.push(buildDebugNode(tNode, lView));
        const parentLocation = lView[injectorIndex + 8];
        if (parentLocation === NO_PARENT_INJECTOR) {
          injectorIndex = -1;
        } else {
          injectorIndex = getParentInjectorIndex(parentLocation);
          lView = getParentInjectorView(parentLocation, lView);
        }
      }
      return path;
    }
    get type_() {
      return toTNodeTypeAsString(this.type) || `TNodeType.?${this.type}?`;
    }
    get flags_() {
      const flags = [];
      if (this.flags & 16) flags.push('TNodeFlags.hasClassInput');
      if (this.flags & 8) flags.push('TNodeFlags.hasContentQuery');
      if (this.flags & 32) flags.push('TNodeFlags.hasStyleInput');
      if (this.flags & 128) flags.push('TNodeFlags.hasHostBindings');
      if (this.flags & 2) flags.push('TNodeFlags.isComponentHost');
      if (this.flags & 1) flags.push('TNodeFlags.isDirectiveHost');
      if (this.flags & 64) flags.push('TNodeFlags.isDetached');
      if (this.flags & 4) flags.push('TNodeFlags.isProjected');
      return flags.join('|');
    }
    get template_() {
      if (this.type & 1) return this.value;
      const buf = [];
      const tagName = typeof this.value === 'string' && this.value || this.type_;
      buf.push('<', tagName);
      if (this.flags) {
        buf.push(' ', this.flags_);
      }
      if (this.attrs) {
        for (let i = 0; i < this.attrs.length;) {
          const attrName = this.attrs[i++];
          if (typeof attrName == 'number') {
            break;
          }
          const attrValue = this.attrs[i++];
          buf.push(' ', attrName, '="', attrValue, '"');
        }
      }
      buf.push('>');
      processTNodeChildren(this.child, buf);
      buf.push('</', tagName, '>');
      return buf.join('');
    }
    get styleBindings_() {
      return toDebugStyleBinding(this, false);
    }
    get classBindings_() {
      return toDebugStyleBinding(this, true);
    }
    get providerIndexStart_() {
      return this.providerIndexes & 1048575;
    }
    get providerIndexEnd_() {
      return this.providerIndexStart_ + (this.providerIndexes >>> 20);
    }
  };
  var TNodeDebug = TNode;
  function toDebugStyleBinding(tNode, isClassBased) {
    const tData = tNode.tView_.data;
    const bindings = [];
    const range2 = isClassBased ? tNode.classBindings : tNode.styleBindings;
    const prev = getTStylingRangePrev(range2);
    const next = getTStylingRangeNext(range2);
    let isTemplate = next !== 0;
    let cursor = isTemplate ? next : prev;
    while (cursor !== 0) {
      const itemKey = tData[cursor];
      const itemRange = tData[cursor + 1];
      bindings.unshift({
        key: itemKey,
        index: cursor,
        isTemplate,
        prevDuplicate: getTStylingRangePrevDuplicate(itemRange),
        nextDuplicate: getTStylingRangeNextDuplicate(itemRange),
        nextIndex: getTStylingRangeNext(itemRange),
        prevIndex: getTStylingRangePrev(itemRange)
      });
      if (cursor === prev) isTemplate = false;
      cursor = getTStylingRangePrev(itemRange);
    }
    bindings.push((isClassBased ? tNode.residualClasses : tNode.residualStyles) || null);
    return bindings;
  }
  function processTNodeChildren(tNode, buf) {
    while (tNode) {
      buf.push(tNode.template_);
      tNode = tNode.next;
    }
  }
  var TViewData = NG_DEV_MODE && createNamedArrayType('TViewData') || null;
  var TVIEWDATA_EMPTY;
  function cloneToTViewData(list) {
    if (TVIEWDATA_EMPTY === void 0) TVIEWDATA_EMPTY = new TViewData();
    return TVIEWDATA_EMPTY.concat(list);
  }
  var LViewBlueprint = NG_DEV_MODE && createNamedArrayType('LViewBlueprint') || null;
  var MatchesArray = NG_DEV_MODE && createNamedArrayType('MatchesArray') || null;
  var TViewComponents = NG_DEV_MODE && createNamedArrayType('TViewComponents') || null;
  var TNodeLocalNames = NG_DEV_MODE && createNamedArrayType('TNodeLocalNames') || null;
  var TNodeInitialInputs = NG_DEV_MODE && createNamedArrayType('TNodeInitialInputs') || null;
  var TNodeInitialData = NG_DEV_MODE && createNamedArrayType('TNodeInitialData') || null;
  var LCleanup = NG_DEV_MODE && createNamedArrayType('LCleanup') || null;
  var TCleanup = NG_DEV_MODE && createNamedArrayType('TCleanup') || null;
  function attachLViewDebug(lView) {
    attachDebugObject(lView, new LViewDebug(lView));
  }
  function attachLContainerDebug(lContainer) {
    attachDebugObject(lContainer, new LContainerDebug(lContainer));
  }
  function toDebug(obj) {
    if (obj) {
      const debug = obj.debug;
      assertDefined(debug, 'Object does not have a debug representation.');
      return debug;
    } else {
      return obj;
    }
  }
  function toHtml(value, includeChildren = false) {
    const node = unwrapRNode(value);
    if (node) {
      switch (node.nodeType) {
        case Node.TEXT_NODE:
          return node.textContent;
        case Node.COMMENT_NODE:
          return `<!--${node.textContent}-->`;
        case Node.ELEMENT_NODE:
          const outerHTML = node.outerHTML;
          if (includeChildren) {
            return outerHTML;
          } else {
            const innerHTML = '>' + node.innerHTML + '<';
            return outerHTML.split(innerHTML)[0] + '>';
          }
      }
    }
    return null;
  }
  var LViewDebug = class {
    constructor(_raw_lView) {
      this._raw_lView = _raw_lView;
    }
    get flags() {
      const flags = this._raw_lView[FLAGS];
      return {
        __raw__flags__: flags,
        initPhaseState: flags & 3,
        creationMode: !!(flags & 4),
        firstViewPass: !!(flags & 8),
        checkAlways: !!(flags & 16),
        dirty: !!(flags & 64),
        attached: !!(flags & 128),
        destroyed: !!(flags & 256),
        isRoot: !!(flags & 512),
        indexWithinInitPhase: flags >> 11
      };
    }
    get parent() {
      return toDebug(this._raw_lView[PARENT]);
    }
    get hostHTML() {
      return toHtml(this._raw_lView[HOST], true);
    }
    get html() {
      return (this.nodes || []).map(mapToHTML).join('');
    }
    get context() {
      return this._raw_lView[CONTEXT];
    }
    get nodes() {
      const lView = this._raw_lView;
      const tNode = lView[TVIEW].firstChild;
      return toDebugNodes(tNode, lView);
    }
    get template() {
      return this.tView.template_;
    }
    get tView() {
      return this._raw_lView[TVIEW];
    }
    get cleanup() {
      return this._raw_lView[CLEANUP];
    }
    get injector() {
      return this._raw_lView[INJECTOR];
    }
    get rendererFactory() {
      return this._raw_lView[RENDERER_FACTORY];
    }
    get renderer() {
      return this._raw_lView[RENDERER];
    }
    get sanitizer() {
      return this._raw_lView[SANITIZER];
    }
    get childHead() {
      return toDebug(this._raw_lView[CHILD_HEAD]);
    }
    get next() {
      return toDebug(this._raw_lView[NEXT]);
    }
    get childTail() {
      return toDebug(this._raw_lView[CHILD_TAIL]);
    }
    get declarationView() {
      return toDebug(this._raw_lView[DECLARATION_VIEW]);
    }
    get queries() {
      return this._raw_lView[QUERIES];
    }
    get tHost() {
      return this._raw_lView[T_HOST];
    }
    get decls() {
      return toLViewRange(this.tView, this._raw_lView, HEADER_OFFSET, this.tView.bindingStartIndex);
    }
    get vars() {
      return toLViewRange(
          this.tView, this._raw_lView, this.tView.bindingStartIndex, this.tView.expandoStartIndex);
    }
    get expando() {
      return toLViewRange(
          this.tView, this._raw_lView, this.tView.expandoStartIndex, this._raw_lView.length);
    }
    get childViews() {
      const childViews = [];
      let child = this.childHead;
      while (child) {
        childViews.push(child);
        child = child.next;
      }
      return childViews;
    }
  };
  function mapToHTML(node) {
    if (node.type === 'ElementContainer') {
      return (node.children || []).map(mapToHTML).join('');
    } else if (node.type === 'IcuContainer') {
      throw new Error('Not implemented');
    } else {
      return toHtml(node.native, true) || '';
    }
  }
  function toLViewRange(tView, lView, start, end) {
    let content = [];
    for (let index = start; index < end; index++) {
      content.push({index, t: tView.data[index], l: lView[index]});
    }
    return {start, end, length: end - start, content};
  }
  function toDebugNodes(tNode, lView) {
    if (tNode) {
      const debugNodes = [];
      let tNodeCursor = tNode;
      while (tNodeCursor) {
        debugNodes.push(buildDebugNode(tNodeCursor, lView));
        tNodeCursor = tNodeCursor.next;
      }
      return debugNodes;
    } else {
      return [];
    }
  }
  function buildDebugNode(tNode, lView) {
    const rawValue = lView[tNode.index];
    const native = unwrapRNode(rawValue);
    const factories = [];
    const instances = [];
    const tView = lView[TVIEW];
    for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
      const def = tView.data[i];
      factories.push(def.type);
      instances.push(lView[i]);
    }
    return {
      html: toHtml(native),
      type: toTNodeTypeAsString(tNode.type),
      native,
      children: toDebugNodes(tNode.child, lView),
      factories,
      instances,
      injector: buildNodeInjectorDebug(tNode, tView, lView)
    };
  }
  function buildNodeInjectorDebug(tNode, tView, lView) {
    const viewProviders = [];
    for (let i = tNode.providerIndexStart_; i < tNode.providerIndexEnd_; i++) {
      viewProviders.push(tView.data[i]);
    }
    const providers = [];
    for (let i = tNode.providerIndexEnd_; i < tNode.directiveEnd; i++) {
      providers.push(tView.data[i]);
    }
    const nodeInjectorDebug = {
      bloom: toBloom(lView, tNode.injectorIndex),
      cumulativeBloom: toBloom(tView.data, tNode.injectorIndex),
      providers,
      viewProviders,
      parentInjectorIndex: lView[tNode.providerIndexStart_ - 1]
    };
    return nodeInjectorDebug;
  }
  function binary(array, idx) {
    const value = array[idx];
    if (typeof value !== 'number') return '????????';
    const text = '00000000' + value.toString(2);
    return text.substring(text.length - 8);
  }
  function toBloom(array, idx) {
    return `${binary(array, idx + 7)}_${binary(array, idx + 6)}_${binary(array, idx + 5)}_${
        binary(array, idx + 4)}_${binary(array, idx + 3)}_${binary(array, idx + 2)}_${
        binary(array, idx + 1)}_${binary(array, idx + 0)}`;
  }
  var LContainerDebug = class {
    constructor(_raw_lContainer) {
      this._raw_lContainer = _raw_lContainer;
    }
    get hasTransplantedViews() {
      return this._raw_lContainer[HAS_TRANSPLANTED_VIEWS];
    }
    get views() {
      return this._raw_lContainer.slice(CONTAINER_HEADER_OFFSET).map(toDebug);
    }
    get parent() {
      return toDebug(this._raw_lContainer[PARENT]);
    }
    get movedViews() {
      return this._raw_lContainer[MOVED_VIEWS];
    }
    get host() {
      return this._raw_lContainer[HOST];
    }
    get native() {
      return this._raw_lContainer[NATIVE];
    }
    get next() {
      return toDebug(this._raw_lContainer[NEXT]);
    }
  };
  var \u02750$5 = () => Promise.resolve(null);
  var _CLEAN_PROMISE = \u02750$5();
  function processHostBindingOpCodes(tView, lView) {
    const hostBindingOpCodes = tView.hostBindingOpCodes;
    if (hostBindingOpCodes === null) return;
    try {
      for (let i = 0; i < hostBindingOpCodes.length; i++) {
        const opCode = hostBindingOpCodes[i];
        if (opCode < 0) {
          setSelectedIndex(~opCode);
        } else {
          const directiveIdx = opCode;
          const bindingRootIndx = hostBindingOpCodes[++i];
          const hostBindingFn = hostBindingOpCodes[++i];
          setBindingRootForHostBindings(bindingRootIndx, directiveIdx);
          const context = lView[directiveIdx];
          hostBindingFn(2, context);
        }
      }
    } finally {
      setSelectedIndex(-1);
    }
  }
  function refreshContentQueries(tView, lView) {
    const contentQueries = tView.contentQueries;
    if (contentQueries !== null) {
      for (let i = 0; i < contentQueries.length; i += 2) {
        const queryStartIdx = contentQueries[i];
        const directiveDefIdx = contentQueries[i + 1];
        if (directiveDefIdx !== -1) {
          const directiveDef = tView.data[directiveDefIdx];
          ngDevMode && assertDefined(directiveDef, 'DirectiveDef not found.');
          ngDevMode &&
              assertDefined(
                  directiveDef.contentQueries, 'contentQueries function should be defined');
          setCurrentQueryIndex(queryStartIdx);
          directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
        }
      }
    }
  }
  function refreshChildComponents(hostLView, components) {
    for (let i = 0; i < components.length; i++) {
      refreshComponent(hostLView, components[i]);
    }
  }
  function renderChildComponents(hostLView, components) {
    for (let i = 0; i < components.length; i++) {
      renderComponent(hostLView, components[i]);
    }
  }
  function createLView(
      parentLView, tView, context, flags, host, tHostNode, rendererFactory, renderer, sanitizer,
      injector) {
    const lView = ngDevMode ? cloneToLViewFromTViewBlueprint(tView) : tView.blueprint.slice();
    lView[HOST] = host;
    lView[FLAGS] = flags | 4 | 128 | 8;
    resetPreOrderHookFlags(lView);
    ngDevMode && tView.declTNode && parentLView &&
        assertTNodeForLView(tView.declTNode, parentLView);
    lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
    lView[CONTEXT] = context;
    lView[RENDERER_FACTORY] = rendererFactory || parentLView && parentLView[RENDERER_FACTORY];
    ngDevMode && assertDefined(lView[RENDERER_FACTORY], 'RendererFactory is required');
    lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];
    ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');
    lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null;
    lView[INJECTOR] = injector || parentLView && parentLView[INJECTOR] || null;
    lView[T_HOST] = tHostNode;
    ngDevMode &&
        assertEqual(
            tView.type == 2 ? parentLView !== null : true, true,
            'Embedded views must have parentLView');
    lView[DECLARATION_COMPONENT_VIEW] =
        tView.type == 2 ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;
    ngDevMode && attachLViewDebug(lView);
    return lView;
  }
  function getOrCreateTNode(tView, index, type, name, attrs) {
    ngDevMode && index !== 0 &&
        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\'t be in the LView header.');
    ngDevMode && assertPureTNodeType(type);
    let tNode = tView.data[index];
    if (tNode === null) {
      tNode = createTNodeAtIndex(tView, index, type, name, attrs);
      if (isInI18nBlock()) {
        tNode.flags |= 64;
      }
    } else if (tNode.type & 64) {
      tNode.type = type;
      tNode.value = name;
      tNode.attrs = attrs;
      const parent = getCurrentParentTNode();
      tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
      ngDevMode && assertTNodeForTView(tNode, tView);
      ngDevMode && assertEqual(index, tNode.index, 'Expecting same index');
    }
    setCurrentTNode(tNode, true);
    return tNode;
  }
  function createTNodeAtIndex(tView, index, type, name, attrs) {
    const currentTNode = getCurrentTNodePlaceholderOk();
    const isParent = isCurrentTNodeParent();
    const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;
    const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs);
    if (tView.firstChild === null) {
      tView.firstChild = tNode;
    }
    if (currentTNode !== null) {
      if (isParent) {
        if (currentTNode.child == null && tNode.parent !== null) {
          currentTNode.child = tNode;
        }
      } else {
        if (currentTNode.next === null) {
          currentTNode.next = tNode;
        }
      }
    }
    return tNode;
  }
  function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
    if (numSlotsToAlloc === 0) return -1;
    if (ngDevMode) {
      assertFirstCreatePass(tView);
      assertSame(tView, lView[TVIEW], '`LView` must be associated with `TView`!');
      assertEqual(tView.data.length, lView.length, 'Expecting LView to be same size as TView');
      assertEqual(
          tView.data.length, tView.blueprint.length,
          'Expecting Blueprint to be same size as TView');
      assertFirstUpdatePass(tView);
    }
    const allocIdx = lView.length;
    for (let i = 0; i < numSlotsToAlloc; i++) {
      lView.push(initialValue);
      tView.blueprint.push(initialValue);
      tView.data.push(null);
    }
    return allocIdx;
  }
  function renderView(tView, lView, context) {
    ngDevMode && assertEqual(isCreationMode(lView), true, 'Should be run in creation mode');
    enterView(lView);
    try {
      const viewQuery = tView.viewQuery;
      if (viewQuery !== null) {
        executeViewQueryFn(1, viewQuery, context);
      }
      const templateFn = tView.template;
      if (templateFn !== null) {
        executeTemplate(tView, lView, templateFn, 1, context);
      }
      if (tView.firstCreatePass) {
        tView.firstCreatePass = false;
      }
      if (tView.staticContentQueries) {
        refreshContentQueries(tView, lView);
      }
      if (tView.staticViewQueries) {
        executeViewQueryFn(2, tView.viewQuery, context);
      }
      const components = tView.components;
      if (components !== null) {
        renderChildComponents(lView, components);
      }
    } catch (error) {
      if (tView.firstCreatePass) {
        tView.incompleteFirstPass = true;
      }
      throw error;
    } finally {
      lView[FLAGS] &= ~4;
      leaveView();
    }
  }
  function refreshView(tView, lView, templateFn, context) {
    ngDevMode && assertEqual(isCreationMode(lView), false, 'Should be run in update mode');
    const flags = lView[FLAGS];
    if ((flags & 256) === 256) return;
    enterView(lView);
    const isInCheckNoChangesPass = isInCheckNoChangesMode();
    try {
      resetPreOrderHookFlags(lView);
      setBindingIndex(tView.bindingStartIndex);
      if (templateFn !== null) {
        executeTemplate(tView, lView, templateFn, 2, context);
      }
      const hooksInitPhaseCompleted = (flags & 3) === 3;
      if (!isInCheckNoChangesPass) {
        if (hooksInitPhaseCompleted) {
          const preOrderCheckHooks = tView.preOrderCheckHooks;
          if (preOrderCheckHooks !== null) {
            executeCheckHooks(lView, preOrderCheckHooks, null);
          }
        } else {
          const preOrderHooks = tView.preOrderHooks;
          if (preOrderHooks !== null) {
            executeInitAndCheckHooks(lView, preOrderHooks, 0, null);
          }
          incrementInitPhaseFlags(lView, 0);
        }
      }
      markTransplantedViewsForRefresh(lView);
      refreshEmbeddedViews(lView);
      if (tView.contentQueries !== null) {
        refreshContentQueries(tView, lView);
      }
      if (!isInCheckNoChangesPass) {
        if (hooksInitPhaseCompleted) {
          const contentCheckHooks = tView.contentCheckHooks;
          if (contentCheckHooks !== null) {
            executeCheckHooks(lView, contentCheckHooks);
          }
        } else {
          const contentHooks = tView.contentHooks;
          if (contentHooks !== null) {
            executeInitAndCheckHooks(lView, contentHooks, 1);
          }
          incrementInitPhaseFlags(lView, 1);
        }
      }
      processHostBindingOpCodes(tView, lView);
      const components = tView.components;
      if (components !== null) {
        refreshChildComponents(lView, components);
      }
      const viewQuery = tView.viewQuery;
      if (viewQuery !== null) {
        executeViewQueryFn(2, viewQuery, context);
      }
      if (!isInCheckNoChangesPass) {
        if (hooksInitPhaseCompleted) {
          const viewCheckHooks = tView.viewCheckHooks;
          if (viewCheckHooks !== null) {
            executeCheckHooks(lView, viewCheckHooks);
          }
        } else {
          const viewHooks = tView.viewHooks;
          if (viewHooks !== null) {
            executeInitAndCheckHooks(lView, viewHooks, 2);
          }
          incrementInitPhaseFlags(lView, 2);
        }
      }
      if (tView.firstUpdatePass === true) {
        tView.firstUpdatePass = false;
      }
      if (!isInCheckNoChangesPass) {
        lView[FLAGS] &= ~(64 | 8);
      }
      if (lView[FLAGS] & 1024) {
        lView[FLAGS] &= ~1024;
        updateTransplantedViewCount(lView[PARENT], -1);
      }
    } finally {
      leaveView();
    }
  }
  function renderComponentOrTemplate(tView, lView, templateFn, context) {
    const rendererFactory = lView[RENDERER_FACTORY];
    const normalExecutionPath = !isInCheckNoChangesMode();
    const creationModeIsActive = isCreationMode(lView);
    try {
      if (normalExecutionPath && !creationModeIsActive && rendererFactory.begin) {
        rendererFactory.begin();
      }
      if (creationModeIsActive) {
        renderView(tView, lView, context);
      }
      refreshView(tView, lView, templateFn, context);
    } finally {
      if (normalExecutionPath && !creationModeIsActive && rendererFactory.end) {
        rendererFactory.end();
      }
    }
  }
  function executeTemplate(tView, lView, templateFn, rf, context) {
    const prevSelectedIndex = getSelectedIndex();
    try {
      setSelectedIndex(-1);
      if (rf & 2 && lView.length > HEADER_OFFSET) {
        selectIndexInternal(tView, lView, HEADER_OFFSET, isInCheckNoChangesMode());
      }
      templateFn(rf, context);
    } finally {
      setSelectedIndex(prevSelectedIndex);
    }
  }
  function executeContentQueries(tView, tNode, lView) {
    if (isContentQueryHost(tNode)) {
      const start = tNode.directiveStart;
      const end = tNode.directiveEnd;
      for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
        const def = tView.data[directiveIndex];
        if (def.contentQueries) {
          def.contentQueries(1, lView[directiveIndex], directiveIndex);
        }
      }
    }
  }
  function createDirectivesInstances(tView, lView, tNode) {
    if (!getBindingsEnabled()) return;
    instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));
    if ((tNode.flags & 128) === 128) {
      invokeDirectivesHostBindings(tView, lView, tNode);
    }
  }
  function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {
    const localNames = tNode.localNames;
    if (localNames !== null) {
      let localIndex = tNode.index + 1;
      for (let i = 0; i < localNames.length; i += 2) {
        const index = localNames[i + 1];
        const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];
        viewData[localIndex++] = value;
      }
    }
  }
  function getOrCreateTComponentView(def) {
    const tView = def.tView;
    if (tView === null || tView.incompleteFirstPass) {
      const declTNode = null;
      return def.tView = createTView(
                 1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs,
                 def.viewQuery, def.schemas, def.consts);
    }
    return tView;
  }
  function createTView(
      type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas,
      constsOrFactory) {
    ngDevMode && ngDevMode.tView++;
    const bindingStartIndex = HEADER_OFFSET + decls;
    const initialViewLength = bindingStartIndex + vars;
    const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
    const consts = typeof constsOrFactory === 'function' ? constsOrFactory() : constsOrFactory;
    const tView = blueprint[TVIEW] = ngDevMode ?
        new TViewConstructor(
            type, blueprint, templateFn, null, viewQuery, declTNode,
            cloneToTViewData(blueprint).fill(null, bindingStartIndex), bindingStartIndex,
            initialViewLength, null, true, true, false, false, null, null, null, null, null, null,
            null, null, null, null, typeof directives === 'function' ? directives() : directives,
            typeof pipes === 'function' ? pipes() : pipes, null, schemas, consts, false, decls,
            vars) :
        {
          type,
          blueprint,
          template: templateFn,
          queries: null,
          viewQuery,
          declTNode,
          data: blueprint.slice().fill(null, bindingStartIndex),
          bindingStartIndex,
          expandoStartIndex: initialViewLength,
          hostBindingOpCodes: null,
          firstCreatePass: true,
          firstUpdatePass: true,
          staticViewQueries: false,
          staticContentQueries: false,
          preOrderHooks: null,
          preOrderCheckHooks: null,
          contentHooks: null,
          contentCheckHooks: null,
          viewHooks: null,
          viewCheckHooks: null,
          destroyHooks: null,
          cleanup: null,
          contentQueries: null,
          components: null,
          directiveRegistry: typeof directives === 'function' ? directives() : directives,
          pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,
          firstChild: null,
          schemas,
          consts,
          incompleteFirstPass: false
        };
    if (ngDevMode) {
      Object.seal(tView);
    }
    return tView;
  }
  function createViewBlueprint(bindingStartIndex, initialViewLength) {
    const blueprint = ngDevMode ? new LViewBlueprint() : [];
    for (let i = 0; i < initialViewLength; i++) {
      blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
    }
    return blueprint;
  }
  function createError(text, token) {
    return new Error(`Renderer: ${text} [${stringifyForError(token)}]`);
  }
  function assertHostNodeExists(rElement, elementOrSelector) {
    if (!rElement) {
      if (typeof elementOrSelector === 'string') {
        throw createError('Host node with selector not found:', elementOrSelector);
      } else {
        throw createError('Host node is required:', elementOrSelector);
      }
    }
  }
  function locateHostElement(renderer, elementOrSelector, encapsulation) {
    if (isProceduralRenderer(renderer)) {
      const preserveContent = encapsulation === ViewEncapsulation.ShadowDom;
      return renderer.selectRootElement(elementOrSelector, preserveContent);
    }
    let rElement = typeof elementOrSelector === 'string' ?
        renderer.querySelector(elementOrSelector) :
        elementOrSelector;
    ngDevMode && assertHostNodeExists(rElement, elementOrSelector);
    rElement.textContent = '';
    return rElement;
  }
  function storeCleanupWithContext(tView, lView, context, cleanupFn) {
    const lCleanup = getOrCreateLViewCleanup(lView);
    if (context === null) {
      if (ngDevMode) {
        Object.freeze(getOrCreateTViewCleanup(tView));
      }
      lCleanup.push(cleanupFn);
    } else {
      lCleanup.push(context);
      if (tView.firstCreatePass) {
        getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
      }
    }
  }
  function createTNode(tView, tParent, type, index, value, attrs) {
    ngDevMode && index !== 0 &&
        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\'t be in the LView header.');
    ngDevMode && assertNotSame(attrs, void 0, '\'undefined\' is not valid value for \'attrs\'');
    ngDevMode && ngDevMode.tNode++;
    ngDevMode && tParent && assertTNodeForTView(tParent, tView);
    let injectorIndex = tParent ? tParent.injectorIndex : -1;
    const tNode = ngDevMode ?
        new TNodeDebug(
            tView, type, index, null, injectorIndex, -1, -1, -1, null, 0, 0, value, attrs, null,
            null, void 0, null, null, null, null, null, null, tParent, null, null, null, void 0,
            null, null, void 0, 0, 0) :
        {
          type,
          index,
          insertBeforeIndex: null,
          injectorIndex,
          directiveStart: -1,
          directiveEnd: -1,
          directiveStylingLast: -1,
          propertyBindings: null,
          flags: 0,
          providerIndexes: 0,
          value,
          attrs,
          mergedAttrs: null,
          localNames: null,
          initialInputs: void 0,
          inputs: null,
          outputs: null,
          tViews: null,
          next: null,
          projectionNext: null,
          child: null,
          parent: tParent,
          projection: null,
          styles: null,
          stylesWithoutHost: null,
          residualStyles: void 0,
          classes: null,
          classesWithoutHost: null,
          residualClasses: void 0,
          classBindings: 0,
          styleBindings: 0
        };
    if (ngDevMode) {
      Object.seal(tNode);
    }
    return tNode;
  }
  function generatePropertyAliases(inputAliasMap, directiveDefIdx, propStore) {
    for (let publicName in inputAliasMap) {
      if (inputAliasMap.hasOwnProperty(publicName)) {
        propStore = propStore === null ? {} : propStore;
        const internalName = inputAliasMap[publicName];
        if (propStore.hasOwnProperty(publicName)) {
          propStore[publicName].push(directiveDefIdx, internalName);
        } else {
          propStore[publicName] = [directiveDefIdx, internalName];
        }
      }
    }
    return propStore;
  }
  function initializeInputAndOutputAliases(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView);
    const start = tNode.directiveStart;
    const end = tNode.directiveEnd;
    const tViewData = tView.data;
    const tNodeAttrs = tNode.attrs;
    const inputsFromAttrs = ngDevMode ? new TNodeInitialInputs() : [];
    let inputsStore = null;
    let outputsStore = null;
    for (let i = start; i < end; i++) {
      const directiveDef = tViewData[i];
      const directiveInputs = directiveDef.inputs;
      const initialInputs = tNodeAttrs !== null && !isInlineTemplate(tNode) ?
          generateInitialInputs(directiveInputs, tNodeAttrs) :
          null;
      inputsFromAttrs.push(initialInputs);
      inputsStore = generatePropertyAliases(directiveInputs, i, inputsStore);
      outputsStore = generatePropertyAliases(directiveDef.outputs, i, outputsStore);
    }
    if (inputsStore !== null) {
      if (inputsStore.hasOwnProperty('class')) {
        tNode.flags |= 16;
      }
      if (inputsStore.hasOwnProperty('style')) {
        tNode.flags |= 32;
      }
    }
    tNode.initialInputs = inputsFromAttrs;
    tNode.inputs = inputsStore;
    tNode.outputs = outputsStore;
  }
  function mapPropName(name) {
    if (name === 'class') return 'className';
    if (name === 'for') return 'htmlFor';
    if (name === 'formaction') return 'formAction';
    if (name === 'innerHtml') return 'innerHTML';
    if (name === 'readonly') return 'readOnly';
    if (name === 'tabindex') return 'tabIndex';
    return name;
  }
  function elementPropertyInternal(
      tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {
    ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');
    const element = getNativeByTNode(tNode, lView);
    let inputData = tNode.inputs;
    let dataValue;
    if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {
      setInputsForProperty(tView, lView, dataValue, propName, value);
      if (isComponentHost(tNode)) markDirtyIfOnPush(lView, tNode.index);
      if (ngDevMode) {
        setNgReflectProperties(lView, element, tNode.type, dataValue, value);
      }
    } else if (tNode.type & 3) {
      propName = mapPropName(propName);
      if (ngDevMode) {
        validateAgainstEventProperties(propName);
        if (!validateProperty(tView, element, propName, tNode)) {
          logUnknownPropertyError(propName, tNode);
          return;
        }
        ngDevMode.rendererSetProperty++;
      }
      value = sanitizer != null ? sanitizer(value, tNode.value || '', propName) : value;
      if (isProceduralRenderer(renderer)) {
        renderer.setProperty(element, propName, value);
      } else if (!isAnimationProp(propName)) {
        element.setProperty ? element.setProperty(propName, value) : element[propName] = value;
      }
    } else if (tNode.type & 12) {
      if (ngDevMode && !matchingSchemas(tView, tNode.value)) {
        logUnknownPropertyError(propName, tNode);
      }
    }
  }
  function markDirtyIfOnPush(lView, viewIndex) {
    ngDevMode && assertLView(lView);
    const childComponentLView = getComponentLViewByIndex(viewIndex, lView);
    if (!(childComponentLView[FLAGS] & 16)) {
      childComponentLView[FLAGS] |= 64;
    }
  }
  function setNgReflectProperty(lView, element, type, attrName, value) {
    const renderer = lView[RENDERER];
    attrName = normalizeDebugBindingName(attrName);
    const debugValue = normalizeDebugBindingValue(value);
    if (type & 3) {
      if (value == null) {
        isProceduralRenderer(renderer) ? renderer.removeAttribute(element, attrName) :
                                         element.removeAttribute(attrName);
      } else {
        isProceduralRenderer(renderer) ? renderer.setAttribute(element, attrName, debugValue) :
                                         element.setAttribute(attrName, debugValue);
      }
    } else {
      const textContent =
          escapeCommentText(`bindings=${JSON.stringify({[attrName]: debugValue}, null, 2)}`);
      if (isProceduralRenderer(renderer)) {
        renderer.setValue(element, textContent);
      } else {
        element.textContent = textContent;
      }
    }
  }
  function setNgReflectProperties(lView, element, type, dataValue, value) {
    if (type & (3 | 4)) {
      for (let i = 0; i < dataValue.length; i += 2) {
        setNgReflectProperty(lView, element, type, dataValue[i + 1], value);
      }
    }
  }
  function validateProperty(tView, element, propName, tNode) {
    if (tView.schemas === null) return true;
    if (matchingSchemas(tView, tNode.value) || propName in element || isAnimationProp(propName)) {
      return true;
    }
    return typeof Node === 'undefined' || Node === null || !(element instanceof Node);
  }
  function matchingSchemas(tView, tagName) {
    const schemas = tView.schemas;
    if (schemas !== null) {
      for (let i = 0; i < schemas.length; i++) {
        const schema = schemas[i];
        if (schema === NO_ERRORS_SCHEMA ||
            schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) {
          return true;
        }
      }
    }
    return false;
  }
  function logUnknownPropertyError(propName, tNode) {
    let message =
        `Can't bind to '${propName}' since it isn't a known property of '${tNode.value}'.`;
    console.error(formatRuntimeError('303', message));
  }
  function instantiateRootComponent(tView, lView, def) {
    const rootTNode = getCurrentTNode();
    if (tView.firstCreatePass) {
      if (def.providersResolver) def.providersResolver(def);
      const directiveIndex = allocExpando(tView, lView, 1, null);
      ngDevMode &&
          assertEqual(
              directiveIndex, rootTNode.directiveStart,
              'Because this is a root component the allocated expando should match the TNode component.');
      configureViewWithDirective(tView, rootTNode, lView, directiveIndex, def);
    }
    const directive = getNodeInjectable(lView, tView, rootTNode.directiveStart, rootTNode);
    attachPatchData(directive, lView);
    const native = getNativeByTNode(rootTNode, lView);
    if (native) {
      attachPatchData(native, lView);
    }
    return directive;
  }
  function resolveDirectives(tView, lView, tNode, localRefs) {
    ngDevMode && assertFirstCreatePass(tView);
    let hasDirectives = false;
    if (getBindingsEnabled()) {
      const directiveDefs = findDirectiveDefMatches(tView, lView, tNode);
      const exportsMap = localRefs === null ? null : {'': -1};
      if (directiveDefs !== null) {
        hasDirectives = true;
        initTNodeFlags(tNode, tView.data.length, directiveDefs.length);
        for (let i = 0; i < directiveDefs.length; i++) {
          const def = directiveDefs[i];
          if (def.providersResolver) def.providersResolver(def);
        }
        let preOrderHooksFound = false;
        let preOrderCheckHooksFound = false;
        let directiveIdx = allocExpando(tView, lView, directiveDefs.length, null);
        ngDevMode &&
            assertSame(
                directiveIdx, tNode.directiveStart,
                'TNode.directiveStart should point to just allocated space');
        for (let i = 0; i < directiveDefs.length; i++) {
          const def = directiveDefs[i];
          tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
          configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
          saveNameToExportMap(directiveIdx, def, exportsMap);
          if (def.contentQueries !== null) tNode.flags |= 8;
          if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0)
            tNode.flags |= 128;
          const lifeCycleHooks = def.type.prototype;
          if (!preOrderHooksFound &&
              (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
            (tView.preOrderHooks || (tView.preOrderHooks = [])).push(tNode.index);
            preOrderHooksFound = true;
          }
          if (!preOrderCheckHooksFound &&
              (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
            (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(tNode.index);
            preOrderCheckHooksFound = true;
          }
          directiveIdx++;
        }
        initializeInputAndOutputAliases(tView, tNode);
      }
      if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);
    }
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
    return hasDirectives;
  }
  function registerHostBindingOpCodes(tView, tNode, lView, directiveIdx, directiveVarsIdx, def) {
    ngDevMode && assertFirstCreatePass(tView);
    const hostBindings = def.hostBindings;
    if (hostBindings) {
      let hostBindingOpCodes = tView.hostBindingOpCodes;
      if (hostBindingOpCodes === null) {
        hostBindingOpCodes = tView.hostBindingOpCodes = [];
      }
      const elementIndx = ~tNode.index;
      if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
        hostBindingOpCodes.push(elementIndx);
      }
      hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
    }
  }
  function lastSelectedElementIdx(hostBindingOpCodes) {
    let i = hostBindingOpCodes.length;
    while (i > 0) {
      const value = hostBindingOpCodes[--i];
      if (typeof value === 'number' && value < 0) {
        return value;
      }
    }
    return 0;
  }
  function instantiateAllDirectives(tView, lView, tNode, native) {
    const start = tNode.directiveStart;
    const end = tNode.directiveEnd;
    if (!tView.firstCreatePass) {
      getOrCreateNodeInjectorForNode(tNode, lView);
    }
    attachPatchData(native, lView);
    const initialInputs = tNode.initialInputs;
    for (let i = start; i < end; i++) {
      const def = tView.data[i];
      const isComponent = isComponentDef(def);
      if (isComponent) {
        ngDevMode && assertTNodeType(tNode, 3);
        addComponentLogic(lView, tNode, def);
      }
      const directive = getNodeInjectable(lView, tView, i, tNode);
      attachPatchData(directive, lView);
      if (initialInputs !== null) {
        setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);
      }
      if (isComponent) {
        const componentView = getComponentLViewByIndex(tNode.index, lView);
        componentView[CONTEXT] = directive;
      }
    }
  }
  function invokeDirectivesHostBindings(tView, lView, tNode) {
    const start = tNode.directiveStart;
    const end = tNode.directiveEnd;
    const firstCreatePass = tView.firstCreatePass;
    const elementIndex = tNode.index;
    const currentDirectiveIndex = getCurrentDirectiveIndex();
    try {
      setSelectedIndex(elementIndex);
      for (let dirIndex = start; dirIndex < end; dirIndex++) {
        const def = tView.data[dirIndex];
        const directive = lView[dirIndex];
        setCurrentDirectiveIndex(dirIndex);
        if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {
          invokeHostBindingsInCreationMode(def, directive);
        }
      }
    } finally {
      setSelectedIndex(-1);
      setCurrentDirectiveIndex(currentDirectiveIndex);
    }
  }
  function invokeHostBindingsInCreationMode(def, directive) {
    if (def.hostBindings !== null) {
      def.hostBindings(1, directive);
    }
  }
  function findDirectiveDefMatches(tView, viewData, tNode) {
    ngDevMode && assertFirstCreatePass(tView);
    ngDevMode && assertTNodeType(tNode, 3 | 12);
    const registry = tView.directiveRegistry;
    let matches = null;
    if (registry) {
      for (let i = 0; i < registry.length; i++) {
        const def = registry[i];
        if (isNodeMatchingSelectorList(tNode, def.selectors, false)) {
          matches || (matches = ngDevMode ? new MatchesArray() : []);
          diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type);
          if (isComponentDef(def)) {
            if (ngDevMode) {
              assertTNodeType(
                  tNode, 2,
                  `"${
                      tNode
                          .value}" tags cannot be used as component hosts. Please use a different tag to activate the ${
                      stringify(def.type)} component.`);
              if (tNode.flags & 2) throwMultipleComponentError(tNode);
            }
            markAsComponentHost(tView, tNode);
            matches.unshift(def);
          } else {
            matches.push(def);
          }
        }
      }
    }
    return matches;
  }
  function markAsComponentHost(tView, hostTNode) {
    ngDevMode && assertFirstCreatePass(tView);
    hostTNode.flags |= 2;
    (tView.components || (tView.components = ngDevMode ? new TViewComponents() : []))
        .push(hostTNode.index);
  }
  function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
    if (localRefs) {
      const localNames = tNode.localNames = ngDevMode ? new TNodeLocalNames() : [];
      for (let i = 0; i < localRefs.length; i += 2) {
        const index = exportsMap[localRefs[i + 1]];
        if (index == null)
          throw new RuntimeError('301', `Export of name '${localRefs[i + 1]}' not found!`);
        localNames.push(localRefs[i], index);
      }
    }
  }
  function saveNameToExportMap(directiveIdx, def, exportsMap) {
    if (exportsMap) {
      if (def.exportAs) {
        for (let i = 0; i < def.exportAs.length; i++) {
          exportsMap[def.exportAs[i]] = directiveIdx;
        }
      }
      if (isComponentDef(def)) exportsMap[''] = directiveIdx;
    }
  }
  function initTNodeFlags(tNode, index, numberOfDirectives) {
    ngDevMode &&
        assertNotEqual(
            numberOfDirectives, tNode.directiveEnd - tNode.directiveStart,
            'Reached the max number of directives');
    tNode.flags |= 1;
    tNode.directiveStart = index;
    tNode.directiveEnd = index + numberOfDirectives;
    tNode.providerIndexes = index;
  }
  function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
    ngDevMode &&
        assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, 'Must be in Expando section');
    tView.data[directiveIndex] = def;
    const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));
    const nodeInjectorFactory =
        new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);
    tView.blueprint[directiveIndex] = nodeInjectorFactory;
    lView[directiveIndex] = nodeInjectorFactory;
    registerHostBindingOpCodes(
        tView, tNode, lView, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE),
        def);
  }
  function addComponentLogic(lView, hostTNode, def) {
    const native = getNativeByTNode(hostTNode, lView);
    const tView = getOrCreateTComponentView(def);
    const rendererFactory = lView[RENDERER_FACTORY];
    const componentView = addToViewTree(
        lView,
        createLView(
            lView, tView, null, def.onPush ? 64 : 16, native, hostTNode, rendererFactory,
            rendererFactory.createRenderer(native, def), null, null));
    lView[hostTNode.index] = componentView;
  }
  function elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {
    if (ngDevMode) {
      assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');
      validateAgainstEventAttributes(name);
      assertTNodeType(
          tNode, 2,
          `Attempted to set attribute \`${
              name}\` on a container node. Host bindings are not valid on ng-container or ng-template.`);
    }
    const element = getNativeByTNode(tNode, lView);
    setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);
  }
  function setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {
    if (value == null) {
      ngDevMode && ngDevMode.rendererRemoveAttribute++;
      isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name, namespace) :
                                       element.removeAttribute(name);
    } else {
      ngDevMode && ngDevMode.rendererSetAttribute++;
      const strValue =
          sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || '', name);
      if (isProceduralRenderer(renderer)) {
        renderer.setAttribute(element, name, strValue, namespace);
      } else {
        namespace ? element.setAttributeNS(namespace, name, strValue) :
                    element.setAttribute(name, strValue);
      }
    }
  }
  function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
    const initialInputs = initialInputData[directiveIndex];
    if (initialInputs !== null) {
      const setInput = def.setInput;
      for (let i = 0; i < initialInputs.length;) {
        const publicName = initialInputs[i++];
        const privateName = initialInputs[i++];
        const value = initialInputs[i++];
        if (setInput !== null) {
          def.setInput(instance, value, publicName, privateName);
        } else {
          instance[privateName] = value;
        }
        if (ngDevMode) {
          const nativeElement = getNativeByTNode(tNode, lView);
          setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);
        }
      }
    }
  }
  function generateInitialInputs(inputs, attrs) {
    let inputsToStore = null;
    let i = 0;
    while (i < attrs.length) {
      const attrName = attrs[i];
      if (attrName === 0) {
        i += 4;
        continue;
      } else if (attrName === 5) {
        i += 2;
        continue;
      }
      if (typeof attrName === 'number') break;
      if (inputs.hasOwnProperty(attrName)) {
        if (inputsToStore === null) inputsToStore = [];
        inputsToStore.push(attrName, inputs[attrName], attrs[i + 1]);
      }
      i += 2;
    }
    return inputsToStore;
  }
  var LContainerArray = (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode() &&
      createNamedArrayType('LContainer');
  function createLContainer(hostNative, currentView, native, tNode) {
    ngDevMode && assertLView(currentView);
    ngDevMode && !isProceduralRenderer(currentView[RENDERER]) && assertDomNode(native);
    const lContainer = new (ngDevMode ? LContainerArray : Array)(
        hostNative, true, false, currentView, null, 0, tNode, native, null, null);
    ngDevMode &&
        assertEqual(
            lContainer.length, CONTAINER_HEADER_OFFSET,
            'Should allocate correct number of slots for LContainer header.');
    ngDevMode && attachLContainerDebug(lContainer);
    return lContainer;
  }
  function refreshEmbeddedViews(lView) {
    for (let lContainer = getFirstLContainer(lView); lContainer !== null;
         lContainer = getNextLContainer(lContainer)) {
      for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
        const embeddedLView = lContainer[i];
        const embeddedTView = embeddedLView[TVIEW];
        ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');
        if (viewAttachedToChangeDetector(embeddedLView)) {
          refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);
        }
      }
    }
  }
  function markTransplantedViewsForRefresh(lView) {
    for (let lContainer = getFirstLContainer(lView); lContainer !== null;
         lContainer = getNextLContainer(lContainer)) {
      if (!lContainer[HAS_TRANSPLANTED_VIEWS]) continue;
      const movedViews = lContainer[MOVED_VIEWS];
      ngDevMode && assertDefined(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');
      for (let i = 0; i < movedViews.length; i++) {
        const movedLView = movedViews[i];
        const insertionLContainer = movedLView[PARENT];
        ngDevMode && assertLContainer(insertionLContainer);
        if ((movedLView[FLAGS] & 1024) === 0) {
          updateTransplantedViewCount(insertionLContainer, 1);
        }
        movedLView[FLAGS] |= 1024;
      }
    }
  }
  function refreshComponent(hostLView, componentHostIdx) {
    ngDevMode && assertEqual(isCreationMode(hostLView), false, 'Should be run in update mode');
    const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
    if (viewAttachedToChangeDetector(componentView)) {
      const tView = componentView[TVIEW];
      if (componentView[FLAGS] & (16 | 64)) {
        refreshView(tView, componentView, tView.template, componentView[CONTEXT]);
      } else if (componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
        refreshContainsDirtyView(componentView);
      }
    }
  }
  function refreshContainsDirtyView(lView) {
    for (let lContainer = getFirstLContainer(lView); lContainer !== null;
         lContainer = getNextLContainer(lContainer)) {
      for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
        const embeddedLView = lContainer[i];
        if (embeddedLView[FLAGS] & 1024) {
          const embeddedTView = embeddedLView[TVIEW];
          ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');
          refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);
        } else if (embeddedLView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
          refreshContainsDirtyView(embeddedLView);
        }
      }
    }
    const tView = lView[TVIEW];
    const components = tView.components;
    if (components !== null) {
      for (let i = 0; i < components.length; i++) {
        const componentView = getComponentLViewByIndex(components[i], lView);
        if (viewAttachedToChangeDetector(componentView) &&
            componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
          refreshContainsDirtyView(componentView);
        }
      }
    }
  }
  function renderComponent(hostLView, componentHostIdx) {
    ngDevMode && assertEqual(isCreationMode(hostLView), true, 'Should be run in creation mode');
    const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
    const componentTView = componentView[TVIEW];
    syncViewWithBlueprint(componentTView, componentView);
    renderView(componentTView, componentView, componentView[CONTEXT]);
  }
  function syncViewWithBlueprint(tView, lView) {
    for (let i = lView.length; i < tView.blueprint.length; i++) {
      lView.push(tView.blueprint[i]);
    }
  }
  function addToViewTree(lView, lViewOrLContainer) {
    if (lView[CHILD_HEAD]) {
      lView[CHILD_TAIL][NEXT] = lViewOrLContainer;
    } else {
      lView[CHILD_HEAD] = lViewOrLContainer;
    }
    lView[CHILD_TAIL] = lViewOrLContainer;
    return lViewOrLContainer;
  }
  function markViewDirty(lView) {
    while (lView) {
      lView[FLAGS] |= 64;
      const parent = getLViewParent(lView);
      if (isRootView(lView) && !parent) {
        return lView;
      }
      lView = parent;
    }
    return null;
  }
  function scheduleTick(rootContext, flags) {
    const nothingScheduled = rootContext.flags === 0;
    if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {
      rootContext.flags |= flags;
      let res;
      rootContext.clean = new Promise((r) => res = r);
      rootContext.scheduler(() => {
        if (rootContext.flags & 1) {
          rootContext.flags &= ~1;
          tickRootContext(rootContext);
        }
        if (rootContext.flags & 2) {
          rootContext.flags &= ~2;
          const playerHandler = rootContext.playerHandler;
          if (playerHandler) {
            playerHandler.flushPlayers();
          }
        }
        rootContext.clean = _CLEAN_PROMISE;
        res(null);
      });
    }
  }
  function tickRootContext(rootContext) {
    for (let i = 0; i < rootContext.components.length; i++) {
      const rootComponent = rootContext.components[i];
      const lView = readPatchedLView(rootComponent);
      const tView = lView[TVIEW];
      renderComponentOrTemplate(tView, lView, tView.template, rootComponent);
    }
  }
  function detectChangesInternal(tView, lView, context) {
    const rendererFactory = lView[RENDERER_FACTORY];
    if (rendererFactory.begin) rendererFactory.begin();
    try {
      refreshView(tView, lView, tView.template, context);
    } catch (error) {
      handleError(lView, error);
      throw error;
    } finally {
      if (rendererFactory.end) rendererFactory.end();
    }
  }
  function detectChangesInRootView(lView) {
    tickRootContext(lView[CONTEXT]);
  }
  function checkNoChangesInternal(tView, view, context) {
    setIsInCheckNoChangesMode(true);
    try {
      detectChangesInternal(tView, view, context);
    } finally {
      setIsInCheckNoChangesMode(false);
    }
  }
  function checkNoChangesInRootView(lView) {
    setIsInCheckNoChangesMode(true);
    try {
      detectChangesInRootView(lView);
    } finally {
      setIsInCheckNoChangesMode(false);
    }
  }
  function executeViewQueryFn(flags, viewQueryFn, component) {
    ngDevMode && assertDefined(viewQueryFn, 'View queries function to execute must be defined.');
    setCurrentQueryIndex(0);
    viewQueryFn(flags, component);
  }
  function storePropertyBindingMetadata(
      tData, tNode, propertyName, bindingIndex, ...interpolationParts) {
    if (tData[bindingIndex] === null) {
      if (tNode.inputs == null || !tNode.inputs[propertyName]) {
        const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
        propBindingIdxs.push(bindingIndex);
        let bindingMetadata = propertyName;
        if (interpolationParts.length > 0) {
          bindingMetadata +=
              INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
        }
        tData[bindingIndex] = bindingMetadata;
      }
    }
  }
  var CLEAN_PROMISE = _CLEAN_PROMISE;
  function getOrCreateLViewCleanup(view) {
    return view[CLEANUP] || (view[CLEANUP] = ngDevMode ? new LCleanup() : []);
  }
  function getOrCreateTViewCleanup(tView) {
    return tView.cleanup || (tView.cleanup = ngDevMode ? new TCleanup() : []);
  }
  function loadComponentRenderer(currentDef, tNode, lView) {
    if (currentDef === null || isComponentDef(currentDef)) {
      lView = unwrapLView(lView[tNode.index]);
    }
    return lView[RENDERER];
  }
  function handleError(lView, error) {
    const injector = lView[INJECTOR];
    const errorHandler2 = injector ? injector.get(ErrorHandler, null) : null;
    errorHandler2 && errorHandler2.handleError(error);
  }
  function setInputsForProperty(tView, lView, inputs, publicName, value) {
    for (let i = 0; i < inputs.length;) {
      const index = inputs[i++];
      const privateName = inputs[i++];
      const instance = lView[index];
      ngDevMode && assertIndexInRange(lView, index);
      const def = tView.data[index];
      if (def.setInput !== null) {
        def.setInput(instance, value, publicName, privateName);
      } else {
        instance[privateName] = value;
      }
    }
  }
  function textBindingInternal(lView, index, value) {
    ngDevMode && assertString(value, 'Value should be a string');
    ngDevMode && assertNotSame(value, NO_CHANGE, 'value should not be NO_CHANGE');
    ngDevMode && assertIndexInRange(lView, index);
    const element = getNativeByIndex(index, lView);
    ngDevMode && assertDefined(element, 'native element should exist');
    updateTextNode(lView[RENDERER], element, value);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function computeStaticStyling(tNode, attrs, writeToHost) {
    ngDevMode &&
        assertFirstCreatePass(getTView(), 'Expecting to be called in first template pass only');
    let styles = writeToHost ? tNode.styles : null;
    let classes = writeToHost ? tNode.classes : null;
    let mode = 0;
    if (attrs !== null) {
      for (let i = 0; i < attrs.length; i++) {
        const value = attrs[i];
        if (typeof value === 'number') {
          mode = value;
        } else if (mode == 1) {
          classes = concatStringsWithSpace(classes, value);
        } else if (mode == 2) {
          const style = value;
          const styleValue = attrs[++i];
          styles = concatStringsWithSpace(styles, style + ': ' + styleValue + ';');
        }
      }
    }
    writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
    writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function detectChanges(component) {
    const view = getComponentViewByInstance(component);
    detectChangesInternal(view[TVIEW], view, component);
  }
  function markDirty(component) {
    ngDevMode && assertDefined(component, 'component');
    const rootView = markViewDirty(getComponentViewByInstance(component));
    ngDevMode && assertDefined(rootView[CONTEXT], 'rootContext should be defined');
    scheduleTick(rootView[CONTEXT], 1);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var INJECTOR$1 = new InjectionToken('INJECTOR', -1);
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NullInjector = class {
    get(token, notFoundValue = THROW_IF_NOT_FOUND) {
      if (notFoundValue === THROW_IF_NOT_FOUND) {
        const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
        error.name = 'NullInjectorError';
        throw error;
      }
      return notFoundValue;
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var INJECTOR_SCOPE = new InjectionToken('Set Injector scope.');
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NOT_YET = {};
  var CIRCULAR = {};
  var EMPTY_ARRAY$1 = [];
  var NULL_INJECTOR = void 0;
  function getNullInjector() {
    if (NULL_INJECTOR === void 0) {
      NULL_INJECTOR = new NullInjector();
    }
    return NULL_INJECTOR;
  }
  function createInjector(defType, parent = null, additionalProviders = null, name) {
    const injector =
        createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);
    injector._resolveInjectorDefTypes();
    return injector;
  }
  function createInjectorWithoutInjectorInstances(
      defType, parent = null, additionalProviders = null, name) {
    return new R3Injector(defType, additionalProviders, parent || getNullInjector(), name);
  }
  var R3Injector = class {
    constructor(def, additionalProviders, parent, source = null) {
      this.parent = parent;
      this.records = new Map();
      this.injectorDefTypes = new Set();
      this.onDestroy = new Set();
      this._destroyed = false;
      const dedupStack = [];
      additionalProviders &&
          deepForEach(
              additionalProviders,
              (provider) => this.processProvider(provider, def, additionalProviders));
      deepForEach([def], (injectorDef) => this.processInjectorType(injectorDef, [], dedupStack));
      this.records.set(INJECTOR$1, makeRecord(void 0, this));
      const record = this.records.get(INJECTOR_SCOPE);
      this.scope = record != null ? record.value : null;
      this.source = source || (typeof def === 'object' ? null : stringify(def));
    }
    get destroyed() {
      return this._destroyed;
    }
    destroy() {
      this.assertNotDestroyed();
      this._destroyed = true;
      try {
        this.onDestroy.forEach((service) => service.ngOnDestroy());
      } finally {
        this.records.clear();
        this.onDestroy.clear();
        this.injectorDefTypes.clear();
      }
    }
    get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
      this.assertNotDestroyed();
      const previousInjector = setCurrentInjector(this);
      try {
        if (!(flags & InjectFlags.SkipSelf)) {
          let record = this.records.get(token);
          if (record === void 0) {
            const def = couldBeInjectableType(token) && getInjectableDef(token);
            if (def && this.injectableDefInScope(def)) {
              record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
            } else {
              record = null;
            }
            this.records.set(token, record);
          }
          if (record != null) {
            return this.hydrate(token, record);
          }
        }
        const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();
        notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ?
            null :
            notFoundValue;
        return nextInjector.get(token, notFoundValue);
      } catch (e) {
        if (e.name === 'NullInjectorError') {
          const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
          path.unshift(stringify(token));
          if (previousInjector) {
            throw e;
          } else {
            return catchInjectorError(e, token, 'R3InjectorError', this.source);
          }
        } else {
          throw e;
        }
      } finally {
        setCurrentInjector(previousInjector);
      }
    }
    _resolveInjectorDefTypes() {
      this.injectorDefTypes.forEach((defType) => this.get(defType));
    }
    toString() {
      const tokens = [], records = this.records;
      records.forEach((v, token) => tokens.push(stringify(token)));
      return `R3Injector[${tokens.join(', ')}]`;
    }
    assertNotDestroyed() {
      if (this._destroyed) {
        throw new Error('Injector has already been destroyed.');
      }
    }
    processInjectorType(defOrWrappedDef, parents, dedupStack) {
      defOrWrappedDef = resolveForwardRef(defOrWrappedDef);
      if (!defOrWrappedDef) return false;
      let def = getInjectorDef(defOrWrappedDef);
      const ngModule = def == null && defOrWrappedDef.ngModule || void 0;
      const defType = ngModule === void 0 ? defOrWrappedDef : ngModule;
      if (ngDevMode && parents.indexOf(defType) !== -1) {
        const defName = stringify(defType);
        const path = parents.map(stringify);
        throwCyclicDependencyError(defName, path);
      }
      const isDuplicate = dedupStack.indexOf(defType) !== -1;
      if (ngModule !== void 0) {
        def = getInjectorDef(ngModule);
      }
      if (def == null) {
        return false;
      }
      if (def.imports != null && !isDuplicate) {
        ngDevMode && parents.push(defType);
        dedupStack.push(defType);
        let importTypesWithProviders;
        try {
          deepForEach(def.imports, (imported) => {
            if (this.processInjectorType(imported, parents, dedupStack)) {
              if (importTypesWithProviders === void 0) importTypesWithProviders = [];
              importTypesWithProviders.push(imported);
            }
          });
        } finally {
          ngDevMode && parents.pop();
        }
        if (importTypesWithProviders !== void 0) {
          for (let i = 0; i < importTypesWithProviders.length; i++) {
            const {ngModule: ngModule2, providers} = importTypesWithProviders[i];
            deepForEach(
                providers,
                (provider) =>
                    this.processProvider(provider, ngModule2, providers || EMPTY_ARRAY$1));
          }
        }
      }
      this.injectorDefTypes.add(defType);
      this.records.set(defType, makeRecord(def.factory, NOT_YET));
      const defProviders = def.providers;
      if (defProviders != null && !isDuplicate) {
        const injectorType = defOrWrappedDef;
        deepForEach(
            defProviders, (provider) => this.processProvider(provider, injectorType, defProviders));
      }
      return ngModule !== void 0 && defOrWrappedDef.providers !== void 0;
    }
    processProvider(provider, ngModuleType, providers) {
      provider = resolveForwardRef(provider);
      let token =
          isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
      const record = providerToRecord(provider, ngModuleType, providers);
      if (!isTypeProvider(provider) && provider.multi === true) {
        let multiRecord = this.records.get(token);
        if (multiRecord) {
          if (ngDevMode && multiRecord.multi === void 0) {
            throwMixedMultiProviderError();
          }
        } else {
          multiRecord = makeRecord(void 0, NOT_YET, true);
          multiRecord.factory = () => injectArgs(multiRecord.multi);
          this.records.set(token, multiRecord);
        }
        token = provider;
        multiRecord.multi.push(provider);
      } else {
        const existing = this.records.get(token);
        if (ngDevMode && existing && existing.multi !== void 0) {
          throwMixedMultiProviderError();
        }
      }
      this.records.set(token, record);
    }
    hydrate(token, record) {
      if (ngDevMode && record.value === CIRCULAR) {
        throwCyclicDependencyError(stringify(token));
      } else if (record.value === NOT_YET) {
        record.value = CIRCULAR;
        record.value = record.factory();
      }
      if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {
        this.onDestroy.add(record.value);
      }
      return record.value;
    }
    injectableDefInScope(def) {
      if (!def.providedIn) {
        return false;
      } else if (typeof def.providedIn === 'string') {
        return def.providedIn === 'any' || def.providedIn === this.scope;
      } else {
        return this.injectorDefTypes.has(def.providedIn);
      }
    }
  };
  function injectableDefOrInjectorDefFactory(token) {
    const injectableDef = getInjectableDef(token);
    const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
    if (factory !== null) {
      return factory;
    }
    const injectorDef = getInjectorDef(token);
    if (injectorDef !== null) {
      return injectorDef.factory;
    }
    if (token instanceof InjectionToken) {
      throw new Error(`Token ${stringify(token)} is missing a \u0275prov definition.`);
    }
    if (token instanceof Function) {
      return getUndecoratedInjectableFactory(token);
    }
    throw new Error('unreachable');
  }
  function getUndecoratedInjectableFactory(token) {
    const paramLength = token.length;
    if (paramLength > 0) {
      const args = newArray(paramLength, '?');
      throw new Error(
          `Can't resolve all parameters for ${stringify(token)}: (${args.join(', ')}).`);
    }
    const inheritedInjectableDef = getInheritedInjectableDef(token);
    if (inheritedInjectableDef !== null) {
      return () => inheritedInjectableDef.factory(token);
    } else {
      return () => new token();
    }
  }
  function providerToRecord(provider, ngModuleType, providers) {
    if (isValueProvider(provider)) {
      return makeRecord(void 0, provider.useValue);
    } else {
      const factory = providerToFactory(provider, ngModuleType, providers);
      return makeRecord(factory, NOT_YET);
    }
  }
  function providerToFactory(provider, ngModuleType, providers) {
    let factory = void 0;
    if (isTypeProvider(provider)) {
      const unwrappedProvider = resolveForwardRef(provider);
      return getFactoryDef(unwrappedProvider) ||
          injectableDefOrInjectorDefFactory(unwrappedProvider);
    } else {
      if (isValueProvider(provider)) {
        factory = () => resolveForwardRef(provider.useValue);
      } else if (isFactoryProvider(provider)) {
        factory = () => provider.useFactory(...injectArgs(provider.deps || []));
      } else if (isExistingProvider(provider)) {
        factory = () => \u0275\u0275inject(resolveForwardRef(provider.useExisting));
      } else {
        const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
        if (ngDevMode && !classRef) {
          throwInvalidProviderError(ngModuleType, providers, provider);
        }
        if (hasDeps(provider)) {
          factory = () => new classRef(...injectArgs(provider.deps));
        } else {
          return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
        }
      }
    }
    return factory;
  }
  function makeRecord(factory, value, multi = false) {
    return {factory, value, multi: multi ? [] : void 0};
  }
  function isValueProvider(value) {
    return value !== null && typeof value == 'object' && USE_VALUE in value;
  }
  function isExistingProvider(value) {
    return !!(value && value.useExisting);
  }
  function isFactoryProvider(value) {
    return !!(value && value.useFactory);
  }
  function isTypeProvider(value) {
    return typeof value === 'function';
  }
  function isClassProvider(value) {
    return !!value.useClass;
  }
  function hasDeps(value) {
    return !!value.deps;
  }
  function hasOnDestroy(value) {
    return value !== null && typeof value === 'object' && typeof value.ngOnDestroy === 'function';
  }
  function couldBeInjectableType(value) {
    return typeof value === 'function' ||
        typeof value === 'object' && value instanceof InjectionToken;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function INJECTOR_IMPL__POST_R3__(providers, parent, name) {
    return createInjector({name}, parent, providers, name);
  }
  var INJECTOR_IMPL = INJECTOR_IMPL__POST_R3__;
  var Injector = class {
    static create(options, parent) {
      if (Array.isArray(options)) {
        return INJECTOR_IMPL(options, parent, '');
      } else {
        return INJECTOR_IMPL(options.providers, options.parent, options.name || '');
      }
    }
  };
  Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
  Injector.NULL = new NullInjector();
  Injector.\u0275prov = \u0275\u0275defineInjectable(
      {token: Injector, providedIn: 'any', factory: () => \u0275\u0275inject(INJECTOR$1)});
  Injector.__NG_ELEMENT_ID__ = -1;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function getComponent(element) {
    assertDomElement(element);
    const context = loadLContext(element, false);
    if (context === null) return null;
    if (context.component === void 0) {
      context.component = getComponentAtNodeIndex(context.nodeIndex, context.lView);
    }
    return context.component;
  }
  function getContext(element) {
    assertDomElement(element);
    const context = loadLContext(element, false);
    return context === null ? null : context.lView[CONTEXT];
  }
  function getOwningComponent(elementOrDir) {
    const context = loadLContext(elementOrDir, false);
    if (context === null) return null;
    let lView = context.lView;
    let parent;
    ngDevMode && assertLView(lView);
    while (lView[TVIEW].type === 2 && (parent = getLViewParent(lView))) {
      lView = parent;
    }
    return lView[FLAGS] & 512 ? null : lView[CONTEXT];
  }
  function getRootComponents(elementOrDir) {
    return [...getRootContext(elementOrDir).components];
  }
  function getInjector(elementOrDir) {
    const context = loadLContext(elementOrDir, false);
    if (context === null) return Injector.NULL;
    const tNode = context.lView[TVIEW].data[context.nodeIndex];
    return new NodeInjector(tNode, context.lView);
  }
  function getDirectives(element) {
    const context = loadLContext(element);
    if (context.directives === void 0) {
      context.directives = getDirectivesAtNodeIndex(context.nodeIndex, context.lView, false);
    }
    return context.directives === null ? [] : [...context.directives];
  }
  function loadLContext(target, throwOnNotFound = true) {
    const context = getLContext(target);
    if (!context && throwOnNotFound) {
      throw new Error(
          ngDevMode ? `Unable to find context associated with ${stringifyForError(target)}` :
                      'Invalid ng target');
    }
    return context;
  }
  function getHostElement(componentOrDirective) {
    return getLContext(componentOrDirective).native;
  }
  function getListeners(element) {
    assertDomElement(element);
    const lContext = loadLContext(element, false);
    if (lContext === null) return [];
    const lView = lContext.lView;
    const tView = lView[TVIEW];
    const lCleanup = lView[CLEANUP];
    const tCleanup = tView.cleanup;
    const listeners = [];
    if (tCleanup && lCleanup) {
      for (let i = 0; i < tCleanup.length;) {
        const firstParam = tCleanup[i++];
        const secondParam = tCleanup[i++];
        if (typeof firstParam === 'string') {
          const name = firstParam;
          const listenerElement = unwrapRNode(lView[secondParam]);
          const callback = lCleanup[tCleanup[i++]];
          const useCaptureOrIndx = tCleanup[i++];
          const type =
              typeof useCaptureOrIndx === 'boolean' || useCaptureOrIndx >= 0 ? 'dom' : 'output';
          const useCapture = typeof useCaptureOrIndx === 'boolean' ? useCaptureOrIndx : false;
          if (element == listenerElement) {
            listeners.push({element, name, callback, useCapture, type});
          }
        }
      }
    }
    listeners.sort(sortListeners);
    return listeners;
  }
  function sortListeners(a, b) {
    if (a.name == b.name) return 0;
    return a.name < b.name ? -1 : 1;
  }
  function assertDomElement(value) {
    if (typeof Element !== 'undefined' && !(value instanceof Element)) {
      throw new Error('Expecting instance of DOM Element');
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function applyChanges(component) {
    markDirty(component);
    getRootComponents(component).forEach((rootComponent) => detectChanges(rootComponent));
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var GLOBAL_PUBLISH_EXPANDO_KEY = 'ng';
  var _published = false;
  function publishDefaultGlobalUtils() {
    if (!_published) {
      _published = true;
      publishGlobalUtil('getComponent', getComponent);
      publishGlobalUtil('getContext', getContext);
      publishGlobalUtil('getListeners', getListeners);
      publishGlobalUtil('getOwningComponent', getOwningComponent);
      publishGlobalUtil('getHostElement', getHostElement);
      publishGlobalUtil('getInjector', getInjector);
      publishGlobalUtil('getRootComponents', getRootComponents);
      publishGlobalUtil('getDirectives', getDirectives);
      publishGlobalUtil('applyChanges', applyChanges);
    }
  }
  function publishGlobalUtil(name, fn) {
    if (typeof COMPILED === 'undefined' || !COMPILED) {
      const w = _global;
      ngDevMode && assertDefined(fn, 'function not defined');
      if (w) {
        let container = w[GLOBAL_PUBLISH_EXPANDO_KEY];
        if (!container) {
          container = w[GLOBAL_PUBLISH_EXPANDO_KEY] = {};
        }
        container[name] = fn;
      }
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function createRootComponentView(rNode, def, rootView, rendererFactory, hostRenderer, sanitizer) {
    const tView = rootView[TVIEW];
    const index = HEADER_OFFSET;
    ngDevMode && assertIndexInRange(rootView, index);
    rootView[index] = rNode;
    const tNode = getOrCreateTNode(tView, index, 2, '#host', null);
    const mergedAttrs = tNode.mergedAttrs = def.hostAttrs;
    if (mergedAttrs !== null) {
      computeStaticStyling(tNode, mergedAttrs, true);
      if (rNode !== null) {
        setUpAttributes(hostRenderer, rNode, mergedAttrs);
        if (tNode.classes !== null) {
          writeDirectClass(hostRenderer, rNode, tNode.classes);
        }
        if (tNode.styles !== null) {
          writeDirectStyle(hostRenderer, rNode, tNode.styles);
        }
      }
    }
    const viewRenderer = rendererFactory.createRenderer(rNode, def);
    const componentView = createLView(
        rootView, getOrCreateTComponentView(def), null, def.onPush ? 64 : 16, rootView[index],
        tNode, rendererFactory, viewRenderer, sanitizer || null, null);
    if (tView.firstCreatePass) {
      diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type);
      markAsComponentHost(tView, tNode);
      initTNodeFlags(tNode, rootView.length, 1);
    }
    addToViewTree(rootView, componentView);
    return rootView[index] = componentView;
  }
  function createRootComponent(componentView, componentDef, rootLView, rootContext, hostFeatures) {
    const tView = rootLView[TVIEW];
    const component = instantiateRootComponent(tView, rootLView, componentDef);
    rootContext.components.push(component);
    componentView[CONTEXT] = component;
    hostFeatures && hostFeatures.forEach((feature) => feature(component, componentDef));
    if (componentDef.contentQueries) {
      const tNode = getCurrentTNode();
      ngDevMode && assertDefined(tNode, 'TNode expected');
      componentDef.contentQueries(1, component, tNode.directiveStart);
    }
    const rootTNode = getCurrentTNode();
    ngDevMode && assertDefined(rootTNode, 'tNode should have been already created');
    if (tView.firstCreatePass &&
        (componentDef.hostBindings !== null || componentDef.hostAttrs !== null)) {
      setSelectedIndex(rootTNode.index);
      const rootTView = rootLView[TVIEW];
      registerHostBindingOpCodes(
          rootTView, rootTNode, rootLView, rootTNode.directiveStart, rootTNode.directiveEnd,
          componentDef);
      invokeHostBindingsInCreationMode(componentDef, component);
    }
    return component;
  }
  function createRootContext(scheduler, playerHandler) {
    return {
      components: [],
      scheduler: scheduler || defaultScheduler,
      clean: CLEAN_PROMISE,
      playerHandler: playerHandler || null,
      flags: 0
    };
  }
  function LifecycleHooksFeature(component, def) {
    const lView = readPatchedLView(component);
    ngDevMode && assertDefined(lView, 'LView is required');
    const tView = lView[TVIEW];
    const tNode = getCurrentTNode();
    ngDevMode && assertDefined(tNode, 'TNode is required');
    registerPostOrderHooks(tView, tNode);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function getSuperType(type) {
    return Object.getPrototypeOf(type.prototype).constructor;
  }
  function \u0275\u0275InheritDefinitionFeature(definition) {
    let superType = getSuperType(definition.type);
    let shouldInheritFields = true;
    const inheritanceChain = [definition];
    while (superType) {
      let superDef = void 0;
      if (isComponentDef(definition)) {
        superDef = superType.\u0275cmp || superType.\u0275dir;
      } else {
        if (superType.\u0275cmp) {
          throw new Error('Directives cannot inherit Components');
        }
        superDef = superType.\u0275dir;
      }
      if (superDef) {
        if (shouldInheritFields) {
          inheritanceChain.push(superDef);
          const writeableDef = definition;
          writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
          writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
          writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
          const superHostBindings = superDef.hostBindings;
          superHostBindings && inheritHostBindings(definition, superHostBindings);
          const superViewQuery = superDef.viewQuery;
          const superContentQueries = superDef.contentQueries;
          superViewQuery && inheritViewQuery(definition, superViewQuery);
          superContentQueries && inheritContentQueries(definition, superContentQueries);
          fillProperties(definition.inputs, superDef.inputs);
          fillProperties(definition.declaredInputs, superDef.declaredInputs);
          fillProperties(definition.outputs, superDef.outputs);
          if (isComponentDef(superDef) && superDef.data.animation) {
            const defData = definition.data;
            defData.animation = (defData.animation || []).concat(superDef.data.animation);
          }
        }
        const features = superDef.features;
        if (features) {
          for (let i = 0; i < features.length; i++) {
            const feature = features[i];
            if (feature && feature.ngInherit) {
              feature(definition);
            }
            if (feature === \u0275\u0275InheritDefinitionFeature) {
              shouldInheritFields = false;
            }
          }
        }
      }
      superType = Object.getPrototypeOf(superType);
    }
    mergeHostAttrsAcrossInheritance(inheritanceChain);
  }
  function mergeHostAttrsAcrossInheritance(inheritanceChain) {
    let hostVars = 0;
    let hostAttrs = null;
    for (let i = inheritanceChain.length - 1; i >= 0; i--) {
      const def = inheritanceChain[i];
      def.hostVars = hostVars += def.hostVars;
      def.hostAttrs =
          mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
    }
  }
  function maybeUnwrapEmpty(value) {
    if (value === EMPTY_OBJ) {
      return {};
    } else if (value === EMPTY_ARRAY) {
      return [];
    } else {
      return value;
    }
  }
  function inheritViewQuery(definition, superViewQuery) {
    const prevViewQuery = definition.viewQuery;
    if (prevViewQuery) {
      definition.viewQuery = (rf, ctx) => {
        superViewQuery(rf, ctx);
        prevViewQuery(rf, ctx);
      };
    } else {
      definition.viewQuery = superViewQuery;
    }
  }
  function inheritContentQueries(definition, superContentQueries) {
    const prevContentQueries = definition.contentQueries;
    if (prevContentQueries) {
      definition.contentQueries = (rf, ctx, directiveIndex) => {
        superContentQueries(rf, ctx, directiveIndex);
        prevContentQueries(rf, ctx, directiveIndex);
      };
    } else {
      definition.contentQueries = superContentQueries;
    }
  }
  function inheritHostBindings(definition, superHostBindings) {
    const prevHostBindings = definition.hostBindings;
    if (prevHostBindings) {
      definition.hostBindings = (rf, ctx) => {
        superHostBindings(rf, ctx);
        prevHostBindings(rf, ctx);
      };
    } else {
      definition.hostBindings = superHostBindings;
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var COPY_DIRECTIVE_FIELDS = ['providersResolver'];
  var COPY_COMPONENT_FIELDS = [
    'template', 'decls', 'consts', 'vars', 'onPush', 'ngContentSelectors', 'styles',
    'encapsulation', 'schemas'
  ];
  function \u0275\u0275CopyDefinitionFeature(definition) {
    let superType = getSuperType(definition.type);
    let superDef = void 0;
    if (isComponentDef(definition)) {
      superDef = superType.\u0275cmp;
    } else {
      superDef = superType.\u0275dir;
    }
    const defAny = definition;
    for (const field of COPY_DIRECTIVE_FIELDS) {
      defAny[field] = superDef[field];
    }
    if (isComponentDef(superDef)) {
      for (const field of COPY_COMPONENT_FIELDS) {
        defAny[field] = superDef[field];
      }
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var _symbolIterator = null;
  function getSymbolIterator2() {
    if (!_symbolIterator) {
      const Symbol2 = _global['Symbol'];
      if (Symbol2 && Symbol2.iterator) {
        _symbolIterator = Symbol2.iterator;
      } else {
        const keys = Object.getOwnPropertyNames(Map.prototype);
        for (let i = 0; i < keys.length; ++i) {
          const key = keys[i];
          if (key !== 'entries' && key !== 'size' &&
              Map.prototype[key] === Map.prototype['entries']) {
            _symbolIterator = key;
          }
        }
      }
    }
    return _symbolIterator;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function devModeEqual(a, b) {
    const isListLikeIterableA = isListLikeIterable(a);
    const isListLikeIterableB = isListLikeIterable(b);
    if (isListLikeIterableA && isListLikeIterableB) {
      return areIterablesEqual(a, b, devModeEqual);
    } else {
      const isAObject = a && (typeof a === 'object' || typeof a === 'function');
      const isBObject = b && (typeof b === 'object' || typeof b === 'function');
      if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
        return true;
      } else {
        return Object.is(a, b);
      }
    }
  }
  var WrappedValue = class {
    constructor(value) {
      this.wrapped = value;
    }
    static wrap(value) {
      return new WrappedValue(value);
    }
    static unwrap(value) {
      return WrappedValue.isWrapped(value) ? value.wrapped : value;
    }
    static isWrapped(value) {
      return value instanceof WrappedValue;
    }
  };
  function isListLikeIterable(obj) {
    if (!isJsObject(obj)) return false;
    return Array.isArray(obj) || !(obj instanceof Map) && getSymbolIterator2() in obj;
  }
  function areIterablesEqual(a, b, comparator) {
    const iterator1 = a[getSymbolIterator2()]();
    const iterator2 = b[getSymbolIterator2()]();
    while (true) {
      const item1 = iterator1.next();
      const item2 = iterator2.next();
      if (item1.done && item2.done) return true;
      if (item1.done || item2.done) return false;
      if (!comparator(item1.value, item2.value)) return false;
    }
  }
  function iterateListLike(obj, fn) {
    if (Array.isArray(obj)) {
      for (let i = 0; i < obj.length; i++) {
        fn(obj[i]);
      }
    } else {
      const iterator2 = obj[getSymbolIterator2()]();
      let item;
      while (!(item = iterator2.next()).done) {
        fn(item.value);
      }
    }
  }
  function isJsObject(o) {
    return o !== null && (typeof o === 'function' || typeof o === 'object');
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function updateBinding(lView, bindingIndex, value) {
    return lView[bindingIndex] = value;
  }
  function getBinding(lView, bindingIndex) {
    ngDevMode && assertIndexInRange(lView, bindingIndex);
    ngDevMode &&
        assertNotSame(lView[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');
    return lView[bindingIndex];
  }
  function bindingUpdated(lView, bindingIndex, value) {
    ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');
    ngDevMode &&
        assertLessThan(
            bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);
    const oldValue = lView[bindingIndex];
    if (Object.is(oldValue, value)) {
      return false;
    } else {
      if (ngDevMode && isInCheckNoChangesMode()) {
        const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : void 0;
        if (!devModeEqual(oldValueToCompare, value)) {
          const details =
              getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);
          throwErrorIfNoChangesMode(
              oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName);
        }
        return false;
      }
      lView[bindingIndex] = value;
      return true;
    }
  }
  function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
    const different = bindingUpdated(lView, bindingIndex, exp1);
    return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
  }
  function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
    const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
    return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
  }
  function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
    const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
    return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275attribute(name, value, sanitizer, namespace) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, 'attr.' + name, bindingIndex);
    }
    return \u0275\u0275attribute;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function interpolationV(lView, values) {
    ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');
    ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');
    let isBindingUpdated = false;
    let bindingIndex = getBindingIndex();
    for (let i = 1; i < values.length; i += 2) {
      isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;
    }
    setBindingIndex(bindingIndex);
    if (!isBindingUpdated) {
      return NO_CHANGE;
    }
    let content = values[0];
    for (let i = 1; i < values.length; i += 2) {
      content += renderStringify(values[i]) + values[i + 1];
    }
    return content;
  }
  function interpolation1(lView, prefix, v0, suffix) {
    const different = bindingUpdated(lView, nextBindingIndex(), v0);
    return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
  }
  function interpolation2(lView, prefix, v0, i011, v1, suffix) {
    const bindingIndex = getBindingIndex();
    const different = bindingUpdated2(lView, bindingIndex, v0, v1);
    incrementBindingIndex(2);
    return different ? prefix + renderStringify(v0) + i011 + renderStringify(v1) + suffix :
                       NO_CHANGE;
  }
  function interpolation3(lView, prefix, v0, i011, v1, i19, v2, suffix) {
    const bindingIndex = getBindingIndex();
    const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
    incrementBindingIndex(3);
    return different ? prefix + renderStringify(v0) + i011 + renderStringify(v1) + i19 +
            renderStringify(v2) + suffix :
                       NO_CHANGE;
  }
  function interpolation4(lView, prefix, v0, i011, v1, i19, v2, i26, v3, suffix) {
    const bindingIndex = getBindingIndex();
    const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    incrementBindingIndex(4);
    return different ? prefix + renderStringify(v0) + i011 + renderStringify(v1) + i19 +
            renderStringify(v2) + i26 + renderStringify(v3) + suffix :
                       NO_CHANGE;
  }
  function interpolation5(lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
    incrementBindingIndex(5);
    return different ? prefix + renderStringify(v0) + i011 + renderStringify(v1) + i19 +
            renderStringify(v2) + i26 + renderStringify(v3) + i34 + renderStringify(v4) + suffix :
                       NO_CHANGE;
  }
  function interpolation6(lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
    incrementBindingIndex(6);
    return different ? prefix + renderStringify(v0) + i011 + renderStringify(v1) + i19 +
            renderStringify(v2) + i26 + renderStringify(v3) + i34 + renderStringify(v4) + i43 +
            renderStringify(v5) + suffix :
                       NO_CHANGE;
  }
  function interpolation7(
      lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
    incrementBindingIndex(7);
    return different ? prefix + renderStringify(v0) + i011 + renderStringify(v1) + i19 +
            renderStringify(v2) + i26 + renderStringify(v3) + i34 + renderStringify(v4) + i43 +
            renderStringify(v5) + i52 + renderStringify(v6) + suffix :
                       NO_CHANGE;
  }
  function interpolation8(
      lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, i62, v7, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
    incrementBindingIndex(8);
    return different ? prefix + renderStringify(v0) + i011 + renderStringify(v1) + i19 +
            renderStringify(v2) + i26 + renderStringify(v3) + i34 + renderStringify(v4) + i43 +
            renderStringify(v5) + i52 + renderStringify(v6) + i62 + renderStringify(v7) + suffix :
                       NO_CHANGE;
  }
  function \u0275\u0275attributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode &&
          storePropertyBindingMetadata(
              getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 1, prefix, suffix);
    }
    return \u0275\u0275attributeInterpolate1;
  }
  function \u0275\u0275attributeInterpolate2(
      attrName, prefix, v0, i011, v1, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i011, v1, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode &&
          storePropertyBindingMetadata(
              getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 2, prefix, i011,
              suffix);
    }
    return \u0275\u0275attributeInterpolate2;
  }
  function \u0275\u0275attributeInterpolate3(
      attrName, prefix, v0, i011, v1, i19, v2, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i011, v1, i19, v2, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode &&
          storePropertyBindingMetadata(
              getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 3, prefix, i011, i19,
              suffix);
    }
    return \u0275\u0275attributeInterpolate3;
  }
  function \u0275\u0275attributeInterpolate4(
      attrName, prefix, v0, i011, v1, i19, v2, i26, v3, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i011, v1, i19, v2, i26, v3, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode &&
          storePropertyBindingMetadata(
              getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 4, prefix, i011, i19,
              i26, suffix);
    }
    return \u0275\u0275attributeInterpolate4;
  }
  function \u0275\u0275attributeInterpolate5(
      attrName, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue =
        interpolation5(lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode &&
          storePropertyBindingMetadata(
              getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 5, prefix, i011, i19,
              i26, i34, suffix);
    }
    return \u0275\u0275attributeInterpolate5;
  }
  function \u0275\u0275attributeInterpolate6(
      attrName, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, suffix, sanitizer,
      namespace) {
    const lView = getLView();
    const interpolatedValue =
        interpolation6(lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode &&
          storePropertyBindingMetadata(
              getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 6, prefix, i011, i19,
              i26, i34, i43, suffix);
    }
    return \u0275\u0275attributeInterpolate6;
  }
  function \u0275\u0275attributeInterpolate7(
      attrName, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, suffix,
      sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation7(
        lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode &&
          storePropertyBindingMetadata(
              getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 7, prefix, i011, i19,
              i26, i34, i43, i52, suffix);
    }
    return \u0275\u0275attributeInterpolate7;
  }
  function \u0275\u0275attributeInterpolate8(
      attrName, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, i62, v7, suffix,
      sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation8(
        lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, i62, v7, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode &&
          storePropertyBindingMetadata(
              getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 8, prefix, i011, i19,
              i26, i34, i43, i52, i62, suffix);
    }
    return \u0275\u0275attributeInterpolate8;
  }
  function \u0275\u0275attributeInterpolateV(attrName, values, sanitizer, namespace) {
    const lView = getLView();
    const interpolated = interpolationV(lView, values);
    if (interpolated !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);
      if (ngDevMode) {
        const interpolationInBetween = [values[0]];
        for (let i = 2; i < values.length; i += 2) {
          interpolationInBetween.push(values[i]);
        }
        storePropertyBindingMetadata(
            getTView().data, tNode, 'attr.' + attrName,
            getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
      }
    }
    return \u0275\u0275attributeInterpolateV;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function templateFirstCreatePass(
      index, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) {
    ngDevMode && assertFirstCreatePass(tView);
    ngDevMode && ngDevMode.firstCreatePass++;
    const tViewConsts = tView.consts;
    const tNode =
        getOrCreateTNode(tView, index, 4, tagName || null, getConstant(tViewConsts, attrsIndex));
    resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
    registerPostOrderHooks(tView, tNode);
    const embeddedTView = tNode.tViews = createTView(
        2, tNode, templateFn, decls, vars, tView.directiveRegistry, tView.pipeRegistry, null,
        tView.schemas, tViewConsts);
    if (tView.queries !== null) {
      tView.queries.template(tView, tNode);
      embeddedTView.queries = tView.queries.embeddedTView(tNode);
    }
    return tNode;
  }
  function \u0275\u0275template(
      index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = index + HEADER_OFFSET;
    const tNode = tView.firstCreatePass ? templateFirstCreatePass(
                                              adjustedIndex, tView, lView, templateFn, decls, vars,
                                              tagName, attrsIndex, localRefsIndex) :
                                          tView.data[adjustedIndex];
    setCurrentTNode(tNode, false);
    const comment = lView[RENDERER].createComment(ngDevMode ? 'container' : '');
    appendChild(tView, lView, comment, tNode);
    attachPatchData(comment, lView);
    addToViewTree(lView, lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode));
    if (isDirectiveHost(tNode)) {
      createDirectivesInstances(tView, lView, tNode);
    }
    if (localRefsIndex != null) {
      saveResolvedLocalsInData(lView, tNode, localRefExtractor);
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function store(tView, lView, index, value) {
    if (index >= tView.data.length) {
      tView.data[index] = null;
      tView.blueprint[index] = null;
    }
    lView[index] = value;
  }
  function \u0275\u0275reference(index) {
    const contextLView = getContextLView();
    return load(contextLView, HEADER_OFFSET + index);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var angularCoreDiEnv = {
    \u0275\u0275defineInjectable,
    \u0275\u0275defineInjector,
    \u0275\u0275inject,
    \u0275\u0275getFactoryOf: getFactoryOf,
    \u0275\u0275invalidFactoryDep
  };
  function getFactoryOf(type) {
    const typeAny = type;
    if (isForwardRef(type)) {
      return () => {
        const factory = getFactoryOf(resolveForwardRef(typeAny));
        return factory ? factory() : null;
      };
    }
    const def = getInjectableDef(typeAny) || getInjectorDef(typeAny);
    if (!def || def.factory === void 0) {
      return null;
    }
    return def.factory;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function compileInjectable(type, srcMeta) {
    let ngInjectableDef = null;
    let ngFactoryDef = null;
    if (!type.hasOwnProperty(NG_PROV_DEF)) {
      Object.defineProperty(type, NG_PROV_DEF, {
        get: () => {
          if (ngInjectableDef === null) {
            ngInjectableDef = getCompilerFacade().compileInjectable(
                angularCoreDiEnv, `ng:///${type.name}/\u0275prov.js`,
                getInjectableMetadata(type, srcMeta));
          }
          return ngInjectableDef;
        }
      });
    }
    if (!type.hasOwnProperty(NG_FACTORY_DEF)) {
      Object.defineProperty(type, NG_FACTORY_DEF, {
        get: () => {
          if (ngFactoryDef === null) {
            const metadata = getInjectableMetadata(type, srcMeta);
            const compiler = getCompilerFacade();
            ngFactoryDef =
                compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/\u0275fac.js`, {
                  name: metadata.name,
                  type: metadata.type,
                  typeArgumentCount: metadata.typeArgumentCount,
                  deps: reflectDependencies(type),
                  injectFn: 'inject',
                  target: compiler.R3FactoryTarget.Injectable
                });
          }
          return ngFactoryDef;
        },
        configurable: true
      });
    }
  }
  var \u02750$8 = getClosureSafeProperty;
  var USE_VALUE$1 = getClosureSafeProperty({provide: String, useValue: \u02750$8});
  function isUseClassProvider(meta) {
    return meta.useClass !== void 0;
  }
  function isUseValueProvider(meta) {
    return USE_VALUE$1 in meta;
  }
  function isUseFactoryProvider(meta) {
    return meta.useFactory !== void 0;
  }
  function isUseExistingProvider(meta) {
    return meta.useExisting !== void 0;
  }
  function getInjectableMetadata(type, srcMeta) {
    const meta = srcMeta || {providedIn: null};
    const compilerMeta = {
      name: type.name,
      type,
      typeArgumentCount: 0,
      providedIn: meta.providedIn,
      userDeps: void 0
    };
    if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== void 0) {
      compilerMeta.userDeps = convertDependencies(meta.deps);
    }
    if (isUseClassProvider(meta)) {
      compilerMeta.useClass = resolveForwardRef(meta.useClass);
    } else if (isUseValueProvider(meta)) {
      compilerMeta.useValue = resolveForwardRef(meta.useValue);
    } else if (isUseFactoryProvider(meta)) {
      compilerMeta.useFactory = meta.useFactory;
    } else if (isUseExistingProvider(meta)) {
      compilerMeta.useExisting = resolveForwardRef(meta.useExisting);
    }
    return compilerMeta;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var \u02750$9 = getClosureSafeProperty;
  var USE_VALUE$2 = getClosureSafeProperty({provide: String, useValue: \u02750$9});
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var \u02750$a = (type, meta) => SWITCH_COMPILE_INJECTABLE(type, meta);
  var Injectable = makeDecorator('Injectable', void 0, void 0, void 0, \u02750$a);
  var SWITCH_COMPILE_INJECTABLE__POST_R3__ = compileInjectable;
  var SWITCH_COMPILE_INJECTABLE = SWITCH_COMPILE_INJECTABLE__POST_R3__;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function findFirstClosedCycle(keys) {
    const res = [];
    for (let i = 0; i < keys.length; ++i) {
      if (res.indexOf(keys[i]) > -1) {
        res.push(keys[i]);
        return res;
      }
      res.push(keys[i]);
    }
    return res;
  }
  function constructResolvingPath(keys) {
    if (keys.length > 1) {
      const reversed = findFirstClosedCycle(keys.slice().reverse());
      const tokenStrs = reversed.map((k) => stringify(k.token));
      return ' (' + tokenStrs.join(' -> ') + ')';
    }
    return '';
  }
  function injectionError(injector, key, constructResolvingMessage, originalError) {
    const keys = [key];
    const errMsg = constructResolvingMessage(keys);
    const error = originalError ? wrappedError(errMsg, originalError) : Error(errMsg);
    error.addKey = addKey;
    error.keys = keys;
    error.injectors = [injector];
    error.constructResolvingMessage = constructResolvingMessage;
    error[ERROR_ORIGINAL_ERROR] = originalError;
    return error;
  }
  function addKey(injector, key) {
    this.injectors.push(injector);
    this.keys.push(key);
    this.message = this.constructResolvingMessage(this.keys);
  }
  function noProviderError(injector, key) {
    return injectionError(injector, key, function(keys) {
      const first2 = stringify(keys[0].token);
      return `No provider for ${first2}!${constructResolvingPath(keys)}`;
    });
  }
  function cyclicDependencyError(injector, key) {
    return injectionError(injector, key, function(keys) {
      return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`;
    });
  }
  function instantiationError(injector, originalException, originalStack, key) {
    return injectionError(injector, key, function(keys) {
      const first2 = stringify(keys[0].token);
      return `${originalException.message}: Error during instantiation of ${first2}!${
          constructResolvingPath(keys)}.`;
    }, originalException);
  }
  function invalidProviderError(provider) {
    return Error(
        `Invalid provider - only instances of Provider and Type are allowed, got: ${provider}`);
  }
  function noAnnotationError(typeOrFunc, params) {
    const signature = [];
    for (let i = 0, ii = params.length; i < ii; i++) {
      const parameter = params[i];
      if (!parameter || parameter.length == 0) {
        signature.push('?');
      } else {
        signature.push(parameter.map(stringify).join(' '));
      }
    }
    return Error(
        'Cannot resolve all parameters for \'' + stringify(typeOrFunc) + '\'(' +
        signature.join(', ') +
        '). Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' +
        stringify(typeOrFunc) + '\' is decorated with Injectable.');
  }
  function outOfBoundsError(index) {
    return Error(`Index ${index} is out-of-bounds.`);
  }
  function mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
    return Error(
        `Cannot mix multi providers and regular providers, got: ${provider1} ${provider2}`);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ReflectiveKey = class {
    constructor(token, id) {
      this.token = token;
      this.id = id;
      if (!token) {
        throw new Error('Token must be defined!');
      }
      this.displayName = stringify(this.token);
    }
    static get(token) {
      return _globalKeyRegistry.get(resolveForwardRef(token));
    }
    static get numberOfKeys() {
      return _globalKeyRegistry.numberOfKeys;
    }
  };
  var KeyRegistry = class {
    constructor() {
      this._allKeys = new Map();
    }
    get(token) {
      if (token instanceof ReflectiveKey) return token;
      if (this._allKeys.has(token)) {
        return this._allKeys.get(token);
      }
      const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
      this._allKeys.set(token, newKey);
      return newKey;
    }
    get numberOfKeys() {
      return this._allKeys.size;
    }
  };
  var _globalKeyRegistry = new KeyRegistry();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var Reflector = class {
    constructor(reflectionCapabilities) {
      this.reflectionCapabilities = reflectionCapabilities;
    }
    updateCapabilities(caps) {
      this.reflectionCapabilities = caps;
    }
    factory(type) {
      return this.reflectionCapabilities.factory(type);
    }
    parameters(typeOrFunc) {
      return this.reflectionCapabilities.parameters(typeOrFunc);
    }
    annotations(typeOrFunc) {
      return this.reflectionCapabilities.annotations(typeOrFunc);
    }
    propMetadata(typeOrFunc) {
      return this.reflectionCapabilities.propMetadata(typeOrFunc);
    }
    hasLifecycleHook(type, lcProperty) {
      return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);
    }
    getter(name) {
      return this.reflectionCapabilities.getter(name);
    }
    setter(name) {
      return this.reflectionCapabilities.setter(name);
    }
    method(name) {
      return this.reflectionCapabilities.method(name);
    }
    importUri(type) {
      return this.reflectionCapabilities.importUri(type);
    }
    resourceUri(type) {
      return this.reflectionCapabilities.resourceUri(type);
    }
    resolveIdentifier(name, moduleUrl, members, runtime) {
      return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime);
    }
    resolveEnum(identifier, name) {
      return this.reflectionCapabilities.resolveEnum(identifier, name);
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var reflector = new Reflector(new ReflectionCapabilities());
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ReflectiveDependency = class {
    constructor(key, optional, visibility) {
      this.key = key;
      this.optional = optional;
      this.visibility = visibility;
    }
    static fromKey(key) {
      return new ReflectiveDependency(key, false, null);
    }
  };
  var _EMPTY_LIST = [];
  var ResolvedReflectiveProvider_ = class {
    constructor(key, resolvedFactories, multiProvider) {
      this.key = key;
      this.resolvedFactories = resolvedFactories;
      this.multiProvider = multiProvider;
      this.resolvedFactory = this.resolvedFactories[0];
    }
  };
  var ResolvedReflectiveFactory = class {
    constructor(factory, dependencies) {
      this.factory = factory;
      this.dependencies = dependencies;
    }
  };
  function resolveReflectiveFactory(provider) {
    let factoryFn;
    let resolvedDeps;
    if (provider.useClass) {
      const useClass = resolveForwardRef(provider.useClass);
      factoryFn = reflector.factory(useClass);
      resolvedDeps = _dependenciesFor(useClass);
    } else if (provider.useExisting) {
      factoryFn = (aliasInstance) => aliasInstance;
      resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
    } else if (provider.useFactory) {
      factoryFn = provider.useFactory;
      resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
    } else {
      factoryFn = () => provider.useValue;
      resolvedDeps = _EMPTY_LIST;
    }
    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
  }
  function resolveReflectiveProvider(provider) {
    return new ResolvedReflectiveProvider_(
        ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)],
        provider.multi || false);
  }
  function resolveReflectiveProviders(providers) {
    const normalized = _normalizeProviders(providers, []);
    const resolved = normalized.map(resolveReflectiveProvider);
    const resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());
    return Array.from(resolvedProviderMap.values());
  }
  function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
    for (let i = 0; i < providers.length; i++) {
      const provider = providers[i];
      const existing = normalizedProvidersMap.get(provider.key.id);
      if (existing) {
        if (provider.multiProvider !== existing.multiProvider) {
          throw mixingMultiProvidersWithRegularProvidersError(existing, provider);
        }
        if (provider.multiProvider) {
          for (let j = 0; j < provider.resolvedFactories.length; j++) {
            existing.resolvedFactories.push(provider.resolvedFactories[j]);
          }
        } else {
          normalizedProvidersMap.set(provider.key.id, provider);
        }
      } else {
        let resolvedProvider;
        if (provider.multiProvider) {
          resolvedProvider = new ResolvedReflectiveProvider_(
              provider.key, provider.resolvedFactories.slice(), provider.multiProvider);
        } else {
          resolvedProvider = provider;
        }
        normalizedProvidersMap.set(provider.key.id, resolvedProvider);
      }
    }
    return normalizedProvidersMap;
  }
  function _normalizeProviders(providers, res) {
    providers.forEach((b) => {
      if (b instanceof Type) {
        res.push({provide: b, useClass: b});
      } else if (b && typeof b == 'object' && b.provide !== void 0) {
        res.push(b);
      } else if (Array.isArray(b)) {
        _normalizeProviders(b, res);
      } else {
        throw invalidProviderError(b);
      }
    });
    return res;
  }
  function constructDependencies(typeOrFunc, dependencies) {
    if (!dependencies) {
      return _dependenciesFor(typeOrFunc);
    } else {
      const params = dependencies.map((t) => [t]);
      return dependencies.map((t) => _extractToken(typeOrFunc, t, params));
    }
  }
  function _dependenciesFor(typeOrFunc) {
    const params = reflector.parameters(typeOrFunc);
    if (!params) return [];
    if (params.some((p) => p == null)) {
      throw noAnnotationError(typeOrFunc, params);
    }
    return params.map((p) => _extractToken(typeOrFunc, p, params));
  }
  function _extractToken(typeOrFunc, metadata, params) {
    let token = null;
    let optional = false;
    if (!Array.isArray(metadata)) {
      if (metadata instanceof Inject) {
        return _createDependency(metadata.token, optional, null);
      } else {
        return _createDependency(metadata, optional, null);
      }
    }
    let visibility = null;
    for (let i = 0; i < metadata.length; ++i) {
      const paramMetadata = metadata[i];
      if (paramMetadata instanceof Type) {
        token = paramMetadata;
      } else if (paramMetadata instanceof Inject) {
        token = paramMetadata.token;
      } else if (paramMetadata instanceof Optional) {
        optional = true;
      } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {
        visibility = paramMetadata;
      } else if (paramMetadata instanceof InjectionToken) {
        token = paramMetadata;
      }
    }
    token = resolveForwardRef(token);
    if (token != null) {
      return _createDependency(token, optional, visibility);
    } else {
      throw noAnnotationError(typeOrFunc, params);
    }
  }
  function _createDependency(token, optional, visibility) {
    return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var UNDEFINED = {};
  var ReflectiveInjector = class {
    static resolve(providers) {
      return resolveReflectiveProviders(providers);
    }
    static resolveAndCreate(providers, parent) {
      const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
      return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
    }
    static fromResolvedProviders(providers, parent) {
      return new ReflectiveInjector_(providers, parent);
    }
  };
  var ReflectiveInjector_ = class {
    constructor(_providers, _parent) {
      this._constructionCounter = 0;
      this._providers = _providers;
      this.parent = _parent || null;
      const len = _providers.length;
      this.keyIds = [];
      this.objs = [];
      for (let i = 0; i < len; i++) {
        this.keyIds[i] = _providers[i].key.id;
        this.objs[i] = UNDEFINED;
      }
    }
    get(token, notFoundValue = THROW_IF_NOT_FOUND) {
      return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);
    }
    resolveAndCreateChild(providers) {
      const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
      return this.createChildFromResolved(ResolvedReflectiveProviders);
    }
    createChildFromResolved(providers) {
      const inj = new ReflectiveInjector_(providers);
      inj.parent = this;
      return inj;
    }
    resolveAndInstantiate(provider) {
      return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
    }
    instantiateResolved(provider) {
      return this._instantiateProvider(provider);
    }
    getProviderAtIndex(index) {
      if (index < 0 || index >= this._providers.length) {
        throw outOfBoundsError(index);
      }
      return this._providers[index];
    }
    _new(provider) {
      if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {
        throw cyclicDependencyError(this, provider.key);
      }
      return this._instantiateProvider(provider);
    }
    _getMaxNumberOfObjects() {
      return this.objs.length;
    }
    _instantiateProvider(provider) {
      if (provider.multiProvider) {
        const res = [];
        for (let i = 0; i < provider.resolvedFactories.length; ++i) {
          res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
        }
        return res;
      } else {
        return this._instantiate(provider, provider.resolvedFactories[0]);
      }
    }
    _instantiate(provider, ResolvedReflectiveFactory2) {
      const factory = ResolvedReflectiveFactory2.factory;
      let deps;
      try {
        deps = ResolvedReflectiveFactory2.dependencies.map(
            (dep) => this._getByReflectiveDependency(dep));
      } catch (e) {
        if (e.addKey) {
          e.addKey(this, provider.key);
        }
        throw e;
      }
      let obj;
      try {
        obj = factory(...deps);
      } catch (e) {
        throw instantiationError(this, e, e.stack, provider.key);
      }
      return obj;
    }
    _getByReflectiveDependency(dep) {
      return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);
    }
    _getByKey(key, visibility, notFoundValue) {
      if (key === ReflectiveInjector_.INJECTOR_KEY) {
        return this;
      }
      if (visibility instanceof Self) {
        return this._getByKeySelf(key, notFoundValue);
      } else {
        return this._getByKeyDefault(key, notFoundValue, visibility);
      }
    }
    _getObjByKeyId(keyId) {
      for (let i = 0; i < this.keyIds.length; i++) {
        if (this.keyIds[i] === keyId) {
          if (this.objs[i] === UNDEFINED) {
            this.objs[i] = this._new(this._providers[i]);
          }
          return this.objs[i];
        }
      }
      return UNDEFINED;
    }
    _throwOrNull(key, notFoundValue) {
      if (notFoundValue !== THROW_IF_NOT_FOUND) {
        return notFoundValue;
      } else {
        throw noProviderError(this, key);
      }
    }
    _getByKeySelf(key, notFoundValue) {
      const obj = this._getObjByKeyId(key.id);
      return obj !== UNDEFINED ? obj : this._throwOrNull(key, notFoundValue);
    }
    _getByKeyDefault(key, notFoundValue, visibility) {
      let inj;
      if (visibility instanceof SkipSelf) {
        inj = this.parent;
      } else {
        inj = this;
      }
      while (inj instanceof ReflectiveInjector_) {
        const inj_ = inj;
        const obj = inj_._getObjByKeyId(key.id);
        if (obj !== UNDEFINED) return obj;
        inj = inj_.parent;
      }
      if (inj !== null) {
        return inj.get(key.token, notFoundValue);
      } else {
        return this._throwOrNull(key, notFoundValue);
      }
    }
    get displayName() {
      const providers = _mapProviders(this, (b) => ' "' + b.key.displayName + '" ').join(', ');
      return `ReflectiveInjector(providers: [${providers}])`;
    }
    toString() {
      return this.displayName;
    }
  };
  ReflectiveInjector_.INJECTOR_KEY = ReflectiveKey.get(Injector);
  function _mapProviders(injector, fn) {
    const res = [];
    for (let i = 0; i < injector._providers.length; ++i) {
      res[i] = fn(injector.getProviderAtIndex(i));
    }
    return res;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275directiveInject(token, flags = InjectFlags.Default) {
    const lView = getLView();
    if (lView === null) {
      ngDevMode && assertInjectImplementationNotEqual(\u0275\u0275directiveInject);
      return \u0275\u0275inject(token, flags);
    }
    const tNode = getCurrentTNode();
    return getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);
  }
  function \u0275\u0275invalidFactory() {
    const msg =
        ngDevMode ? `This constructor was not compatible with Dependency Injection.` : 'invalid';
    throw new Error(msg);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275property(propName, value, sanitizer) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(
          tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
    }
    return \u0275\u0275property;
  }
  function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {
    const inputs = tNode.inputs;
    const property = isClassBased ? 'class' : 'style';
    setInputsForProperty(tView, lView, inputs[property], property, value);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function elementStartFirstCreatePass(
      index, tView, lView, native, name, attrsIndex, localRefsIndex) {
    ngDevMode && assertFirstCreatePass(tView);
    ngDevMode && ngDevMode.firstCreatePass++;
    const tViewConsts = tView.consts;
    const attrs = getConstant(tViewConsts, attrsIndex);
    const tNode = getOrCreateTNode(tView, index, 2, name, attrs);
    const hasDirectives =
        resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
    ngDevMode && logUnknownElementError(tView, native, tNode, hasDirectives);
    if (tNode.attrs !== null) {
      computeStaticStyling(tNode, tNode.attrs, false);
    }
    if (tNode.mergedAttrs !== null) {
      computeStaticStyling(tNode, tNode.mergedAttrs, true);
    }
    if (tView.queries !== null) {
      tView.queries.elementStart(tView, tNode);
    }
    return tNode;
  }
  function \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex) {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = HEADER_OFFSET + index;
    ngDevMode &&
        assertEqual(
            getBindingIndex(), tView.bindingStartIndex,
            'elements should be created before any bindings');
    ngDevMode && assertIndexInRange(lView, adjustedIndex);
    const renderer = lView[RENDERER];
    const native = lView[adjustedIndex] = createElementNode(renderer, name, getNamespace());
    const tNode = tView.firstCreatePass ?
        elementStartFirstCreatePass(
            adjustedIndex, tView, lView, native, name, attrsIndex, localRefsIndex) :
        tView.data[adjustedIndex];
    setCurrentTNode(tNode, true);
    const mergedAttrs = tNode.mergedAttrs;
    if (mergedAttrs !== null) {
      setUpAttributes(renderer, native, mergedAttrs);
    }
    const classes = tNode.classes;
    if (classes !== null) {
      writeDirectClass(renderer, native, classes);
    }
    const styles = tNode.styles;
    if (styles !== null) {
      writeDirectStyle(renderer, native, styles);
    }
    if ((tNode.flags & 64) !== 64) {
      appendChild(tView, lView, native, tNode);
    }
    if (getElementDepthCount() === 0) {
      attachPatchData(native, lView);
    }
    increaseElementDepthCount();
    if (isDirectiveHost(tNode)) {
      createDirectivesInstances(tView, lView, tNode);
      executeContentQueries(tView, tNode, lView);
    }
    if (localRefsIndex !== null) {
      saveResolvedLocalsInData(lView, tNode);
    }
  }
  function \u0275\u0275elementEnd() {
    let currentTNode = getCurrentTNode();
    ngDevMode && assertDefined(currentTNode, 'No parent node to close.');
    if (isCurrentTNodeParent()) {
      setCurrentTNodeAsNotParent();
    } else {
      ngDevMode && assertHasParent(getCurrentTNode());
      currentTNode = currentTNode.parent;
      setCurrentTNode(currentTNode, false);
    }
    const tNode = currentTNode;
    ngDevMode && assertTNodeType(tNode, 3);
    decreaseElementDepthCount();
    const tView = getTView();
    if (tView.firstCreatePass) {
      registerPostOrderHooks(tView, currentTNode);
      if (isContentQueryHost(currentTNode)) {
        tView.queries.elementEnd(currentTNode);
      }
    }
    if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {
      setDirectiveInputsWhichShadowsStyling(
          tView, tNode, getLView(), tNode.classesWithoutHost, true);
    }
    if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {
      setDirectiveInputsWhichShadowsStyling(
          tView, tNode, getLView(), tNode.stylesWithoutHost, false);
    }
  }
  function \u0275\u0275element(index, name, attrsIndex, localRefsIndex) {
    \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex);
    \u0275\u0275elementEnd();
  }
  function logUnknownElementError(tView, element, tNode, hasDirectives) {
    const schemas = tView.schemas;
    if (schemas === null) return;
    const tagName = tNode.value;
    if (!hasDirectives && tagName !== null) {
      const isUnknown = typeof HTMLUnknownElement !== 'undefined' && HTMLUnknownElement &&
              element instanceof HTMLUnknownElement ||
          typeof customElements !== 'undefined' && tagName.indexOf('-') > -1 &&
              !customElements.get(tagName);
      if (isUnknown && !matchingSchemas(tView, tagName)) {
        let message = `'${tagName}' is not a known element:
`;
        message +=
            `1. If '${tagName}' is an Angular component, then verify that it is part of this module.
`;
        if (tagName && tagName.indexOf('-') > -1) {
          message += `2. If '${
              tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.`;
        } else {
          message +=
              `2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;
        }
        console.error(formatRuntimeError('304', message));
      }
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {
    ngDevMode && ngDevMode.firstCreatePass++;
    const tViewConsts = tView.consts;
    const attrs = getConstant(tViewConsts, attrsIndex);
    const tNode = getOrCreateTNode(tView, index, 8, 'ng-container', attrs);
    if (attrs !== null) {
      computeStaticStyling(tNode, attrs, true);
    }
    const localRefs = getConstant(tViewConsts, localRefsIndex);
    resolveDirectives(tView, lView, tNode, localRefs);
    if (tView.queries !== null) {
      tView.queries.elementStart(tView, tNode);
    }
    return tNode;
  }
  function \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex) {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = index + HEADER_OFFSET;
    ngDevMode && assertIndexInRange(lView, adjustedIndex);
    ngDevMode &&
        assertEqual(
            getBindingIndex(), tView.bindingStartIndex,
            'element containers should be created before any bindings');
    const tNode = tView.firstCreatePass ?
        elementContainerStartFirstCreatePass(
            adjustedIndex, tView, lView, attrsIndex, localRefsIndex) :
        tView.data[adjustedIndex];
    setCurrentTNode(tNode, true);
    ngDevMode && ngDevMode.rendererCreateComment++;
    const native = lView[adjustedIndex] =
        lView[RENDERER].createComment(ngDevMode ? 'ng-container' : '');
    appendChild(tView, lView, native, tNode);
    attachPatchData(native, lView);
    if (isDirectiveHost(tNode)) {
      createDirectivesInstances(tView, lView, tNode);
      executeContentQueries(tView, tNode, lView);
    }
    if (localRefsIndex != null) {
      saveResolvedLocalsInData(lView, tNode);
    }
  }
  function \u0275\u0275elementContainerEnd() {
    let currentTNode = getCurrentTNode();
    const tView = getTView();
    if (isCurrentTNodeParent()) {
      setCurrentTNodeAsNotParent();
    } else {
      ngDevMode && assertHasParent(currentTNode);
      currentTNode = currentTNode.parent;
      setCurrentTNode(currentTNode, false);
    }
    ngDevMode && assertTNodeType(currentTNode, 8);
    if (tView.firstCreatePass) {
      registerPostOrderHooks(tView, currentTNode);
      if (isContentQueryHost(currentTNode)) {
        tView.queries.elementEnd(currentTNode);
      }
    }
  }
  function \u0275\u0275elementContainer(index, attrsIndex, localRefsIndex) {
    \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex);
    \u0275\u0275elementContainerEnd();
  }
  function \u0275\u0275getCurrentView() {
    return getLView();
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function isPromise2(obj) {
    return !!obj && typeof obj.then === 'function';
  }
  function isObservable2(obj) {
    return !!obj && typeof obj.subscribe === 'function';
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275listener(eventName, listenerFn, useCapture = false, eventTargetResolver) {
    const lView = getLView();
    const tView = getTView();
    const tNode = getCurrentTNode();
    listenerInternal(
        tView, lView, lView[RENDERER], tNode, eventName, listenerFn, useCapture,
        eventTargetResolver);
    return \u0275\u0275listener;
  }
  function \u0275\u0275syntheticHostListener(
      eventName, listenerFn, useCapture = false, eventTargetResolver) {
    const tNode = getCurrentTNode();
    const lView = getLView();
    const tView = getTView();
    const currentDef = getCurrentDirectiveDef(tView.data);
    const renderer = loadComponentRenderer(currentDef, tNode, lView);
    listenerInternal(
        tView, lView, renderer, tNode, eventName, listenerFn, useCapture, eventTargetResolver);
    return \u0275\u0275syntheticHostListener;
  }
  function findExistingListener(tView, lView, eventName, tNodeIdx) {
    const tCleanup = tView.cleanup;
    if (tCleanup != null) {
      for (let i = 0; i < tCleanup.length - 1; i += 2) {
        const cleanupEventName = tCleanup[i];
        if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {
          const lCleanup = lView[CLEANUP];
          const listenerIdxInLCleanup = tCleanup[i + 2];
          return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
        }
        if (typeof cleanupEventName === 'string') {
          i += 2;
        }
      }
    }
    return null;
  }
  function listenerInternal(
      tView, lView, renderer, tNode, eventName, listenerFn, useCapture = false,
      eventTargetResolver) {
    const isTNodeDirectiveHost = isDirectiveHost(tNode);
    const firstCreatePass = tView.firstCreatePass;
    const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);
    const lCleanup = getOrCreateLViewCleanup(lView);
    ngDevMode && assertTNodeType(tNode, 3 | 12);
    let processOutputs = true;
    if (tNode.type & 3) {
      const native = getNativeByTNode(tNode, lView);
      const resolved = eventTargetResolver ? eventTargetResolver(native) : EMPTY_OBJ;
      const target = resolved.target || native;
      const lCleanupIndex = lCleanup.length;
      const idxOrTargetGetter = eventTargetResolver ?
          (_lView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])).target :
          tNode.index;
      if (isProceduralRenderer(renderer)) {
        let existingListener = null;
        if (!eventTargetResolver && isTNodeDirectiveHost) {
          existingListener = findExistingListener(tView, lView, eventName, tNode.index);
        }
        if (existingListener !== null) {
          const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
          lastListenerFn.__ngNextListenerFn__ = listenerFn;
          existingListener.__ngLastListenerFn__ = listenerFn;
          processOutputs = false;
        } else {
          listenerFn = wrapListener(tNode, lView, listenerFn, false);
          const cleanupFn = renderer.listen(resolved.name || target, eventName, listenerFn);
          ngDevMode && ngDevMode.rendererAddEventListener++;
          lCleanup.push(listenerFn, cleanupFn);
          tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);
        }
      } else {
        listenerFn = wrapListener(tNode, lView, listenerFn, true);
        target.addEventListener(eventName, listenerFn, useCapture);
        ngDevMode && ngDevMode.rendererAddEventListener++;
        lCleanup.push(listenerFn);
        tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, useCapture);
      }
    } else {
      listenerFn = wrapListener(tNode, lView, listenerFn, false);
    }
    const outputs = tNode.outputs;
    let props;
    if (processOutputs && outputs !== null && (props = outputs[eventName])) {
      const propsLength = props.length;
      if (propsLength) {
        for (let i = 0; i < propsLength; i += 2) {
          const index = props[i];
          ngDevMode && assertIndexInRange(lView, index);
          const minifiedName = props[i + 1];
          const directiveInstance = lView[index];
          const output = directiveInstance[minifiedName];
          if (ngDevMode && !isObservable2(output)) {
            throw new Error(`@Output ${minifiedName} not initialized in '${
                directiveInstance.constructor.name}'.`);
          }
          const subscription = output.subscribe(listenerFn);
          const idx = lCleanup.length;
          lCleanup.push(listenerFn, subscription);
          tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
        }
      }
    }
  }
  function executeListenerWithErrorHandling(lView, listenerFn, e) {
    try {
      return listenerFn(e) !== false;
    } catch (error) {
      handleError(lView, error);
      return false;
    }
  }
  function wrapListener(tNode, lView, listenerFn, wrapWithPreventDefault) {
    return function wrapListenerIn_markDirtyAndPreventDefault(e) {
      if (e === Function) {
        return listenerFn;
      }
      const startView = tNode.flags & 2 ? getComponentLViewByIndex(tNode.index, lView) : lView;
      if ((lView[FLAGS] & 32) === 0) {
        markViewDirty(startView);
      }
      let result = executeListenerWithErrorHandling(lView, listenerFn, e);
      let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
      while (nextListenerFn) {
        result = executeListenerWithErrorHandling(lView, nextListenerFn, e) && result;
        nextListenerFn = nextListenerFn.__ngNextListenerFn__;
      }
      if (wrapWithPreventDefault && result === false) {
        e.preventDefault();
        e.returnValue = false;
      }
      return result;
    };
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275nextContext(level = 1) {
    return nextContextImpl(level);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function matchingProjectionSlotIndex(tNode, projectionSlots) {
    let wildcardNgContentIndex = null;
    const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
    for (let i = 0; i < projectionSlots.length; i++) {
      const slotValue = projectionSlots[i];
      if (slotValue === '*') {
        wildcardNgContentIndex = i;
        continue;
      }
      if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(tNode, slotValue, true) :
                                        isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
        return i;
      }
    }
    return wildcardNgContentIndex;
  }
  function \u0275\u0275projectionDef(projectionSlots) {
    const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];
    if (!componentNode.projection) {
      const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
      const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);
      const tails = projectionHeads.slice();
      let componentChild = componentNode.child;
      while (componentChild !== null) {
        const slotIndex =
            projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
        if (slotIndex !== null) {
          if (tails[slotIndex]) {
            tails[slotIndex].projectionNext = componentChild;
          } else {
            projectionHeads[slotIndex] = componentChild;
          }
          tails[slotIndex] = componentChild;
        }
        componentChild = componentChild.next;
      }
    }
  }
  function \u0275\u0275projection(nodeIndex, selectorIndex = 0, attrs) {
    const lView = getLView();
    const tView = getTView();
    const tProjectionNode =
        getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16, null, attrs || null);
    if (tProjectionNode.projection === null) tProjectionNode.projection = selectorIndex;
    setCurrentTNodeAsNotParent();
    if ((tProjectionNode.flags & 64) !== 64) {
      applyProjection(tView, lView, tProjectionNode);
    }
  }
  function \u0275\u0275propertyInterpolate(propName, v0, sanitizer) {
    \u0275\u0275propertyInterpolate1(propName, '', v0, '', sanitizer);
    return \u0275\u0275propertyInterpolate;
  }
  function \u0275\u0275propertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(
          tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode &&
          storePropertyBindingMetadata(
              tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);
    }
    return \u0275\u0275propertyInterpolate1;
  }
  function \u0275\u0275propertyInterpolate2(propName, prefix, v0, i011, v1, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i011, v1, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(
          tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode &&
          storePropertyBindingMetadata(
              tView.data, tNode, propName, getBindingIndex() - 2, prefix, i011, suffix);
    }
    return \u0275\u0275propertyInterpolate2;
  }
  function \u0275\u0275propertyInterpolate3(
      propName, prefix, v0, i011, v1, i19, v2, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i011, v1, i19, v2, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(
          tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode &&
          storePropertyBindingMetadata(
              tView.data, tNode, propName, getBindingIndex() - 3, prefix, i011, i19, suffix);
    }
    return \u0275\u0275propertyInterpolate3;
  }
  function \u0275\u0275propertyInterpolate4(
      propName, prefix, v0, i011, v1, i19, v2, i26, v3, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i011, v1, i19, v2, i26, v3, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(
          tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode &&
          storePropertyBindingMetadata(
              tView.data, tNode, propName, getBindingIndex() - 4, prefix, i011, i19, i26, suffix);
    }
    return \u0275\u0275propertyInterpolate4;
  }
  function \u0275\u0275propertyInterpolate5(
      propName, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue =
        interpolation5(lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(
          tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode &&
          storePropertyBindingMetadata(
              tView.data, tNode, propName, getBindingIndex() - 5, prefix, i011, i19, i26, i34,
              suffix);
    }
    return \u0275\u0275propertyInterpolate5;
  }
  function \u0275\u0275propertyInterpolate6(
      propName, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue =
        interpolation6(lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(
          tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode &&
          storePropertyBindingMetadata(
              tView.data, tNode, propName, getBindingIndex() - 6, prefix, i011, i19, i26, i34, i43,
              suffix);
    }
    return \u0275\u0275propertyInterpolate6;
  }
  function \u0275\u0275propertyInterpolate7(
      propName, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, suffix,
      sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation7(
        lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(
          tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode &&
          storePropertyBindingMetadata(
              tView.data, tNode, propName, getBindingIndex() - 7, prefix, i011, i19, i26, i34, i43,
              i52, suffix);
    }
    return \u0275\u0275propertyInterpolate7;
  }
  function \u0275\u0275propertyInterpolate8(
      propName, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, i62, v7, suffix,
      sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation8(
        lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, i62, v7, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(
          tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode &&
          storePropertyBindingMetadata(
              tView.data, tNode, propName, getBindingIndex() - 8, prefix, i011, i19, i26, i34, i43,
              i52, i62, suffix);
    }
    return \u0275\u0275propertyInterpolate8;
  }
  function \u0275\u0275propertyInterpolateV(propName, values, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(
          tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      if (ngDevMode) {
        const interpolationInBetween = [values[0]];
        for (let i = 2; i < values.length; i += 2) {
          interpolationInBetween.push(values[i]);
        }
        storePropertyBindingMetadata(
            tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1,
            ...interpolationInBetween);
      }
    }
    return \u0275\u0275propertyInterpolateV;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var EMPTY_OBJ$1 = {};
  var EMPTY_ARRAY$3 = [];
  if ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {
    Object.freeze(EMPTY_OBJ$1);
    Object.freeze(EMPTY_ARRAY$3);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function insertTStylingBinding(
      tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {
    ngDevMode && assertFirstUpdatePass(getTView());
    let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
    let tmplHead = getTStylingRangePrev(tBindings);
    let tmplTail = getTStylingRangeNext(tBindings);
    tData[index] = tStylingKeyWithStatic;
    let isKeyDuplicateOfStatic = false;
    let tStylingKey;
    if (Array.isArray(tStylingKeyWithStatic)) {
      const staticKeyValueArray = tStylingKeyWithStatic;
      tStylingKey = staticKeyValueArray[1];
      if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {
        isKeyDuplicateOfStatic = true;
      }
    } else {
      tStylingKey = tStylingKeyWithStatic;
    }
    if (isHostBinding) {
      const hasTemplateBindings = tmplTail !== 0;
      if (hasTemplateBindings) {
        const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
        tData[index + 1] = toTStylingRange(previousNode, tmplHead);
        if (previousNode !== 0) {
          tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);
        }
        tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);
      } else {
        tData[index + 1] = toTStylingRange(tmplHead, 0);
        if (tmplHead !== 0) {
          tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);
        }
        tmplHead = index;
      }
    } else {
      tData[index + 1] = toTStylingRange(tmplTail, 0);
      ngDevMode &&
          assertEqual(
              tmplHead !== 0 && tmplTail === 0, false,
              'Adding template bindings after hostBindings is not allowed.');
      if (tmplHead === 0) {
        tmplHead = index;
      } else {
        tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);
      }
      tmplTail = index;
    }
    if (isKeyDuplicateOfStatic) {
      tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);
    }
    markDuplicates(tData, tStylingKey, index, true, isClassBinding);
    markDuplicates(tData, tStylingKey, index, false, isClassBinding);
    markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);
    tBindings = toTStylingRange(tmplHead, tmplTail);
    if (isClassBinding) {
      tNode.classBindings = tBindings;
    } else {
      tNode.styleBindings = tBindings;
    }
  }
  function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {
    const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
    if (residual != null && typeof tStylingKey == 'string' &&
        keyValueArrayIndexOf(residual, tStylingKey) >= 0) {
      tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);
    }
  }
  function markDuplicates(tData, tStylingKey, index, isPrevDir, isClassBinding) {
    const tStylingAtIndex = tData[index + 1];
    const isMap = tStylingKey === null;
    let cursor =
        isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
    let foundDuplicate = false;
    while (cursor !== 0 && (foundDuplicate === false || isMap)) {
      ngDevMode && assertIndexInRange(tData, cursor);
      const tStylingValueAtCursor = tData[cursor];
      const tStyleRangeAtCursor = tData[cursor + 1];
      if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
        foundDuplicate = true;
        tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) :
                                        setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
      }
      cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) :
                           getTStylingRangeNext(tStyleRangeAtCursor);
    }
    if (foundDuplicate) {
      tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) :
                                     setTStylingRangeNextDuplicate(tStylingAtIndex);
    }
  }
  function isStylingMatch(tStylingKeyCursor, tStylingKey) {
    ngDevMode &&
        assertNotEqual(
            Array.isArray(tStylingKey), true, 'Expected that \'tStylingKey\' has been unwrapped');
    if (tStylingKeyCursor === null || tStylingKey == null ||
        (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) ===
            tStylingKey) {
      return true;
    } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === 'string') {
      return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0;
    }
    return false;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var parserState = {textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0};
  function getLastParsedKey(text) {
    return text.substring(parserState.key, parserState.keyEnd);
  }
  function getLastParsedValue(text) {
    return text.substring(parserState.value, parserState.valueEnd);
  }
  function parseClassName(text) {
    resetParserState(text);
    return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));
  }
  function parseClassNameNext(text, index) {
    const end = parserState.textEnd;
    if (end === index) {
      return -1;
    }
    index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);
    return consumeWhitespace(text, index, end);
  }
  function parseStyle(text) {
    resetParserState(text);
    return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));
  }
  function parseStyleNext(text, startIndex) {
    const end = parserState.textEnd;
    let index = parserState.key = consumeWhitespace(text, startIndex, end);
    if (end === index) {
      return -1;
    }
    index = parserState.keyEnd = consumeStyleKey(text, index, end);
    index = consumeSeparator(text, index, end, 58);
    index = parserState.value = consumeWhitespace(text, index, end);
    index = parserState.valueEnd = consumeStyleValue(text, index, end);
    return consumeSeparator(text, index, end, 59);
  }
  function resetParserState(text) {
    parserState.key = 0;
    parserState.keyEnd = 0;
    parserState.value = 0;
    parserState.valueEnd = 0;
    parserState.textEnd = text.length;
  }
  function consumeWhitespace(text, startIndex, endIndex) {
    while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32) {
      startIndex++;
    }
    return startIndex;
  }
  function consumeClassToken(text, startIndex, endIndex) {
    while (startIndex < endIndex && text.charCodeAt(startIndex) > 32) {
      startIndex++;
    }
    return startIndex;
  }
  function consumeStyleKey(text, startIndex, endIndex) {
    let ch;
    while (startIndex < endIndex &&
           ((ch = text.charCodeAt(startIndex)) === 45 || ch === 95 ||
            (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57)) {
      startIndex++;
    }
    return startIndex;
  }
  function consumeSeparator(text, startIndex, endIndex, separator) {
    startIndex = consumeWhitespace(text, startIndex, endIndex);
    if (startIndex < endIndex) {
      if (ngDevMode && text.charCodeAt(startIndex) !== separator) {
        malformedStyleError(text, String.fromCharCode(separator), startIndex);
      }
      startIndex++;
    }
    return startIndex;
  }
  function consumeStyleValue(text, startIndex, endIndex) {
    let ch1 = -1;
    let ch2 = -1;
    let ch3 = -1;
    let i = startIndex;
    let lastChIndex = i;
    while (i < endIndex) {
      const ch = text.charCodeAt(i++);
      if (ch === 59) {
        return lastChIndex;
      } else if (ch === 34 || ch === 39) {
        lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);
      } else if (startIndex === i - 4 && ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) {
        lastChIndex = i = consumeQuotedText(text, 41, i, endIndex);
      } else if (ch > 32) {
        lastChIndex = i;
      }
      ch3 = ch2;
      ch2 = ch1;
      ch1 = ch & -33;
    }
    return lastChIndex;
  }
  function consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {
    let ch1 = -1;
    let index = startIndex;
    while (index < endIndex) {
      const ch = text.charCodeAt(index++);
      if (ch == quoteCharCode && ch1 !== 92) {
        return index;
      }
      if (ch == 92 && ch1 === 92) {
        ch1 = 0;
      } else {
        ch1 = ch;
      }
    }
    throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) :
                      new Error();
  }
  function malformedStyleError(text, expecting, index) {
    ngDevMode && assertEqual(typeof text === 'string', true, 'String expected here');
    throw throwError2(
        `Malformed style at location ${index} in string '` + text.substring(0, index) + '[>>' +
        text.substring(index, index + 1) + '<<]' + text.substr(index + 1) +
        `'. Expecting '${expecting}'.`);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275styleProp(prop, value, suffix) {
    checkStylingProperty(prop, value, suffix, false);
    return \u0275\u0275styleProp;
  }
  function \u0275\u0275classProp(className, value) {
    checkStylingProperty(className, value, null, true);
    return \u0275\u0275classProp;
  }
  function \u0275\u0275styleMap(styles) {
    checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);
  }
  function styleStringParser(keyValueArray, text) {
    for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {
      styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));
    }
  }
  function \u0275\u0275classMap(classes) {
    checkStylingMap(keyValueArraySet, classStringParser, classes, true);
  }
  function classStringParser(keyValueArray, text) {
    for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {
      keyValueArraySet(keyValueArray, getLastParsedKey(text), true);
    }
  }
  function checkStylingProperty(prop, value, suffix, isClassBased) {
    const lView = getLView();
    const tView = getTView();
    const bindingIndex = incrementBindingIndex(2);
    if (tView.firstUpdatePass) {
      stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
    }
    if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
      const tNode = tView.data[getSelectedIndex()];
      updateStyling(
          tView, tNode, lView, lView[RENDERER], prop,
          lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);
    }
  }
  function checkStylingMap(keyValueArraySet2, stringParser, value, isClassBased) {
    const tView = getTView();
    const bindingIndex = incrementBindingIndex(2);
    if (tView.firstUpdatePass) {
      stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
    }
    const lView = getLView();
    if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
      const tNode = tView.data[getSelectedIndex()];
      if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
        if (ngDevMode) {
          const tStylingKey = tView.data[bindingIndex];
          assertEqual(
              Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false,
              'Styling linked list shadow input should be marked as \'false\'');
        }
        let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
        ngDevMode && isClassBased === false && staticPrefix !== null &&
            assertEqual(
                staticPrefix.endsWith(';'), true, 'Expecting static portion to end with \';\'');
        if (staticPrefix !== null) {
          value = concatStringsWithSpace(staticPrefix, value ? value : '');
        }
        setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);
      } else {
        updateStylingMap(
            tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1],
            lView[bindingIndex + 1] =
                toStylingKeyValueArray(keyValueArraySet2, stringParser, value),
            isClassBased, bindingIndex);
      }
    }
  }
  function isInHostBindings(tView, bindingIndex) {
    return bindingIndex >= tView.expandoStartIndex;
  }
  function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
    ngDevMode && assertFirstUpdatePass(tView);
    const tData = tView.data;
    if (tData[bindingIndex + 1] === null) {
      const tNode = tData[getSelectedIndex()];
      ngDevMode && assertDefined(tNode, 'TNode expected');
      const isHostBindings = isInHostBindings(tView, bindingIndex);
      if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {
        tStylingKey = false;
      }
      tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
      insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
    }
  }
  function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
    const hostDirectiveDef = getCurrentDirectiveDef(tData);
    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
    if (hostDirectiveDef === null) {
      const isFirstStylingInstructionInTemplate =
          (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
      if (isFirstStylingInstructionInTemplate) {
        stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
        stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
        residual = null;
      }
    } else {
      const directiveStylingLast = tNode.directiveStylingLast;
      const isFirstStylingInstructionInHostBinding =
          directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
      if (isFirstStylingInstructionInHostBinding) {
        stylingKey =
            collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
        if (residual === null) {
          let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
          if (templateStylingKey !== void 0 && Array.isArray(templateStylingKey)) {
            templateStylingKey = collectStylingFromDirectives(
                null, tData, tNode, templateStylingKey[1], isClassBased);
            templateStylingKey =
                collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
            setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
          }
        } else {
          residual = collectResidual(tData, tNode, isClassBased);
        }
      }
    }
    if (residual !== void 0) {
      isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;
    }
    return stylingKey;
  }
  function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
    const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
    if (getTStylingRangeNext(bindings) === 0) {
      return void 0;
    }
    return tData[getTStylingRangePrev(bindings)];
  }
  function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
    const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
    ngDevMode &&
        assertNotEqual(
            getTStylingRangeNext(bindings), 0,
            'Expecting to have at least one template styling binding.');
    tData[getTStylingRangePrev(bindings)] = tStylingKey;
  }
  function collectResidual(tData, tNode, isClassBased) {
    let residual = void 0;
    const directiveEnd = tNode.directiveEnd;
    ngDevMode &&
        assertNotEqual(
            tNode.directiveStylingLast, -1,
            'By the time this function gets called at least one hostBindings-node styling instruction must have executed.');
    for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {
      const attrs = tData[i].hostAttrs;
      residual = collectStylingFromTAttrs(residual, attrs, isClassBased);
    }
    return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);
  }
  function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
    let currentDirective = null;
    const directiveEnd = tNode.directiveEnd;
    let directiveStylingLast = tNode.directiveStylingLast;
    if (directiveStylingLast === -1) {
      directiveStylingLast = tNode.directiveStart;
    } else {
      directiveStylingLast++;
    }
    while (directiveStylingLast < directiveEnd) {
      currentDirective = tData[directiveStylingLast];
      ngDevMode && assertDefined(currentDirective, 'expected to be defined');
      stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
      if (currentDirective === hostDirectiveDef) break;
      directiveStylingLast++;
    }
    if (hostDirectiveDef !== null) {
      tNode.directiveStylingLast = directiveStylingLast;
    }
    return stylingKey;
  }
  function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
    const desiredMarker = isClassBased ? 1 : 2;
    let currentMarker = -1;
    if (attrs !== null) {
      for (let i = 0; i < attrs.length; i++) {
        const item = attrs[i];
        if (typeof item === 'number') {
          currentMarker = item;
        } else {
          if (currentMarker === desiredMarker) {
            if (!Array.isArray(stylingKey)) {
              stylingKey = stylingKey === void 0 ? [] : ['', stylingKey];
            }
            keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);
          }
        }
      }
    }
    return stylingKey === void 0 ? null : stylingKey;
  }
  function toStylingKeyValueArray(keyValueArraySet2, stringParser, value) {
    if (value == null || value === '') return EMPTY_ARRAY$3;
    const styleKeyValueArray = [];
    const unwrappedValue = unwrapSafeValue(value);
    if (Array.isArray(unwrappedValue)) {
      for (let i = 0; i < unwrappedValue.length; i++) {
        keyValueArraySet2(styleKeyValueArray, unwrappedValue[i], true);
      }
    } else if (typeof unwrappedValue === 'object') {
      for (const key in unwrappedValue) {
        if (unwrappedValue.hasOwnProperty(key)) {
          keyValueArraySet2(styleKeyValueArray, key, unwrappedValue[key]);
        }
      }
    } else if (typeof unwrappedValue === 'string') {
      stringParser(styleKeyValueArray, unwrappedValue);
    } else {
      ngDevMode &&
          throwError2('Unsupported styling type ' + typeof unwrappedValue + ': ' + unwrappedValue);
    }
    return styleKeyValueArray;
  }
  function styleKeyValueArraySet(keyValueArray, key, value) {
    keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));
  }
  function updateStylingMap(
      tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased,
      bindingIndex) {
    if (oldKeyValueArray === NO_CHANGE) {
      oldKeyValueArray = EMPTY_ARRAY$3;
    }
    let oldIndex = 0;
    let newIndex = 0;
    let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
    let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
    while (oldKey !== null || newKey !== null) {
      ngDevMode && assertLessThan(oldIndex, 999, 'Are we stuck in infinite loop?');
      ngDevMode && assertLessThan(newIndex, 999, 'Are we stuck in infinite loop?');
      const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : void 0;
      const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : void 0;
      let setKey = null;
      let setValue = void 0;
      if (oldKey === newKey) {
        oldIndex += 2;
        newIndex += 2;
        if (oldValue !== newValue) {
          setKey = newKey;
          setValue = newValue;
        }
      } else if (newKey === null || oldKey !== null && oldKey < newKey) {
        oldIndex += 2;
        setKey = oldKey;
      } else {
        ngDevMode && assertDefined(newKey, 'Expecting to have a valid key');
        newIndex += 2;
        setKey = newKey;
        setValue = newValue;
      }
      if (setKey !== null) {
        updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
      }
      oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
      newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
    }
  }
  function updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {
    if (!(tNode.type & 3)) {
      return;
    }
    const tData = tView.data;
    const tRange = tData[bindingIndex + 1];
    const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ?
        findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) :
        void 0;
    if (!isStylingValuePresent(higherPriorityValue)) {
      if (!isStylingValuePresent(value)) {
        if (getTStylingRangePrevDuplicate(tRange)) {
          value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
        }
      }
      const rNode = getNativeByIndex(getSelectedIndex(), lView);
      applyStyling(renderer, isClassBased, rNode, prop, value);
    }
  }
  function findStylingValue(tData, tNode, lView, prop, index, isClassBased) {
    const isPrevDirection = tNode === null;
    let value = void 0;
    while (index > 0) {
      const rawKey = tData[index];
      const containsStatics = Array.isArray(rawKey);
      const key = containsStatics ? rawKey[1] : rawKey;
      const isStylingMap = key === null;
      let valueAtLViewIndex = lView[index + 1];
      if (valueAtLViewIndex === NO_CHANGE) {
        valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY$3 : void 0;
      }
      let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) :
                                        key === prop ? valueAtLViewIndex : void 0;
      if (containsStatics && !isStylingValuePresent(currentValue)) {
        currentValue = keyValueArrayGet(rawKey, prop);
      }
      if (isStylingValuePresent(currentValue)) {
        value = currentValue;
        if (isPrevDirection) {
          return value;
        }
      }
      const tRange = tData[index + 1];
      index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
    }
    if (tNode !== null) {
      let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
      if (residual != null) {
        value = keyValueArrayGet(residual, prop);
      }
    }
    return value;
  }
  function isStylingValuePresent(value) {
    return value !== void 0;
  }
  function normalizeSuffix(value, suffix) {
    if (value == null) {
    } else if (typeof suffix === 'string') {
      value = value + suffix;
    } else if (typeof value === 'object') {
      value = stringify(unwrapSafeValue(value));
    }
    return value;
  }
  function hasStylingInputShadow(tNode, isClassBased) {
    return (tNode.flags & (isClassBased ? 16 : 32)) !== 0;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275text(index, value = '') {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = index + HEADER_OFFSET;
    ngDevMode &&
        assertEqual(
            getBindingIndex(), tView.bindingStartIndex,
            'text nodes should be created before any bindings');
    ngDevMode && assertIndexInRange(lView, adjustedIndex);
    const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value, null) :
                                          tView.data[adjustedIndex];
    const textNative = lView[adjustedIndex] = createTextNode(lView[RENDERER], value);
    appendChild(tView, lView, textNative, tNode);
    setCurrentTNode(tNode, false);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275textInterpolate(v0) {
    \u0275\u0275textInterpolate1('', v0, '');
    return \u0275\u0275textInterpolate;
  }
  function \u0275\u0275textInterpolate1(prefix, v0, suffix) {
    const lView = getLView();
    const interpolated = interpolation1(lView, prefix, v0, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate1;
  }
  function \u0275\u0275textInterpolate2(prefix, v0, i011, v1, suffix) {
    const lView = getLView();
    const interpolated = interpolation2(lView, prefix, v0, i011, v1, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate2;
  }
  function \u0275\u0275textInterpolate3(prefix, v0, i011, v1, i19, v2, suffix) {
    const lView = getLView();
    const interpolated = interpolation3(lView, prefix, v0, i011, v1, i19, v2, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate3;
  }
  function \u0275\u0275textInterpolate4(prefix, v0, i011, v1, i19, v2, i26, v3, suffix) {
    const lView = getLView();
    const interpolated = interpolation4(lView, prefix, v0, i011, v1, i19, v2, i26, v3, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate4;
  }
  function \u0275\u0275textInterpolate5(prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, suffix) {
    const lView = getLView();
    const interpolated =
        interpolation5(lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate5;
  }
  function \u0275\u0275textInterpolate6(
      prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, suffix) {
    const lView = getLView();
    const interpolated =
        interpolation6(lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate6;
  }
  function \u0275\u0275textInterpolate7(
      prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, suffix) {
    const lView = getLView();
    const interpolated = interpolation7(
        lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate7;
  }
  function \u0275\u0275textInterpolate8(
      prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, i62, v7, suffix) {
    const lView = getLView();
    const interpolated = interpolation8(
        lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, i62, v7, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate8;
  }
  function \u0275\u0275textInterpolateV(values) {
    const lView = getLView();
    const interpolated = interpolationV(lView, values);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolateV;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275classMapInterpolate1(prefix, v0, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate2(prefix, v0, i011, v1, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i011, v1, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate3(prefix, v0, i011, v1, i19, v2, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i011, v1, i19, v2, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate4(prefix, v0, i011, v1, i19, v2, i26, v3, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i011, v1, i19, v2, i26, v3, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate5(
      prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, suffix) {
    const lView = getLView();
    const interpolatedValue =
        interpolation5(lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate6(
      prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, suffix) {
    const lView = getLView();
    const interpolatedValue =
        interpolation6(lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate7(
      prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation7(
        lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate8(
      prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, i62, v7, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation8(
        lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, i62, v7, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolateV(values) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275styleMapInterpolate1(prefix, v0, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate2(prefix, v0, i011, v1, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i011, v1, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate3(prefix, v0, i011, v1, i19, v2, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i011, v1, i19, v2, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate4(prefix, v0, i011, v1, i19, v2, i26, v3, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i011, v1, i19, v2, i26, v3, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate5(
      prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, suffix) {
    const lView = getLView();
    const interpolatedValue =
        interpolation5(lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate6(
      prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, suffix) {
    const lView = getLView();
    const interpolatedValue =
        interpolation6(lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate7(
      prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation7(
        lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate8(
      prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, i62, v7, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation8(
        lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, i62, v7, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolateV(values) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    \u0275\u0275styleMap(interpolatedValue);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275stylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate1;
  }
  function \u0275\u0275stylePropInterpolate2(prop, prefix, v0, i011, v1, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i011, v1, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate2;
  }
  function \u0275\u0275stylePropInterpolate3(
      prop, prefix, v0, i011, v1, i19, v2, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i011, v1, i19, v2, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate3;
  }
  function \u0275\u0275stylePropInterpolate4(
      prop, prefix, v0, i011, v1, i19, v2, i26, v3, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i011, v1, i19, v2, i26, v3, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate4;
  }
  function \u0275\u0275stylePropInterpolate5(
      prop, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue =
        interpolation5(lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate5;
  }
  function \u0275\u0275stylePropInterpolate6(
      prop, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue =
        interpolation6(lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate6;
  }
  function \u0275\u0275stylePropInterpolate7(
      prop, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, suffix,
      valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation7(
        lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate7;
  }
  function \u0275\u0275stylePropInterpolate8(
      prop, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, i62, v7, suffix,
      valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation8(
        lView, prefix, v0, i011, v1, i19, v2, i26, v3, i34, v4, i43, v5, i52, v6, i62, v7, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate8;
  }
  function \u0275\u0275stylePropInterpolateV(prop, values, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolateV;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275hostProperty(propName, value, sanitizer) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(
          tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
    }
    return \u0275\u0275hostProperty;
  }
  function \u0275\u0275syntheticHostProperty(propName, value, sanitizer) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      const currentDef = getCurrentDirectiveDef(tView.data);
      const renderer = loadComponentRenderer(currentDef, tNode, lView);
      elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
    }
    return \u0275\u0275syntheticHostProperty;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  if (typeof ngI18nClosureMode === 'undefined') {
    (function() {
      _global['ngI18nClosureMode'] =
          typeof goog !== 'undefined' && typeof goog.getMsg === 'function';
    })();
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var u = void 0;
  function plural(n) {
    let i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\.?/, '').length;
    if (i === 1 && v === 0) return 1;
    return 5;
  }
  var localeEn = [
    'en',
    [['a', 'p'], ['AM', 'PM'], u],
    [['AM', 'PM'], u, u],
    [
      ['S', 'M', 'T', 'W', 'T', 'F', 'S'], ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']
    ],
    u,
    [
      ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      [
        'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
        'October', 'November', 'December'
      ]
    ],
    u,
    [['B', 'A'], ['BC', 'AD'], ['Before Christ', 'Anno Domini']],
    0,
    [6, 0],
    ['M/d/yy', 'MMM d, y', 'MMMM d, y', 'EEEE, MMMM d, y'],
    ['h:mm a', 'h:mm:ss a', 'h:mm:ss a z', 'h:mm:ss a zzzz'],
    ['{1}, {0}', u, '{1} \'at\' {0}', u],
    ['.', ',', ';', '%', '+', '-', 'E', '\xD7', '\u2030', '\u221E', 'NaN', ':'],
    ['#,##0.###', '#,##0%', '\xA4#,##0.00', '#E0'],
    'USD',
    '$',
    'US Dollar',
    {},
    'ltr',
    plural
  ];
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var LOCALE_DATA = {};
  function findLocaleData(locale) {
    const normalizedLocale = normalizeLocale(locale);
    let match2 = getLocaleData(normalizedLocale);
    if (match2) {
      return match2;
    }
    const parentLocale = normalizedLocale.split('-')[0];
    match2 = getLocaleData(parentLocale);
    if (match2) {
      return match2;
    }
    if (parentLocale === 'en') {
      return localeEn;
    }
    throw new Error(`Missing locale data for the locale "${locale}".`);
  }
  function getLocalePluralCase(locale) {
    const data = findLocaleData(locale);
    return data[LocaleDataIndex.PluralCase];
  }
  function getLocaleData(normalizedLocale) {
    if (!(normalizedLocale in LOCALE_DATA)) {
      LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common &&
          _global.ng.common.locales && _global.ng.common.locales[normalizedLocale];
    }
    return LOCALE_DATA[normalizedLocale];
  }
  var LocaleDataIndex;
  (function(LocaleDataIndex2) {
    LocaleDataIndex2[LocaleDataIndex2['LocaleId'] = 0] = 'LocaleId';
    LocaleDataIndex2[LocaleDataIndex2['DayPeriodsFormat'] = 1] = 'DayPeriodsFormat';
    LocaleDataIndex2[LocaleDataIndex2['DayPeriodsStandalone'] = 2] = 'DayPeriodsStandalone';
    LocaleDataIndex2[LocaleDataIndex2['DaysFormat'] = 3] = 'DaysFormat';
    LocaleDataIndex2[LocaleDataIndex2['DaysStandalone'] = 4] = 'DaysStandalone';
    LocaleDataIndex2[LocaleDataIndex2['MonthsFormat'] = 5] = 'MonthsFormat';
    LocaleDataIndex2[LocaleDataIndex2['MonthsStandalone'] = 6] = 'MonthsStandalone';
    LocaleDataIndex2[LocaleDataIndex2['Eras'] = 7] = 'Eras';
    LocaleDataIndex2[LocaleDataIndex2['FirstDayOfWeek'] = 8] = 'FirstDayOfWeek';
    LocaleDataIndex2[LocaleDataIndex2['WeekendRange'] = 9] = 'WeekendRange';
    LocaleDataIndex2[LocaleDataIndex2['DateFormat'] = 10] = 'DateFormat';
    LocaleDataIndex2[LocaleDataIndex2['TimeFormat'] = 11] = 'TimeFormat';
    LocaleDataIndex2[LocaleDataIndex2['DateTimeFormat'] = 12] = 'DateTimeFormat';
    LocaleDataIndex2[LocaleDataIndex2['NumberSymbols'] = 13] = 'NumberSymbols';
    LocaleDataIndex2[LocaleDataIndex2['NumberFormats'] = 14] = 'NumberFormats';
    LocaleDataIndex2[LocaleDataIndex2['CurrencyCode'] = 15] = 'CurrencyCode';
    LocaleDataIndex2[LocaleDataIndex2['CurrencySymbol'] = 16] = 'CurrencySymbol';
    LocaleDataIndex2[LocaleDataIndex2['CurrencyName'] = 17] = 'CurrencyName';
    LocaleDataIndex2[LocaleDataIndex2['Currencies'] = 18] = 'Currencies';
    LocaleDataIndex2[LocaleDataIndex2['Directionality'] = 19] = 'Directionality';
    LocaleDataIndex2[LocaleDataIndex2['PluralCase'] = 20] = 'PluralCase';
    LocaleDataIndex2[LocaleDataIndex2['ExtraData'] = 21] = 'ExtraData';
  })(LocaleDataIndex || (LocaleDataIndex = {}));
  function normalizeLocale(locale) {
    return locale.toLowerCase().replace(/_/g, '-');
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var pluralMapping = ['zero', 'one', 'two', 'few', 'many'];
  function getPluralCase(value, locale) {
    const plural2 = getLocalePluralCase(locale)(parseInt(value, 10));
    const result = pluralMapping[plural2];
    return result !== void 0 ? result : 'other';
  }
  var DEFAULT_LOCALE_ID = 'en-US';
  var USD_CURRENCY_CODE = 'USD';
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ELEMENT_MARKER = {marker: 'element'};
  var ICU_MARKER = {marker: 'ICU'};
  var I18nCreateOpCode;
  (function(I18nCreateOpCode2) {
    I18nCreateOpCode2[I18nCreateOpCode2['SHIFT'] = 2] = 'SHIFT';
    I18nCreateOpCode2[I18nCreateOpCode2['APPEND_EAGERLY'] = 1] = 'APPEND_EAGERLY';
    I18nCreateOpCode2[I18nCreateOpCode2['COMMENT'] = 2] = 'COMMENT';
  })(I18nCreateOpCode || (I18nCreateOpCode = {}));
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var LOCALE_ID = DEFAULT_LOCALE_ID;
  function setLocaleId(localeId) {
    assertDefined(localeId, `Expected localeId to be defined`);
    if (typeof localeId === 'string') {
      LOCALE_ID = localeId.toLowerCase().replace(/_/g, '-');
    }
  }
  function getLocaleId() {
    return LOCALE_ID;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
    const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
    const insertBeforeIndex =
        Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
    if (insertBeforeIndex === null) {
      return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
    } else {
      ngDevMode && assertIndexInRange(lView, insertBeforeIndex);
      return unwrapRNode(lView[insertBeforeIndex]);
    }
  }
  function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
    const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
    if (Array.isArray(tNodeInsertBeforeIndex)) {
      ngDevMode && assertDomNode(childRNode);
      let i18nParent = childRNode;
      let anchorRNode = null;
      if (!(childTNode.type & 3)) {
        anchorRNode = i18nParent;
        i18nParent = parentRElement;
      }
      if (i18nParent !== null && (childTNode.flags & 2) === 0) {
        for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {
          const i18nChild = lView[tNodeInsertBeforeIndex[i]];
          nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
        }
      }
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
    ngDevMode &&
        assertEqual(
            newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');
    previousTNodes.push(newTNode);
    if (previousTNodes.length > 1) {
      for (let i = previousTNodes.length - 2; i >= 0; i--) {
        const existingTNode = previousTNodes[i];
        if (!isI18nText(existingTNode)) {
          if (isNewTNodeCreatedBefore(existingTNode, newTNode) &&
              getInsertBeforeIndex(existingTNode) === null) {
            setInsertBeforeIndex(existingTNode, newTNode.index);
          }
        }
      }
    }
  }
  function isI18nText(tNode) {
    return !(tNode.type & 64);
  }
  function isNewTNodeCreatedBefore(existingTNode, newTNode) {
    return isI18nText(newTNode) || existingTNode.index > newTNode.index;
  }
  function getInsertBeforeIndex(tNode) {
    const index = tNode.insertBeforeIndex;
    return Array.isArray(index) ? index[0] : index;
  }
  function setInsertBeforeIndex(tNode, value) {
    const index = tNode.insertBeforeIndex;
    if (Array.isArray(index)) {
      index[0] = value;
    } else {
      setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
      tNode.insertBeforeIndex = value;
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function getTIcu(tView, index) {
    const value = tView.data[index];
    if (value === null || typeof value === 'string') return null;
    if (ngDevMode &&
        !(value.hasOwnProperty('tViews') || value.hasOwnProperty('currentCaseLViewIndex'))) {
      throwError2('We expect to get \'null\'|\'TIcu\'|\'TIcuContainer\', but got: ' + value);
    }
    const tIcu = value.hasOwnProperty('currentCaseLViewIndex') ? value : value.value;
    ngDevMode && assertTIcu(tIcu);
    return tIcu;
  }
  function setTIcu(tView, index, tIcu) {
    const tNode = tView.data[index];
    ngDevMode &&
        assertEqual(
            tNode === null || tNode.hasOwnProperty('tViews'), true,
            'We expect to get \'null\'|\'TIcuContainer\'');
    if (tNode === null) {
      tView.data[index] = tIcu;
    } else {
      ngDevMode && assertTNodeType(tNode, 32);
      tNode.value = tIcu;
    }
  }
  function setTNodeInsertBeforeIndex(tNode, index) {
    ngDevMode && assertTNode(tNode);
    let insertBeforeIndex = tNode.insertBeforeIndex;
    if (insertBeforeIndex === null) {
      setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
      insertBeforeIndex = tNode.insertBeforeIndex = [null, index];
    } else {
      assertEqual(Array.isArray(insertBeforeIndex), true, 'Expecting array here');
      insertBeforeIndex.push(index);
    }
  }
  function createTNodePlaceholder(tView, previousTNodes, index) {
    const tNode = createTNodeAtIndex(tView, index, 64, null, null);
    addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
    return tNode;
  }
  function getCurrentICUCaseIndex(tIcu, lView) {
    const currentCase = lView[tIcu.currentCaseLViewIndex];
    return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
  }
  function getParentFromIcuCreateOpCode(mergedCode) {
    return mergedCode >>> 17;
  }
  function getRefFromIcuCreateOpCode(mergedCode) {
    return (mergedCode & 131070) >>> 1;
  }
  function getInstructionFromIcuCreateOpCode(mergedCode) {
    return mergedCode & 1;
  }
  function icuCreateOpCode(opCode, parentIdx, refIdx) {
    ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, 'Missing parent index');
    ngDevMode && assertGreaterThan(refIdx, 0, 'Missing ref index');
    return opCode | parentIdx << 17 | refIdx << 1;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var changeMask = 0;
  var changeMaskCounter = 0;
  function setMaskBit(hasChange) {
    if (hasChange) {
      changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
    }
    changeMaskCounter++;
  }
  function applyI18n(tView, lView, index) {
    if (changeMaskCounter > 0) {
      ngDevMode && assertDefined(tView, `tView should be defined`);
      const tI18n = tView.data[index];
      const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
      const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;
      applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
    }
    changeMask = 0;
    changeMaskCounter = 0;
  }
  function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
    const renderer = lView[RENDERER];
    for (let i = 0; i < createOpCodes.length; i++) {
      const opCode = createOpCodes[i++];
      const text = createOpCodes[i];
      const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
      const appendNow =
          (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
      const index = opCode >>> I18nCreateOpCode.SHIFT;
      let rNode = lView[index];
      if (rNode === null) {
        rNode = lView[index] =
            isComment ? renderer.createComment(text) : createTextNode(renderer, text);
      }
      if (appendNow && parentRNode !== null) {
        nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
      }
    }
  }
  function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
    ngDevMode && assertDomNode(anchorRNode);
    const renderer = lView[RENDERER];
    let rootIdx = null;
    let rootRNode;
    for (let i = 0; i < mutableOpCodes.length; i++) {
      const opCode = mutableOpCodes[i];
      if (typeof opCode == 'string') {
        const textNodeIndex = mutableOpCodes[++i];
        if (lView[textNodeIndex] === null) {
          ngDevMode && ngDevMode.rendererCreateTextNode++;
          ngDevMode && assertIndexInRange(lView, textNodeIndex);
          lView[textNodeIndex] = createTextNode(renderer, opCode);
        }
      } else if (typeof opCode == 'number') {
        switch (opCode & 1) {
          case 0:
            const parentIdx = getParentFromIcuCreateOpCode(opCode);
            if (rootIdx === null) {
              rootIdx = parentIdx;
              rootRNode = nativeParentNode(renderer, anchorRNode);
            }
            let insertInFrontOf;
            let parentRNode;
            if (parentIdx === rootIdx) {
              insertInFrontOf = anchorRNode;
              parentRNode = rootRNode;
            } else {
              insertInFrontOf = null;
              parentRNode = unwrapRNode(lView[parentIdx]);
            }
            if (parentRNode !== null) {
              ngDevMode && assertDomNode(parentRNode);
              const refIdx = getRefFromIcuCreateOpCode(opCode);
              ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, 'Missing ref');
              const child = lView[refIdx];
              ngDevMode && assertDomNode(child);
              nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
              const tIcu = getTIcu(tView, refIdx);
              if (tIcu !== null && typeof tIcu === 'object') {
                ngDevMode && assertTIcu(tIcu);
                const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
                if (caseIndex !== null) {
                  applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
                }
              }
            }
            break;
          case 1:
            const elementNodeIndex = opCode >>> 1;
            const attrName = mutableOpCodes[++i];
            const attrValue = mutableOpCodes[++i];
            setElementAttribute(
                renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName,
                attrValue, null);
            break;
          default:
            throw new Error(`Unable to determine the type of mutate operation for "${opCode}"`);
        }
      } else {
        switch (opCode) {
          case ICU_MARKER:
            const commentValue = mutableOpCodes[++i];
            const commentNodeIndex = mutableOpCodes[++i];
            if (lView[commentNodeIndex] === null) {
              ngDevMode &&
                  assertEqual(
                      typeof commentValue, 'string',
                      `Expected "${commentValue}" to be a comment node value`);
              ngDevMode && ngDevMode.rendererCreateComment++;
              ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);
              const commentRNode = lView[commentNodeIndex] =
                  createCommentNode(renderer, commentValue);
              attachPatchData(commentRNode, lView);
            }
            break;
          case ELEMENT_MARKER:
            const tagName = mutableOpCodes[++i];
            const elementNodeIndex = mutableOpCodes[++i];
            if (lView[elementNodeIndex] === null) {
              ngDevMode &&
                  assertEqual(
                      typeof tagName, 'string',
                      `Expected "${tagName}" to be an element node tag name`);
              ngDevMode && ngDevMode.rendererCreateElement++;
              ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);
              const elementRNode = lView[elementNodeIndex] =
                  createElementNode(renderer, tagName, null);
              attachPatchData(elementRNode, lView);
            }
            break;
          default:
            ngDevMode &&
                throwError2(`Unable to determine the type of mutate operation for "${opCode}"`);
        }
      }
    }
  }
  function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask2) {
    for (let i = 0; i < updateOpCodes.length; i++) {
      const checkBit = updateOpCodes[i];
      const skipCodes = updateOpCodes[++i];
      if (checkBit & changeMask2) {
        let value = '';
        for (let j = i + 1; j <= i + skipCodes; j++) {
          const opCode = updateOpCodes[j];
          if (typeof opCode == 'string') {
            value += opCode;
          } else if (typeof opCode == 'number') {
            if (opCode < 0) {
              value += renderStringify(lView[bindingsStartIndex - opCode]);
            } else {
              const nodeIndex = opCode >>> 2;
              switch (opCode & 3) {
                case 1:
                  const propName = updateOpCodes[++j];
                  const sanitizeFn = updateOpCodes[++j];
                  const tNodeOrTagName = tView.data[nodeIndex];
                  ngDevMode && assertDefined(tNodeOrTagName, 'Experting TNode or string');
                  if (typeof tNodeOrTagName === 'string') {
                    setElementAttribute(
                        lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value,
                        sanitizeFn);
                  } else {
                    elementPropertyInternal(
                        tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn,
                        false);
                  }
                  break;
                case 0:
                  const rText = lView[nodeIndex];
                  rText !== null && updateTextNode(lView[RENDERER], rText, value);
                  break;
                case 2:
                  applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);
                  break;
                case 3:
                  applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
                  break;
              }
            }
          }
        }
      } else {
        const opCode = updateOpCodes[i + 1];
        if (opCode > 0 && (opCode & 3) === 3) {
          const nodeIndex = opCode >>> 2;
          const tIcu = getTIcu(tView, nodeIndex);
          const currentIndex = lView[tIcu.currentCaseLViewIndex];
          if (currentIndex < 0) {
            applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
          }
        }
      }
      i += skipCodes;
    }
  }
  function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
    ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);
    let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
    if (activeCaseIndex !== null) {
      let mask = changeMask;
      if (activeCaseIndex < 0) {
        activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
        mask = -1;
      }
      applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
    }
  }
  function applyIcuSwitchCase(tView, tIcu, lView, value) {
    const caseIndex = getCaseIndex(tIcu, value);
    let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
    if (activeCaseIndex !== caseIndex) {
      applyIcuSwitchCaseRemove(tView, tIcu, lView);
      lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
      if (caseIndex !== null) {
        const anchorRNode = lView[tIcu.anchorIdx];
        if (anchorRNode) {
          ngDevMode && assertDomNode(anchorRNode);
          applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
        }
      }
    }
  }
  function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
    let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
    if (activeCaseIndex !== null) {
      const removeCodes = tIcu.remove[activeCaseIndex];
      for (let i = 0; i < removeCodes.length; i++) {
        const nodeOrIcuIndex = removeCodes[i];
        if (nodeOrIcuIndex > 0) {
          const rNode = getNativeByIndex(nodeOrIcuIndex, lView);
          rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);
        } else {
          applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
        }
      }
    }
  }
  function getCaseIndex(icuExpression, bindingValue) {
    let index = icuExpression.cases.indexOf(bindingValue);
    if (index === -1) {
      switch (icuExpression.type) {
        case 1: {
          const resolvedCase = getPluralCase(bindingValue, getLocaleId());
          index = icuExpression.cases.indexOf(resolvedCase);
          if (index === -1 && resolvedCase !== 'other') {
            index = icuExpression.cases.indexOf('other');
          }
          break;
        }
        case 0: {
          index = icuExpression.cases.indexOf('other');
          break;
        }
      }
    }
    return index === -1 ? null : index;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function loadIcuContainerVisitor() {
    const _stack = [];
    let _index = -1;
    let _lView;
    let _removes;
    function icuContainerIteratorStart(tIcuContainerNode, lView) {
      _lView = lView;
      while (_stack.length) _stack.pop();
      ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);
      enterIcu(tIcuContainerNode.value, lView);
      return icuContainerIteratorNext;
    }
    function enterIcu(tIcu, lView) {
      _index = 0;
      const currentCase = getCurrentICUCaseIndex(tIcu, lView);
      if (currentCase !== null) {
        ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);
        _removes = tIcu.remove[currentCase];
      } else {
        _removes = EMPTY_ARRAY;
      }
    }
    function icuContainerIteratorNext() {
      if (_index < _removes.length) {
        const removeOpCode = _removes[_index++];
        ngDevMode && assertNumber(removeOpCode, 'Expecting OpCode number');
        if (removeOpCode > 0) {
          const rNode = _lView[removeOpCode];
          ngDevMode && assertDomNode(rNode);
          return rNode;
        } else {
          _stack.push(_index, _removes);
          const tIcuIndex = ~removeOpCode;
          const tIcu = _lView[TVIEW].data[tIcuIndex];
          ngDevMode && assertTIcu(tIcu);
          enterIcu(tIcu, _lView);
          return icuContainerIteratorNext();
        }
      } else {
        if (_stack.length === 0) {
          return null;
        } else {
          _removes = _stack.pop();
          _index = _stack.pop();
          return icuContainerIteratorNext();
        }
      }
    }
    return icuContainerIteratorStart;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function i18nCreateOpCodesToString(opcodes) {
    const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
    let lines = [];
    for (let i = 0; i < createOpCodes.length; i++) {
      const opCode = createOpCodes[i++];
      const text = createOpCodes[i];
      const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
      const appendNow =
          (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
      const index = opCode >>> I18nCreateOpCode.SHIFT;
      lines.push(`lView[${index}] = document.${isComment ? 'createComment' : 'createText'}(${
          JSON.stringify(text)});`);
      if (appendNow) {
        lines.push(`parent.appendChild(lView[${index}]);`);
      }
    }
    return lines;
  }
  function i18nUpdateOpCodesToString(opcodes) {
    const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
    let lines = [];
    function consumeOpCode(value) {
      const ref = value >>> 2;
      const opCode = value & 3;
      switch (opCode) {
        case 0:
          return `(lView[${ref}] as Text).textContent = $$$`;
        case 1:
          const attrName = parser.consumeString();
          const sanitizationFn = parser.consumeFunction();
          const value2 = sanitizationFn ? `(${sanitizationFn})($$$)` : '$$$';
          return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value2})`;
        case 2:
          return `icuSwitchCase(${ref}, $$$)`;
        case 3:
          return `icuUpdateCase(${ref})`;
      }
      throw new Error('unexpected OpCode');
    }
    while (parser.hasMore()) {
      let mask = parser.consumeNumber();
      let size = parser.consumeNumber();
      const end = parser.i + size;
      const statements = [];
      let statement = '';
      while (parser.i < end) {
        let value = parser.consumeNumberOrString();
        if (typeof value === 'string') {
          statement += value;
        } else if (value < 0) {
          statement += '${lView[i' + value + ']}';
        } else {
          const opCodeText = consumeOpCode(value);
          statements.push(opCodeText.replace('$$$', '`' + statement + '`') + ';');
          statement = '';
        }
      }
      lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(' ')} }`);
    }
    return lines;
  }
  function icuCreateOpCodesToString(opcodes) {
    const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
    let lines = [];
    function consumeOpCode(opCode) {
      const parent = getParentFromIcuCreateOpCode(opCode);
      const ref = getRefFromIcuCreateOpCode(opCode);
      switch (getInstructionFromIcuCreateOpCode(opCode)) {
        case 0:
          return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;
        case 1:
          return `(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${
              parser.consumeString()}")`;
      }
      throw new Error('Unexpected OpCode: ' + getInstructionFromIcuCreateOpCode(opCode));
    }
    let lastRef = -1;
    while (parser.hasMore()) {
      let value = parser.consumeNumberStringOrMarker();
      if (value === ICU_MARKER) {
        const text = parser.consumeString();
        lastRef = parser.consumeNumber();
        lines.push(`lView[${lastRef}] = document.createComment("${text}")`);
      } else if (value === ELEMENT_MARKER) {
        const text = parser.consumeString();
        lastRef = parser.consumeNumber();
        lines.push(`lView[${lastRef}] = document.createElement("${text}")`);
      } else if (typeof value === 'string') {
        lastRef = parser.consumeNumber();
        lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);
      } else if (typeof value === 'number') {
        const line = consumeOpCode(value);
        line && lines.push(line);
      } else {
        throw new Error('Unexpected value');
      }
    }
    return lines;
  }
  function i18nRemoveOpCodesToString(opcodes) {
    const removeCodes = opcodes || (Array.isArray(this) ? this : []);
    let lines = [];
    for (let i = 0; i < removeCodes.length; i++) {
      const nodeOrIcuIndex = removeCodes[i];
      if (nodeOrIcuIndex > 0) {
        lines.push(`remove(lView[${nodeOrIcuIndex}])`);
      } else {
        lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
      }
    }
    return lines;
  }
  var OpCodeParser = class {
    constructor(codes) {
      this.i = 0;
      this.codes = codes;
    }
    hasMore() {
      return this.i < this.codes.length;
    }
    consumeNumber() {
      let value = this.codes[this.i++];
      assertNumber(value, 'expecting number in OpCode');
      return value;
    }
    consumeString() {
      let value = this.codes[this.i++];
      assertString(value, 'expecting string in OpCode');
      return value;
    }
    consumeFunction() {
      let value = this.codes[this.i++];
      if (value === null || typeof value === 'function') {
        return value;
      }
      throw new Error('expecting function in OpCode');
    }
    consumeNumberOrString() {
      let value = this.codes[this.i++];
      if (typeof value === 'string') {
        return value;
      }
      assertNumber(value, 'expecting number or string in OpCode');
      return value;
    }
    consumeNumberStringOrMarker() {
      let value = this.codes[this.i++];
      if (typeof value === 'string' || typeof value === 'number' || value == ICU_MARKER ||
          value == ELEMENT_MARKER) {
        return value;
      }
      assertNumber(value, 'expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode');
      return value;
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var BINDING_REGEXP = /�(\d+):?\d*�/gi;
  var ICU_REGEXP = /({\s*�\d+:?\d*�\s*,\s*\S{6}\s*,[\s\S]*})/gi;
  var NESTED_ICU = /�(\d+)�/;
  var ICU_BLOCK_REGEXP = /^\s*(�\d+:?\d*�)\s*,\s*(select|plural)\s*,/;
  var MARKER = `\uFFFD`;
  var SUBTEMPLATE_REGEXP = /�\/?\*(\d+:\d+)�/gi;
  var PH_REGEXP = /�(\/?[#*]\d+):?\d*�/gi;
  var NGSP_UNICODE_REGEXP = /\uE500/g;
  function replaceNgsp(value) {
    return value.replace(NGSP_UNICODE_REGEXP, ' ');
  }
  function i18nStartFirstCreatePass(
      tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {
    const rootTNode = getCurrentParentTNode();
    const createOpCodes = [];
    const updateOpCodes = [];
    const existingTNodeStack = [[]];
    if (ngDevMode) {
      attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
      attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
    }
    message = getTranslationForTemplate(message, subTemplateIndex);
    const msgParts = replaceNgsp(message).split(PH_REGEXP);
    for (let i = 0; i < msgParts.length; i++) {
      let value = msgParts[i];
      if ((i & 1) === 0) {
        const parts = i18nParseTextIntoPartsAndICU(value);
        for (let j = 0; j < parts.length; j++) {
          let part = parts[j];
          if ((j & 1) === 0) {
            const text = part;
            ngDevMode && assertString(text, 'Parsed ICU part should be string');
            if (text !== '') {
              i18nStartFirstCreatePassProcessTextNode(
                  tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView,
                  text);
            }
          } else {
            const icuExpression = part;
            if (typeof icuExpression !== 'object') {
              throw new Error(`Unable to parse ICU expression in "${message}" message.`);
            }
            const icuContainerTNode = createTNodeAndAddOpCode(
                tView, rootTNode, existingTNodeStack[0], lView, createOpCodes,
                ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '', true);
            const icuNodeIndex = icuContainerTNode.index;
            ngDevMode &&
                assertGreaterThanOrEqual(
                    icuNodeIndex, HEADER_OFFSET, 'Index must be in absolute LView offset');
            icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
          }
        }
      } else {
        const isClosing = value.charCodeAt(0) === 47;
        const type = value.charCodeAt(isClosing ? 1 : 0);
        ngDevMode && assertOneOf(type, 42, 35);
        const index2 = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));
        if (isClosing) {
          existingTNodeStack.shift();
          setCurrentTNode(getCurrentParentTNode(), false);
        } else {
          const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index2);
          existingTNodeStack.unshift([]);
          setCurrentTNode(tNode, true);
        }
      }
    }
    tView.data[index] = {create: createOpCodes, update: updateOpCodes};
  }
  function createTNodeAndAddOpCode(
      tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {
    const i18nNodeIdx = allocExpando(tView, lView, 1, null);
    let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
    let parentTNode = getCurrentParentTNode();
    if (rootTNode === parentTNode) {
      parentTNode = null;
    }
    if (parentTNode === null) {
      opCode |= I18nCreateOpCode.APPEND_EAGERLY;
    }
    if (isICU) {
      opCode |= I18nCreateOpCode.COMMENT;
      ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
    }
    createOpCodes.push(opCode, text === null ? '' : text);
    const tNode = createTNodeAtIndex(
        tView, i18nNodeIdx, isICU ? 32 : 1, text === null ? ngDevMode ? '{{?}}' : '' : text, null);
    addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
    const tNodeIdx = tNode.index;
    setCurrentTNode(tNode, false);
    if (parentTNode !== null && rootTNode !== parentTNode) {
      setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
    }
    return tNode;
  }
  function i18nStartFirstCreatePassProcessTextNode(
      tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {
    const hasBinding = text.match(BINDING_REGEXP);
    const tNode = createTNodeAndAddOpCode(
        tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);
    if (hasBinding) {
      generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index);
    }
  }
  function i18nAttributesFirstPass(tView, index, values) {
    const previousElement = getCurrentTNode();
    const previousElementIndex = previousElement.index;
    const updateOpCodes = [];
    if (ngDevMode) {
      attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
    }
    if (tView.firstCreatePass && tView.data[index] === null) {
      for (let i = 0; i < values.length; i += 2) {
        const attrName = values[i];
        const message = values[i + 1];
        if (message !== '') {
          if (ICU_REGEXP.test(message)) {
            throw new Error(
                `ICU expressions are not supported in attributes. Message: "${message}".`);
          }
          generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName);
        }
      }
      tView.data[index] = updateOpCodes;
    }
  }
  function generateBindingUpdateOpCodes(
      updateOpCodes, str, destinationNode, attrName, sanitizeFn = null) {
    ngDevMode &&
        assertGreaterThanOrEqual(
            destinationNode, HEADER_OFFSET, 'Index must be in absolute LView offset');
    const maskIndex = updateOpCodes.length;
    const sizeIndex = maskIndex + 1;
    updateOpCodes.push(null, null);
    const startIndex = maskIndex + 2;
    if (ngDevMode) {
      attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
    }
    const textParts = str.split(BINDING_REGEXP);
    let mask = 0;
    for (let j = 0; j < textParts.length; j++) {
      const textValue = textParts[j];
      if (j & 1) {
        const bindingIndex = parseInt(textValue, 10);
        updateOpCodes.push(-1 - bindingIndex);
        mask = mask | toMaskBit(bindingIndex);
      } else if (textValue !== '') {
        updateOpCodes.push(textValue);
      }
    }
    updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
    if (attrName) {
      updateOpCodes.push(attrName, sanitizeFn);
    }
    updateOpCodes[maskIndex] = mask;
    updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
    return mask;
  }
  function toMaskBit(bindingIndex) {
    return 1 << Math.min(bindingIndex, 31);
  }
  function isRootTemplateMessage(subTemplateIndex) {
    return subTemplateIndex === -1;
  }
  function removeInnerTemplateTranslation(message) {
    let match2;
    let res = '';
    let index = 0;
    let inTemplate = false;
    let tagMatched;
    while ((match2 = SUBTEMPLATE_REGEXP.exec(message)) !== null) {
      if (!inTemplate) {
        res += message.substring(index, match2.index + match2[0].length);
        tagMatched = match2[1];
        inTemplate = true;
      } else {
        if (match2[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
          index = match2.index;
          inTemplate = false;
        }
      }
    }
    ngDevMode &&
        assertEqual(
            inTemplate, false,
            `Tag mismatch: unable to find the end of the sub-template in the translation "${
                message}"`);
    res += message.substr(index);
    return res;
  }
  function getTranslationForTemplate(message, subTemplateIndex) {
    if (isRootTemplateMessage(subTemplateIndex)) {
      return removeInnerTemplateTranslation(message);
    } else {
      const start =
          message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
      const end = message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
      return removeInnerTemplateTranslation(message.substring(start, end));
    }
  }
  function icuStart(tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
    ngDevMode && assertDefined(icuExpression, 'ICU expression must be defined');
    let bindingMask = 0;
    const tIcu = {
      type: icuExpression.type,
      currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
      anchorIdx,
      cases: [],
      create: [],
      remove: [],
      update: []
    };
    addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
    setTIcu(tView, anchorIdx, tIcu);
    const values = icuExpression.values;
    for (let i = 0; i < values.length; i++) {
      const valueArr = values[i];
      const nestedIcus = [];
      for (let j = 0; j < valueArr.length; j++) {
        const value = valueArr[j];
        if (typeof value !== 'string') {
          const icuIndex = nestedIcus.push(value) - 1;
          valueArr[j] = `<!--\uFFFD${icuIndex}\uFFFD-->`;
        }
      }
      bindingMask = parseIcuCase(
                        tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i],
                        valueArr.join(''), nestedIcus) |
          bindingMask;
    }
    if (bindingMask) {
      addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
    }
  }
  function parseICUBlock(pattern) {
    const cases = [];
    const values = [];
    let icuType = 1;
    let mainBinding = 0;
    pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str, binding, type) {
      if (type === 'select') {
        icuType = 0;
      } else {
        icuType = 1;
      }
      mainBinding = parseInt(binding.substr(1), 10);
      return '';
    });
    const parts = i18nParseTextIntoPartsAndICU(pattern);
    for (let pos = 0; pos < parts.length;) {
      let key = parts[pos++].trim();
      if (icuType === 1) {
        key = key.replace(/\s*(?:=)?(\w+)\s*/, '$1');
      }
      if (key.length) {
        cases.push(key);
      }
      const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
      if (cases.length > values.length) {
        values.push(blocks);
      }
    }
    return {type: icuType, mainBinding, cases, values};
  }
  function i18nParseTextIntoPartsAndICU(pattern) {
    if (!pattern) {
      return [];
    }
    let prevPos = 0;
    const braceStack = [];
    const results = [];
    const braces = /[{}]/g;
    braces.lastIndex = 0;
    let match2;
    while (match2 = braces.exec(pattern)) {
      const pos = match2.index;
      if (match2[0] == '}') {
        braceStack.pop();
        if (braceStack.length == 0) {
          const block = pattern.substring(prevPos, pos);
          if (ICU_BLOCK_REGEXP.test(block)) {
            results.push(parseICUBlock(block));
          } else {
            results.push(block);
          }
          prevPos = pos + 1;
        }
      } else {
        if (braceStack.length == 0) {
          const substring2 = pattern.substring(prevPos, pos);
          results.push(substring2);
          prevPos = pos + 1;
        }
        braceStack.push('{');
      }
    }
    const substring = pattern.substring(prevPos);
    results.push(substring);
    return results;
  }
  function parseIcuCase(
      tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
    const create = [];
    const remove2 = [];
    const update = [];
    if (ngDevMode) {
      attachDebugGetter(create, icuCreateOpCodesToString);
      attachDebugGetter(remove2, i18nRemoveOpCodesToString);
      attachDebugGetter(update, i18nUpdateOpCodesToString);
    }
    tIcu.cases.push(caseName);
    tIcu.create.push(create);
    tIcu.remove.push(remove2);
    tIcu.update.push(update);
    const inertBodyHelper2 = getInertBodyHelper(getDocument());
    const inertBodyElement = inertBodyHelper2.getInertBodyElement(unsafeCaseHtml);
    ngDevMode && assertDefined(inertBodyElement, 'Unable to generate inert body element');
    const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
    if (inertRootNode) {
      return walkIcuTree(
          tView, tIcu, lView, updateOpCodes, create, remove2, update, inertRootNode, parentIdx,
          nestedIcus, 0);
    } else {
      return 0;
    }
  }
  function walkIcuTree(
      tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, parentNode, parentIdx,
      nestedIcus, depth) {
    let bindingMask = 0;
    let currentNode = parentNode.firstChild;
    while (currentNode) {
      const newIndex = allocExpando(tView, lView, 1, null);
      switch (currentNode.nodeType) {
        case Node.ELEMENT_NODE:
          const element = currentNode;
          const tagName = element.tagName.toLowerCase();
          if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
            addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);
            tView.data[newIndex] = tagName;
            const elAttrs = element.attributes;
            for (let i = 0; i < elAttrs.length; i++) {
              const attr = elAttrs.item(i);
              const lowerAttrName = attr.name.toLowerCase();
              const hasBinding2 = !!attr.value.match(BINDING_REGEXP);
              if (hasBinding2) {
                if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                  if (URI_ATTRS[lowerAttrName]) {
                    generateBindingUpdateOpCodes(
                        update, attr.value, newIndex, attr.name, _sanitizeUrl);
                  } else if (SRCSET_ATTRS[lowerAttrName]) {
                    generateBindingUpdateOpCodes(
                        update, attr.value, newIndex, attr.name, sanitizeSrcset);
                  } else {
                    generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name);
                  }
                } else {
                  ngDevMode &&
                      console.warn(`WARNING: ignoring unsafe attribute value ${
                          lowerAttrName} on element ${tagName} (see https://g.co/ng/security#xss)`);
                }
              } else {
                addCreateAttribute(create, newIndex, attr);
              }
            }
            bindingMask = walkIcuTree(
                              tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update,
                              currentNode, newIndex, nestedIcus, depth + 1) |
                bindingMask;
            addRemoveNode(remove2, newIndex, depth);
          }
          break;
        case Node.TEXT_NODE:
          const value = currentNode.textContent || '';
          const hasBinding = value.match(BINDING_REGEXP);
          addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);
          addRemoveNode(remove2, newIndex, depth);
          if (hasBinding) {
            bindingMask = generateBindingUpdateOpCodes(update, value, newIndex) | bindingMask;
          }
          break;
        case Node.COMMENT_NODE:
          const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');
          if (isNestedIcu) {
            const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
            const icuExpression = nestedIcus[nestedIcuIndex];
            addCreateNodeAndAppend(
                create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : '', parentIdx,
                newIndex);
            icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
            addRemoveNestedIcu(remove2, newIndex, depth);
          }
          break;
      }
      currentNode = currentNode.nextSibling;
    }
    return bindingMask;
  }
  function addRemoveNode(remove2, index, depth) {
    if (depth === 0) {
      remove2.push(index);
    }
  }
  function addRemoveNestedIcu(remove2, index, depth) {
    if (depth === 0) {
      remove2.push(~index);
      remove2.push(index);
    }
  }
  function addUpdateIcuSwitch(update, icuExpression, index) {
    update.push(
        toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding, index << 2 | 2);
  }
  function addUpdateIcuUpdate(update, bindingMask, index) {
    update.push(bindingMask, 1, index << 2 | 3);
  }
  function addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {
    if (marker !== null) {
      create.push(marker);
    }
    create.push(text, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));
  }
  function addCreateAttribute(create, newIndex, attr) {
    create.push(newIndex << 1 | 1, attr.name, attr.value);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ROOT_TEMPLATE_ID = 0;
  var PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]/;
  var PP_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]|(�\/?\*\d+:\d+�)/g;
  var PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
  var PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
  var PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\d+)?)�/g;
  var PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
  var PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
  function i18nPostprocess(message, replacements = {}) {
    let result = message;
    if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
      const matches = {};
      const templateIdsStack = [ROOT_TEMPLATE_ID];
      result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {
        const content = phs || tmpl;
        const placeholders = matches[content] || [];
        if (!placeholders.length) {
          content.split('|').forEach((placeholder2) => {
            const match2 = placeholder2.match(PP_TEMPLATE_ID_REGEXP);
            const templateId2 = match2 ? parseInt(match2[1], 10) : ROOT_TEMPLATE_ID;
            const isCloseTemplateTag2 = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder2);
            placeholders.push([templateId2, isCloseTemplateTag2, placeholder2]);
          });
          matches[content] = placeholders;
        }
        if (!placeholders.length) {
          throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);
        }
        const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
        let idx = 0;
        for (let i = 0; i < placeholders.length; i++) {
          if (placeholders[i][0] === currentTemplateId) {
            idx = i;
            break;
          }
        }
        const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
        if (isCloseTemplateTag) {
          templateIdsStack.pop();
        } else if (currentTemplateId !== templateId) {
          templateIdsStack.push(templateId);
        }
        placeholders.splice(idx, 1);
        return placeholder;
      });
    }
    if (!Object.keys(replacements).length) {
      return result;
    }
    result = result.replace(PP_ICU_VARS_REGEXP, (match2, start, key, _type, _idx, end) => {
      return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match2;
    });
    result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match2, key) => {
      return replacements.hasOwnProperty(key) ? replacements[key] : match2;
    });
    result = result.replace(PP_ICUS_REGEXP, (match2, key) => {
      if (replacements.hasOwnProperty(key)) {
        const list = replacements[key];
        if (!list.length) {
          throw new Error(`i18n postprocess: unmatched ICU - ${match2} with key: ${key}`);
        }
        return list.shift();
      }
      return match2;
    });
    return result;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex = -1) {
    const tView = getTView();
    const lView = getLView();
    const adjustedIndex = HEADER_OFFSET + index;
    ngDevMode && assertDefined(tView, `tView should be defined`);
    const message = getConstant(tView.consts, messageIndex);
    const parentTNode = getCurrentParentTNode();
    if (tView.firstCreatePass) {
      i18nStartFirstCreatePass(
          tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message,
          subTemplateIndex);
    }
    const tI18n = tView.data[adjustedIndex];
    const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;
    const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
    const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
    applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
    setInI18nBlock(true);
  }
  function \u0275\u0275i18nEnd() {
    setInI18nBlock(false);
  }
  function \u0275\u0275i18n(index, messageIndex, subTemplateIndex) {
    \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex);
    \u0275\u0275i18nEnd();
  }
  function \u0275\u0275i18nAttributes(index, attrsIndex) {
    const tView = getTView();
    ngDevMode && assertDefined(tView, `tView should be defined`);
    const attrs = getConstant(tView.consts, attrsIndex);
    i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);
  }
  function \u0275\u0275i18nExp(value) {
    const lView = getLView();
    setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));
    return \u0275\u0275i18nExp;
  }
  function \u0275\u0275i18nApply(index) {
    applyI18n(getTView(), getLView(), index + HEADER_OFFSET);
  }
  function \u0275\u0275i18nPostprocess(message, replacements = {}) {
    return i18nPostprocess(message, replacements);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function providersResolver(def, providers, viewProviders) {
    const tView = getTView();
    if (tView.firstCreatePass) {
      const isComponent = isComponentDef(def);
      resolveProvider$1(viewProviders, tView.data, tView.blueprint, isComponent, true);
      resolveProvider$1(providers, tView.data, tView.blueprint, isComponent, false);
    }
  }
  function resolveProvider$1(
      provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {
    provider = resolveForwardRef(provider);
    if (Array.isArray(provider)) {
      for (let i = 0; i < provider.length; i++) {
        resolveProvider$1(
            provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);
      }
    } else {
      const tView = getTView();
      const lView = getLView();
      let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);
      let providerFactory = providerToFactory(provider);
      const tNode = getCurrentTNode();
      const beginIndex = tNode.providerIndexes & 1048575;
      const endIndex = tNode.directiveStart;
      const cptViewProvidersCount = tNode.providerIndexes >> 20;
      if (isTypeProvider(provider) || !provider.multi) {
        const factory =
            new NodeInjectorFactory(providerFactory, isViewProvider, \u0275\u0275directiveInject);
        const existingFactoryIndex = indexOf(
            token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount,
            endIndex);
        if (existingFactoryIndex === -1) {
          diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
          registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
          tInjectables.push(token);
          tNode.directiveStart++;
          tNode.directiveEnd++;
          if (isViewProvider) {
            tNode.providerIndexes += 1048576;
          }
          lInjectablesBlueprint.push(factory);
          lView.push(factory);
        } else {
          lInjectablesBlueprint[existingFactoryIndex] = factory;
          lView[existingFactoryIndex] = factory;
        }
      } else {
        const existingProvidersFactoryIndex =
            indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
        const existingViewProvidersFactoryIndex =
            indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
        const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 &&
            lInjectablesBlueprint[existingProvidersFactoryIndex];
        const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 &&
            lInjectablesBlueprint[existingViewProvidersFactoryIndex];
        if (isViewProvider && !doesViewProvidersFactoryExist ||
            !isViewProvider && !doesProvidersFactoryExist) {
          diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
          const factory = multiFactory(
              isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver,
              lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);
          if (!isViewProvider && doesViewProvidersFactoryExist) {
            lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
          }
          registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
          tInjectables.push(token);
          tNode.directiveStart++;
          tNode.directiveEnd++;
          if (isViewProvider) {
            tNode.providerIndexes += 1048576;
          }
          lInjectablesBlueprint.push(factory);
          lView.push(factory);
        } else {
          const indexInFactory = multiFactoryAdd(
              lInjectablesBlueprint
                  [isViewProvider ? existingViewProvidersFactoryIndex :
                                    existingProvidersFactoryIndex],
              providerFactory, !isViewProvider && isComponent);
          registerDestroyHooksIfSupported(
              tView, provider,
              existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex :
                                                   existingViewProvidersFactoryIndex,
              indexInFactory);
        }
        if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {
          lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
        }
      }
    }
  }
  function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
    const providerIsTypeProvider = isTypeProvider(provider);
    if (providerIsTypeProvider || isClassProvider(provider)) {
      const prototype = (provider.useClass || provider).prototype;
      const ngOnDestroy = prototype.ngOnDestroy;
      if (ngOnDestroy) {
        const hooks = tView.destroyHooks || (tView.destroyHooks = []);
        if (!providerIsTypeProvider && provider.multi) {
          ngDevMode &&
              assertDefined(
                  indexInFactory, 'indexInFactory when registering multi factory destroy hook');
          const existingCallbacksIndex = hooks.indexOf(contextIndex);
          if (existingCallbacksIndex === -1) {
            hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);
          } else {
            hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
          }
        } else {
          hooks.push(contextIndex, ngOnDestroy);
        }
      }
    }
  }
  function multiFactoryAdd(multiFactory2, factory, isComponentProvider) {
    if (isComponentProvider) {
      multiFactory2.componentProviders++;
    }
    return multiFactory2.multi.push(factory) - 1;
  }
  function indexOf(item, arr, begin, end) {
    for (let i = begin; i < end; i++) {
      if (arr[i] === item) return i;
    }
    return -1;
  }
  function multiProvidersFactoryResolver(_, tData, lData, tNode) {
    return multiResolve(this.multi, []);
  }
  function multiViewProvidersFactoryResolver(_, tData, lView, tNode) {
    const factories = this.multi;
    let result;
    if (this.providerFactory) {
      const componentCount = this.providerFactory.componentProviders;
      const multiProviders =
          getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);
      result = multiProviders.slice(0, componentCount);
      multiResolve(factories, result);
      for (let i = componentCount; i < multiProviders.length; i++) {
        result.push(multiProviders[i]);
      }
    } else {
      result = [];
      multiResolve(factories, result);
    }
    return result;
  }
  function multiResolve(factories, result) {
    for (let i = 0; i < factories.length; i++) {
      const factory = factories[i];
      result.push(factory());
    }
    return result;
  }
  function multiFactory(factoryFn, index, isViewProvider, isComponent, f) {
    const factory = new NodeInjectorFactory(factoryFn, isViewProvider, \u0275\u0275directiveInject);
    factory.multi = [];
    factory.index = index;
    factory.componentProviders = 0;
    multiFactoryAdd(factory, f, isComponent && !isViewProvider);
    return factory;
  }
  function \u0275\u0275ProvidersFeature(providers, viewProviders = []) {
    return (definition) => {
      definition.providersResolver = (def, processProvidersFn) => {
        return providersResolver(
            def, processProvidersFn ? processProvidersFn(providers) : providers, viewProviders);
      };
    };
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ComponentRef = class {};
  var ComponentFactory = class {};
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function noComponentFactoryError(component) {
    const error = Error(`No component factory found for ${
        stringify(component)}. Did you add it to @NgModule.entryComponents?`);
    error[ERROR_COMPONENT] = component;
    return error;
  }
  var ERROR_COMPONENT = 'ngComponent';
  var _NullComponentFactoryResolver = class {
    resolveComponentFactory(component) {
      throw noComponentFactoryError(component);
    }
  };
  var ComponentFactoryResolver = class {};
  ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function noop2(...args) {}
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function injectElementRef() {
    return createElementRef(getCurrentTNode(), getLView());
  }
  function createElementRef(tNode, lView) {
    return new ElementRef(getNativeByTNode(tNode, lView));
  }
  var SWITCH_ELEMENT_REF_FACTORY__POST_R3__ = injectElementRef;
  var SWITCH_ELEMENT_REF_FACTORY = SWITCH_ELEMENT_REF_FACTORY__POST_R3__;
  var ElementRef = class {
    constructor(nativeElement) {
      this.nativeElement = nativeElement;
    }
  };
  ElementRef.__NG_ELEMENT_ID__ = SWITCH_ELEMENT_REF_FACTORY;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var Renderer2Interceptor = new InjectionToken('Renderer2Interceptor');
  var RendererFactory2 = class {};
  var Renderer2 = class {};
  Renderer2.__NG_ELEMENT_ID__ = () => SWITCH_RENDERER2_FACTORY();
  var SWITCH_RENDERER2_FACTORY__POST_R3__ = injectRenderer2;
  var SWITCH_RENDERER2_FACTORY = SWITCH_RENDERER2_FACTORY__POST_R3__;
  function getOrCreateRenderer2(lView) {
    const renderer = lView[RENDERER];
    if (ngDevMode && !isProceduralRenderer(renderer)) {
      throw new Error('Cannot inject Renderer2 when the application uses Renderer3!');
    }
    return renderer;
  }
  function injectRenderer2() {
    const lView = getLView();
    const tNode = getCurrentTNode();
    const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);
    return getOrCreateRenderer2(isLView(nodeAtIndex) ? nodeAtIndex : lView);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var Sanitizer = class {};
  Sanitizer.\u0275prov =
      \u0275\u0275defineInjectable({token: Sanitizer, providedIn: 'root', factory: () => null});
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var Version = class {
    constructor(full) {
      this.full = full;
      this.major = full.split('.')[0];
      this.minor = full.split('.')[1];
      this.patch = full.split('.').slice(2).join('.');
    }
  };
  var VERSION = new Version('11.0.9');
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var DefaultIterableDifferFactory = class {
    constructor() {}
    supports(obj) {
      return isListLikeIterable(obj);
    }
    create(trackByFn) {
      return new DefaultIterableDiffer(trackByFn);
    }
  };
  var trackByIdentity = (index, item) => item;
  var DefaultIterableDiffer = class {
    constructor(trackByFn) {
      this.length = 0;
      this._linkedRecords = null;
      this._unlinkedRecords = null;
      this._previousItHead = null;
      this._itHead = null;
      this._itTail = null;
      this._additionsHead = null;
      this._additionsTail = null;
      this._movesHead = null;
      this._movesTail = null;
      this._removalsHead = null;
      this._removalsTail = null;
      this._identityChangesHead = null;
      this._identityChangesTail = null;
      this._trackByFn = trackByFn || trackByIdentity;
    }
    forEachItem(fn) {
      let record;
      for (record = this._itHead; record !== null; record = record._next) {
        fn(record);
      }
    }
    forEachOperation(fn) {
      let nextIt = this._itHead;
      let nextRemove = this._removalsHead;
      let addRemoveOffset = 0;
      let moveOffsets = null;
      while (nextIt || nextRemove) {
        const record = !nextRemove ||
                nextIt &&
                    nextIt.currentIndex <
                        getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?
            nextIt :
            nextRemove;
        const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
        const currentIndex = record.currentIndex;
        if (record === nextRemove) {
          addRemoveOffset--;
          nextRemove = nextRemove._nextRemoved;
        } else {
          nextIt = nextIt._next;
          if (record.previousIndex == null) {
            addRemoveOffset++;
          } else {
            if (!moveOffsets) moveOffsets = [];
            const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
            const localCurrentIndex = currentIndex - addRemoveOffset;
            if (localMovePreviousIndex != localCurrentIndex) {
              for (let i = 0; i < localMovePreviousIndex; i++) {
                const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;
                const index = offset + i;
                if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                  moveOffsets[i] = offset + 1;
                }
              }
              const previousIndex = record.previousIndex;
              moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
            }
          }
        }
        if (adjPreviousIndex !== currentIndex) {
          fn(record, adjPreviousIndex, currentIndex);
        }
      }
    }
    forEachPreviousItem(fn) {
      let record;
      for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
        fn(record);
      }
    }
    forEachAddedItem(fn) {
      let record;
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        fn(record);
      }
    }
    forEachMovedItem(fn) {
      let record;
      for (record = this._movesHead; record !== null; record = record._nextMoved) {
        fn(record);
      }
    }
    forEachRemovedItem(fn) {
      let record;
      for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
        fn(record);
      }
    }
    forEachIdentityChange(fn) {
      let record;
      for (record = this._identityChangesHead; record !== null;
           record = record._nextIdentityChange) {
        fn(record);
      }
    }
    diff(collection) {
      if (collection == null) collection = [];
      if (!isListLikeIterable(collection)) {
        throw new Error(`Error trying to diff '${
            stringify(collection)}'. Only arrays and iterables are allowed`);
      }
      if (this.check(collection)) {
        return this;
      } else {
        return null;
      }
    }
    onDestroy() {}
    check(collection) {
      this._reset();
      let record = this._itHead;
      let mayBeDirty = false;
      let index;
      let item;
      let itemTrackBy;
      if (Array.isArray(collection)) {
        this.length = collection.length;
        for (let index2 = 0; index2 < this.length; index2++) {
          item = collection[index2];
          itemTrackBy = this._trackByFn(index2, item);
          if (record === null || !Object.is(record.trackById, itemTrackBy)) {
            record = this._mismatch(record, item, itemTrackBy, index2);
            mayBeDirty = true;
          } else {
            if (mayBeDirty) {
              record = this._verifyReinsertion(record, item, itemTrackBy, index2);
            }
            if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
          }
          record = record._next;
        }
      } else {
        index = 0;
        iterateListLike(collection, (item2) => {
          itemTrackBy = this._trackByFn(index, item2);
          if (record === null || !Object.is(record.trackById, itemTrackBy)) {
            record = this._mismatch(record, item2, itemTrackBy, index);
            mayBeDirty = true;
          } else {
            if (mayBeDirty) {
              record = this._verifyReinsertion(record, item2, itemTrackBy, index);
            }
            if (!Object.is(record.item, item2)) this._addIdentityChange(record, item2);
          }
          record = record._next;
          index++;
        });
        this.length = index;
      }
      this._truncate(record);
      this.collection = collection;
      return this.isDirty;
    }
    get isDirty() {
      return this._additionsHead !== null || this._movesHead !== null ||
          this._removalsHead !== null || this._identityChangesHead !== null;
    }
    _reset() {
      if (this.isDirty) {
        let record;
        for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
          record._nextPrevious = record._next;
        }
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
          record.previousIndex = record.currentIndex;
        }
        this._additionsHead = this._additionsTail = null;
        for (record = this._movesHead; record !== null; record = record._nextMoved) {
          record.previousIndex = record.currentIndex;
        }
        this._movesHead = this._movesTail = null;
        this._removalsHead = this._removalsTail = null;
        this._identityChangesHead = this._identityChangesTail = null;
      }
    }
    _mismatch(record, item, itemTrackBy, index) {
      let previousRecord;
      if (record === null) {
        previousRecord = this._itTail;
      } else {
        previousRecord = record._prev;
        this._remove(record);
      }
      record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
      if (record !== null) {
        if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
        this._moveAfter(record, previousRecord, index);
      } else {
        record =
            this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
        if (record !== null) {
          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
          this._reinsertAfter(record, previousRecord, index);
        } else {
          record =
              this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
        }
      }
      return record;
    }
    _verifyReinsertion(record, item, itemTrackBy, index) {
      let reinsertRecord =
          this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
      if (reinsertRecord !== null) {
        record = this._reinsertAfter(reinsertRecord, record._prev, index);
      } else if (record.currentIndex != index) {
        record.currentIndex = index;
        this._addToMoves(record, index);
      }
      return record;
    }
    _truncate(record) {
      while (record !== null) {
        const nextRecord = record._next;
        this._addToRemovals(this._unlink(record));
        record = nextRecord;
      }
      if (this._unlinkedRecords !== null) {
        this._unlinkedRecords.clear();
      }
      if (this._additionsTail !== null) {
        this._additionsTail._nextAdded = null;
      }
      if (this._movesTail !== null) {
        this._movesTail._nextMoved = null;
      }
      if (this._itTail !== null) {
        this._itTail._next = null;
      }
      if (this._removalsTail !== null) {
        this._removalsTail._nextRemoved = null;
      }
      if (this._identityChangesTail !== null) {
        this._identityChangesTail._nextIdentityChange = null;
      }
    }
    _reinsertAfter(record, prevRecord, index) {
      if (this._unlinkedRecords !== null) {
        this._unlinkedRecords.remove(record);
      }
      const prev = record._prevRemoved;
      const next = record._nextRemoved;
      if (prev === null) {
        this._removalsHead = next;
      } else {
        prev._nextRemoved = next;
      }
      if (next === null) {
        this._removalsTail = prev;
      } else {
        next._prevRemoved = prev;
      }
      this._insertAfter(record, prevRecord, index);
      this._addToMoves(record, index);
      return record;
    }
    _moveAfter(record, prevRecord, index) {
      this._unlink(record);
      this._insertAfter(record, prevRecord, index);
      this._addToMoves(record, index);
      return record;
    }
    _addAfter(record, prevRecord, index) {
      this._insertAfter(record, prevRecord, index);
      if (this._additionsTail === null) {
        this._additionsTail = this._additionsHead = record;
      } else {
        this._additionsTail = this._additionsTail._nextAdded = record;
      }
      return record;
    }
    _insertAfter(record, prevRecord, index) {
      const next = prevRecord === null ? this._itHead : prevRecord._next;
      record._next = next;
      record._prev = prevRecord;
      if (next === null) {
        this._itTail = record;
      } else {
        next._prev = record;
      }
      if (prevRecord === null) {
        this._itHead = record;
      } else {
        prevRecord._next = record;
      }
      if (this._linkedRecords === null) {
        this._linkedRecords = new _DuplicateMap();
      }
      this._linkedRecords.put(record);
      record.currentIndex = index;
      return record;
    }
    _remove(record) {
      return this._addToRemovals(this._unlink(record));
    }
    _unlink(record) {
      if (this._linkedRecords !== null) {
        this._linkedRecords.remove(record);
      }
      const prev = record._prev;
      const next = record._next;
      if (prev === null) {
        this._itHead = next;
      } else {
        prev._next = next;
      }
      if (next === null) {
        this._itTail = prev;
      } else {
        next._prev = prev;
      }
      return record;
    }
    _addToMoves(record, toIndex) {
      if (record.previousIndex === toIndex) {
        return record;
      }
      if (this._movesTail === null) {
        this._movesTail = this._movesHead = record;
      } else {
        this._movesTail = this._movesTail._nextMoved = record;
      }
      return record;
    }
    _addToRemovals(record) {
      if (this._unlinkedRecords === null) {
        this._unlinkedRecords = new _DuplicateMap();
      }
      this._unlinkedRecords.put(record);
      record.currentIndex = null;
      record._nextRemoved = null;
      if (this._removalsTail === null) {
        this._removalsTail = this._removalsHead = record;
        record._prevRemoved = null;
      } else {
        record._prevRemoved = this._removalsTail;
        this._removalsTail = this._removalsTail._nextRemoved = record;
      }
      return record;
    }
    _addIdentityChange(record, item) {
      record.item = item;
      if (this._identityChangesTail === null) {
        this._identityChangesTail = this._identityChangesHead = record;
      } else {
        this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
      }
      return record;
    }
  };
  var IterableChangeRecord_ = class {
    constructor(item, trackById) {
      this.item = item;
      this.trackById = trackById;
      this.currentIndex = null;
      this.previousIndex = null;
      this._nextPrevious = null;
      this._prev = null;
      this._next = null;
      this._prevDup = null;
      this._nextDup = null;
      this._prevRemoved = null;
      this._nextRemoved = null;
      this._nextAdded = null;
      this._nextMoved = null;
      this._nextIdentityChange = null;
    }
  };
  var _DuplicateItemRecordList = class {
    constructor() {
      this._head = null;
      this._tail = null;
    }
    add(record) {
      if (this._head === null) {
        this._head = this._tail = record;
        record._nextDup = null;
        record._prevDup = null;
      } else {
        this._tail._nextDup = record;
        record._prevDup = this._tail;
        record._nextDup = null;
        this._tail = record;
      }
    }
    get(trackById, atOrAfterIndex) {
      let record;
      for (record = this._head; record !== null; record = record._nextDup) {
        if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) &&
            Object.is(record.trackById, trackById)) {
          return record;
        }
      }
      return null;
    }
    remove(record) {
      const prev = record._prevDup;
      const next = record._nextDup;
      if (prev === null) {
        this._head = next;
      } else {
        prev._nextDup = next;
      }
      if (next === null) {
        this._tail = prev;
      } else {
        next._prevDup = prev;
      }
      return this._head === null;
    }
  };
  var _DuplicateMap = class {
    constructor() {
      this.map = new Map();
    }
    put(record) {
      const key = record.trackById;
      let duplicates = this.map.get(key);
      if (!duplicates) {
        duplicates = new _DuplicateItemRecordList();
        this.map.set(key, duplicates);
      }
      duplicates.add(record);
    }
    get(trackById, atOrAfterIndex) {
      const key = trackById;
      const recordList = this.map.get(key);
      return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
    }
    remove(record) {
      const key = record.trackById;
      const recordList = this.map.get(key);
      if (recordList.remove(record)) {
        this.map.delete(key);
      }
      return record;
    }
    get isEmpty() {
      return this.map.size === 0;
    }
    clear() {
      this.map.clear();
    }
  };
  function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
    const previousIndex = item.previousIndex;
    if (previousIndex === null) return previousIndex;
    let moveOffset = 0;
    if (moveOffsets && previousIndex < moveOffsets.length) {
      moveOffset = moveOffsets[previousIndex];
    }
    return previousIndex + addRemoveOffset + moveOffset;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var DefaultKeyValueDifferFactory = class {
    constructor() {}
    supports(obj) {
      return obj instanceof Map || isJsObject(obj);
    }
    create() {
      return new DefaultKeyValueDiffer();
    }
  };
  var DefaultKeyValueDiffer = class {
    constructor() {
      this._records = new Map();
      this._mapHead = null;
      this._appendAfter = null;
      this._previousMapHead = null;
      this._changesHead = null;
      this._changesTail = null;
      this._additionsHead = null;
      this._additionsTail = null;
      this._removalsHead = null;
      this._removalsTail = null;
    }
    get isDirty() {
      return this._additionsHead !== null || this._changesHead !== null ||
          this._removalsHead !== null;
    }
    forEachItem(fn) {
      let record;
      for (record = this._mapHead; record !== null; record = record._next) {
        fn(record);
      }
    }
    forEachPreviousItem(fn) {
      let record;
      for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
        fn(record);
      }
    }
    forEachChangedItem(fn) {
      let record;
      for (record = this._changesHead; record !== null; record = record._nextChanged) {
        fn(record);
      }
    }
    forEachAddedItem(fn) {
      let record;
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        fn(record);
      }
    }
    forEachRemovedItem(fn) {
      let record;
      for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
        fn(record);
      }
    }
    diff(map2) {
      if (!map2) {
        map2 = new Map();
      } else if (!(map2 instanceof Map || isJsObject(map2))) {
        throw new Error(
            `Error trying to diff '${stringify(map2)}'. Only maps and objects are allowed`);
      }
      return this.check(map2) ? this : null;
    }
    onDestroy() {}
    check(map2) {
      this._reset();
      let insertBefore = this._mapHead;
      this._appendAfter = null;
      this._forEach(map2, (value, key) => {
        if (insertBefore && insertBefore.key === key) {
          this._maybeAddToChanges(insertBefore, value);
          this._appendAfter = insertBefore;
          insertBefore = insertBefore._next;
        } else {
          const record = this._getOrCreateRecordForKey(key, value);
          insertBefore = this._insertBeforeOrAppend(insertBefore, record);
        }
      });
      if (insertBefore) {
        if (insertBefore._prev) {
          insertBefore._prev._next = null;
        }
        this._removalsHead = insertBefore;
        for (let record = insertBefore; record !== null; record = record._nextRemoved) {
          if (record === this._mapHead) {
            this._mapHead = null;
          }
          this._records.delete(record.key);
          record._nextRemoved = record._next;
          record.previousValue = record.currentValue;
          record.currentValue = null;
          record._prev = null;
          record._next = null;
        }
      }
      if (this._changesTail) this._changesTail._nextChanged = null;
      if (this._additionsTail) this._additionsTail._nextAdded = null;
      return this.isDirty;
    }
    _insertBeforeOrAppend(before, record) {
      if (before) {
        const prev = before._prev;
        record._next = before;
        record._prev = prev;
        before._prev = record;
        if (prev) {
          prev._next = record;
        }
        if (before === this._mapHead) {
          this._mapHead = record;
        }
        this._appendAfter = before;
        return before;
      }
      if (this._appendAfter) {
        this._appendAfter._next = record;
        record._prev = this._appendAfter;
      } else {
        this._mapHead = record;
      }
      this._appendAfter = record;
      return null;
    }
    _getOrCreateRecordForKey(key, value) {
      if (this._records.has(key)) {
        const record2 = this._records.get(key);
        this._maybeAddToChanges(record2, value);
        const prev = record2._prev;
        const next = record2._next;
        if (prev) {
          prev._next = next;
        }
        if (next) {
          next._prev = prev;
        }
        record2._next = null;
        record2._prev = null;
        return record2;
      }
      const record = new KeyValueChangeRecord_(key);
      this._records.set(key, record);
      record.currentValue = value;
      this._addToAdditions(record);
      return record;
    }
    _reset() {
      if (this.isDirty) {
        let record;
        this._previousMapHead = this._mapHead;
        for (record = this._previousMapHead; record !== null; record = record._next) {
          record._nextPrevious = record._next;
        }
        for (record = this._changesHead; record !== null; record = record._nextChanged) {
          record.previousValue = record.currentValue;
        }
        for (record = this._additionsHead; record != null; record = record._nextAdded) {
          record.previousValue = record.currentValue;
        }
        this._changesHead = this._changesTail = null;
        this._additionsHead = this._additionsTail = null;
        this._removalsHead = null;
      }
    }
    _maybeAddToChanges(record, newValue) {
      if (!Object.is(newValue, record.currentValue)) {
        record.previousValue = record.currentValue;
        record.currentValue = newValue;
        this._addToChanges(record);
      }
    }
    _addToAdditions(record) {
      if (this._additionsHead === null) {
        this._additionsHead = this._additionsTail = record;
      } else {
        this._additionsTail._nextAdded = record;
        this._additionsTail = record;
      }
    }
    _addToChanges(record) {
      if (this._changesHead === null) {
        this._changesHead = this._changesTail = record;
      } else {
        this._changesTail._nextChanged = record;
        this._changesTail = record;
      }
    }
    _forEach(obj, fn) {
      if (obj instanceof Map) {
        obj.forEach(fn);
      } else {
        Object.keys(obj).forEach((k) => fn(obj[k], k));
      }
    }
  };
  var KeyValueChangeRecord_ = class {
    constructor(key) {
      this.key = key;
      this.previousValue = null;
      this.currentValue = null;
      this._nextPrevious = null;
      this._next = null;
      this._prev = null;
      this._nextAdded = null;
      this._nextRemoved = null;
      this._nextChanged = null;
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var IterableDiffers = class {
    constructor(factories) {
      this.factories = factories;
    }
    static create(factories, parent) {
      if (parent != null) {
        const copied = parent.factories.slice();
        factories = factories.concat(copied);
      }
      return new IterableDiffers(factories);
    }
    static extend(factories) {
      return {
        provide: IterableDiffers,
        useFactory: (parent) => {
          if (!parent) {
            throw new Error('Cannot extend IterableDiffers without a parent injector');
          }
          return IterableDiffers.create(factories, parent);
        },
        deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
      };
    }
    find(iterable) {
      const factory = this.factories.find((f) => f.supports(iterable));
      if (factory != null) {
        return factory;
      } else {
        throw new Error(`Cannot find a differ supporting object '${iterable}' of type '${
            getTypeNameForDebugging(iterable)}'`);
      }
    }
  };
  IterableDiffers.\u0275prov = \u0275\u0275defineInjectable({
    token: IterableDiffers,
    providedIn: 'root',
    factory: () => new IterableDiffers([new DefaultIterableDifferFactory()])
  });
  function getTypeNameForDebugging(type) {
    return type['name'] || typeof type;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var KeyValueDiffers = class {
    constructor(factories) {
      this.factories = factories;
    }
    static create(factories, parent) {
      if (parent) {
        const copied = parent.factories.slice();
        factories = factories.concat(copied);
      }
      return new KeyValueDiffers(factories);
    }
    static extend(factories) {
      return {
        provide: KeyValueDiffers,
        useFactory: (parent) => {
          if (!parent) {
            throw new Error('Cannot extend KeyValueDiffers without a parent injector');
          }
          return KeyValueDiffers.create(factories, parent);
        },
        deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
      };
    }
    find(kv) {
      const factory = this.factories.find((f) => f.supports(kv));
      if (factory) {
        return factory;
      }
      throw new Error(`Cannot find a differ supporting object '${kv}'`);
    }
  };
  KeyValueDiffers.\u0275prov = \u0275\u0275defineInjectable({
    token: KeyValueDiffers,
    providedIn: 'root',
    factory: () => new KeyValueDiffers([new DefaultKeyValueDifferFactory()])
  });
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
    while (tNode !== null) {
      ngDevMode && assertTNodeType(tNode, 3 | 12 | 16 | 32);
      const lNode = lView[tNode.index];
      if (lNode !== null) {
        result.push(unwrapRNode(lNode));
      }
      if (isLContainer(lNode)) {
        for (let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++) {
          const lViewInAContainer = lNode[i];
          const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
          if (lViewFirstChildTNode !== null) {
            collectNativeNodes(
                lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
          }
        }
      }
      const tNodeType = tNode.type;
      if (tNodeType & 8) {
        collectNativeNodes(tView, lView, tNode.child, result);
      } else if (tNodeType & 32) {
        const nextRNode = icuContainerIterate(tNode, lView);
        let rNode;
        while (rNode = nextRNode()) {
          result.push(rNode);
        }
      } else if (tNodeType & 16) {
        const componentView = lView[DECLARATION_COMPONENT_VIEW];
        const componentHost = componentView[T_HOST];
        const slotIdx = tNode.projection;
        ngDevMode &&
            assertDefined(
                componentHost.projection,
                'Components with projection nodes (<ng-content>) must have projection slots defined.');
        const nodesInSlot = componentHost.projection[slotIdx];
        if (Array.isArray(nodesInSlot)) {
          result.push(...nodesInSlot);
        } else {
          const parentView = getLViewParent(componentView);
          ngDevMode &&
              assertDefined(
                  parentView,
                  'Component views should always have a parent view (component\'s host view)');
          collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);
        }
      }
      tNode = isProjection ? tNode.projectionNext : tNode.next;
    }
    return result;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ViewRef = class {
    constructor(_lView, _cdRefInjectingView) {
      this._lView = _lView;
      this._cdRefInjectingView = _cdRefInjectingView;
      this._appRef = null;
      this._attachedToViewContainer = false;
    }
    get rootNodes() {
      const lView = this._lView;
      const tView = lView[TVIEW];
      return collectNativeNodes(tView, lView, tView.firstChild, []);
    }
    get context() {
      return this._lView[CONTEXT];
    }
    get destroyed() {
      return (this._lView[FLAGS] & 256) === 256;
    }
    destroy() {
      if (this._appRef) {
        this._appRef.detachView(this);
      } else if (this._attachedToViewContainer) {
        const parent = this._lView[PARENT];
        if (isLContainer(parent)) {
          const viewRefs = parent[VIEW_REFS];
          const index = viewRefs ? viewRefs.indexOf(this) : -1;
          if (index > -1) {
            ngDevMode &&
                assertEqual(
                    index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET,
                    'An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.');
            detachView(parent, index);
            removeFromArray(viewRefs, index);
          }
        }
        this._attachedToViewContainer = false;
      }
      destroyLView(this._lView[TVIEW], this._lView);
    }
    onDestroy(callback) {
      storeCleanupWithContext(this._lView[TVIEW], this._lView, null, callback);
    }
    markForCheck() {
      markViewDirty(this._cdRefInjectingView || this._lView);
    }
    detach() {
      this._lView[FLAGS] &= ~128;
    }
    reattach() {
      this._lView[FLAGS] |= 128;
    }
    detectChanges() {
      detectChangesInternal(this._lView[TVIEW], this._lView, this.context);
    }
    checkNoChanges() {
      checkNoChangesInternal(this._lView[TVIEW], this._lView, this.context);
    }
    attachToViewContainerRef() {
      if (this._appRef) {
        throw new Error('This view is already attached directly to the ApplicationRef!');
      }
      this._attachedToViewContainer = true;
    }
    detachFromAppRef() {
      this._appRef = null;
      renderDetachView(this._lView[TVIEW], this._lView);
    }
    attachToAppRef(appRef) {
      if (this._attachedToViewContainer) {
        throw new Error('This view is already attached to a ViewContainer!');
      }
      this._appRef = appRef;
    }
  };
  var RootViewRef = class extends ViewRef {
    constructor(_view) {
      super(_view);
      this._view = _view;
    }
    detectChanges() {
      detectChangesInRootView(this._view);
    }
    checkNoChanges() {
      checkNoChangesInRootView(this._view);
    }
    get context() {
      return null;
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var SWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__ = injectChangeDetectorRef;
  var SWITCH_CHANGE_DETECTOR_REF_FACTORY = SWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__;
  var ChangeDetectorRef = class {};
  ChangeDetectorRef.__NG_ELEMENT_ID__ = SWITCH_CHANGE_DETECTOR_REF_FACTORY;
  ChangeDetectorRef.__ChangeDetectorRef__ = true;
  function injectChangeDetectorRef(isPipe = false) {
    return createViewRef(getCurrentTNode(), getLView(), isPipe);
  }
  function createViewRef(tNode, lView, isPipe) {
    const isComponentView = !isPipe && isComponentHost(tNode);
    if (isComponentView) {
      const componentView = getComponentLViewByIndex(tNode.index, lView);
      return new ViewRef(componentView, componentView);
    } else if (tNode.type & (3 | 12 | 32)) {
      const hostComponentView = lView[DECLARATION_COMPONENT_VIEW];
      return new ViewRef(hostComponentView, lView);
    }
    return null;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var keyValDiff = [new DefaultKeyValueDifferFactory()];
  var iterableDiff = [new DefaultIterableDifferFactory()];
  var defaultIterableDiffers = new IterableDiffers(iterableDiff);
  var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var SWITCH_TEMPLATE_REF_FACTORY__POST_R3__ = injectTemplateRef;
  var SWITCH_TEMPLATE_REF_FACTORY = SWITCH_TEMPLATE_REF_FACTORY__POST_R3__;
  var TemplateRef = class {};
  TemplateRef.__NG_ELEMENT_ID__ = SWITCH_TEMPLATE_REF_FACTORY;
  var ViewEngineTemplateRef = TemplateRef;
  var R3TemplateRef = class TemplateRef2 extends ViewEngineTemplateRef {
    constructor(_declarationLView, _declarationTContainer, elementRef) {
      super();
      this._declarationLView = _declarationLView;
      this._declarationTContainer = _declarationTContainer;
      this.elementRef = elementRef;
    }
    createEmbeddedView(context) {
      const embeddedTView = this._declarationTContainer.tViews;
      const embeddedLView = createLView(
          this._declarationLView, embeddedTView, context, 16, null, embeddedTView.declTNode, null,
          null, null, null);
      const declarationLContainer = this._declarationLView[this._declarationTContainer.index];
      ngDevMode && assertLContainer(declarationLContainer);
      embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;
      const declarationViewLQueries = this._declarationLView[QUERIES];
      if (declarationViewLQueries !== null) {
        embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
      }
      renderView(embeddedTView, embeddedLView, context);
      return new ViewRef(embeddedLView);
    }
  };
  function injectTemplateRef() {
    return createTemplateRef(getCurrentTNode(), getLView());
  }
  function createTemplateRef(hostTNode, hostLView) {
    if (hostTNode.type & 4) {
      ngDevMode && assertDefined(hostTNode.tViews, 'TView must be allocated');
      return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
    }
    return null;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NgModuleRef = class {};
  var NgModuleFactory = class {};
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var SWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__ = injectViewContainerRef;
  var SWITCH_VIEW_CONTAINER_REF_FACTORY = SWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__;
  var ViewContainerRef = class {};
  ViewContainerRef.__NG_ELEMENT_ID__ = SWITCH_VIEW_CONTAINER_REF_FACTORY;
  function injectViewContainerRef() {
    const previousTNode = getCurrentTNode();
    return createContainerRef(previousTNode, getLView());
  }
  var VE_ViewContainerRef = ViewContainerRef;
  var R3ViewContainerRef = class ViewContainerRef2 extends VE_ViewContainerRef {
    constructor(_lContainer, _hostTNode, _hostLView) {
      super();
      this._lContainer = _lContainer;
      this._hostTNode = _hostTNode;
      this._hostLView = _hostLView;
    }
    get element() {
      return createElementRef(this._hostTNode, this._hostLView);
    }
    get injector() {
      return new NodeInjector(this._hostTNode, this._hostLView);
    }
    get parentInjector() {
      const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
      if (hasParentInjector(parentLocation)) {
        const parentView = getParentInjectorView(parentLocation, this._hostLView);
        const injectorIndex = getParentInjectorIndex(parentLocation);
        ngDevMode && assertNodeInjector(parentView, injectorIndex);
        const parentTNode = parentView[TVIEW].data[injectorIndex + 8];
        return new NodeInjector(parentTNode, parentView);
      } else {
        return new NodeInjector(null, this._hostLView);
      }
    }
    clear() {
      while (this.length > 0) {
        this.remove(this.length - 1);
      }
    }
    get(index) {
      const viewRefs = getViewRefs(this._lContainer);
      return viewRefs !== null && viewRefs[index] || null;
    }
    get length() {
      return this._lContainer.length - CONTAINER_HEADER_OFFSET;
    }
    createEmbeddedView(templateRef, context, index) {
      const viewRef = templateRef.createEmbeddedView(context || {});
      this.insert(viewRef, index);
      return viewRef;
    }
    createComponent(componentFactory, index, injector, projectableNodes, ngModuleRef) {
      const contextInjector = injector || this.parentInjector;
      if (!ngModuleRef && componentFactory.ngModule == null && contextInjector) {
        const result = contextInjector.get(NgModuleRef, null);
        if (result) {
          ngModuleRef = result;
        }
      }
      const componentRef =
          componentFactory.create(contextInjector, projectableNodes, void 0, ngModuleRef);
      this.insert(componentRef.hostView, index);
      return componentRef;
    }
    insert(viewRef, index) {
      const lView = viewRef._lView;
      const tView = lView[TVIEW];
      if (ngDevMode && viewRef.destroyed) {
        throw new Error('Cannot insert a destroyed View in a ViewContainer!');
      }
      if (viewAttachedToContainer(lView)) {
        const prevIdx = this.indexOf(viewRef);
        if (prevIdx !== -1) {
          this.detach(prevIdx);
        } else {
          const prevLContainer = lView[PARENT];
          ngDevMode &&
              assertEqual(
                  isLContainer(prevLContainer), true,
                  'An attached view should have its PARENT point to a container.');
          const prevVCRef = new R3ViewContainerRef(
              prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);
          prevVCRef.detach(prevVCRef.indexOf(viewRef));
        }
      }
      const adjustedIdx = this._adjustIndex(index);
      const lContainer = this._lContainer;
      insertView(tView, lView, lContainer, adjustedIdx);
      const beforeNode = getBeforeNodeForView(adjustedIdx, lContainer);
      const renderer = lView[RENDERER];
      const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);
      if (parentRNode !== null) {
        addViewToContainer(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);
      }
      viewRef.attachToViewContainerRef();
      addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
      return viewRef;
    }
    move(viewRef, newIndex) {
      if (ngDevMode && viewRef.destroyed) {
        throw new Error('Cannot move a destroyed View in a ViewContainer!');
      }
      return this.insert(viewRef, newIndex);
    }
    indexOf(viewRef) {
      const viewRefsArr = getViewRefs(this._lContainer);
      return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
    }
    remove(index) {
      const adjustedIdx = this._adjustIndex(index, -1);
      const detachedView = detachView(this._lContainer, adjustedIdx);
      if (detachedView) {
        removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);
        destroyLView(detachedView[TVIEW], detachedView);
      }
    }
    detach(index) {
      const adjustedIdx = this._adjustIndex(index, -1);
      const view = detachView(this._lContainer, adjustedIdx);
      const wasDetached =
          view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
      return wasDetached ? new ViewRef(view) : null;
    }
    _adjustIndex(index, shift = 0) {
      if (index == null) {
        return this.length + shift;
      }
      if (ngDevMode) {
        assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);
        assertLessThan(index, this.length + 1 + shift, 'index');
      }
      return index;
    }
  };
  function getViewRefs(lContainer) {
    return lContainer[VIEW_REFS];
  }
  function getOrCreateViewRefs(lContainer) {
    return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);
  }
  function createContainerRef(hostTNode, hostLView) {
    ngDevMode && assertTNodeType(hostTNode, 12 | 3);
    let lContainer;
    const slotValue = hostLView[hostTNode.index];
    if (isLContainer(slotValue)) {
      lContainer = slotValue;
    } else {
      let commentNode;
      if (hostTNode.type & 8) {
        commentNode = unwrapRNode(slotValue);
      } else {
        const renderer = hostLView[RENDERER];
        ngDevMode && ngDevMode.rendererCreateComment++;
        commentNode = renderer.createComment(ngDevMode ? 'container' : '');
        const hostNative = getNativeByTNode(hostTNode, hostLView);
        const parentOfHostNative = nativeParentNode(renderer, hostNative);
        nativeInsertBefore(
            renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative),
            false);
      }
      hostLView[hostTNode.index] = lContainer =
          createLContainer(slotValue, hostLView, commentNode, hostTNode);
      addToViewTree(hostLView, lContainer);
    }
    return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var _tokenKeyCache = new Map();
  function tokenKey(token) {
    let key = _tokenKeyCache.get(token);
    if (!key) {
      key = stringify(token) + '_' + _tokenKeyCache.size;
      _tokenKeyCache.set(token, key);
    }
    return key;
  }
  var DEFINITION_CACHE = new WeakMap();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var InjectorRefTokenKey = tokenKey(Injector);
  var INJECTORRefTokenKey = tokenKey(INJECTOR$1);
  var NgModuleRefTokenKey = tokenKey(NgModuleRef);
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var Renderer2TokenKey = tokenKey(Renderer2);
  var ElementRefTokenKey = tokenKey(ElementRef);
  var ViewContainerRefTokenKey = tokenKey(ViewContainerRef);
  var TemplateRefTokenKey = tokenKey(TemplateRef);
  var ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef);
  var InjectorRefTokenKey$1 = tokenKey(Injector);
  var INJECTORRefTokenKey$1 = tokenKey(INJECTOR$1);
  var NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ComponentFactoryResolver$1 = class extends ComponentFactoryResolver {
    constructor(ngModule) {
      super();
      this.ngModule = ngModule;
    }
    resolveComponentFactory(component) {
      ngDevMode && assertComponentType(component);
      const componentDef = getComponentDef(component);
      return new ComponentFactory$1(componentDef, this.ngModule);
    }
  };
  function toRefArray(map2) {
    const array = [];
    for (let nonMinified in map2) {
      if (map2.hasOwnProperty(nonMinified)) {
        const minified = map2[nonMinified];
        array.push({propName: minified, templateName: nonMinified});
      }
    }
    return array;
  }
  function getNamespace$1(elementName) {
    const name = elementName.toLowerCase();
    return name === 'svg' ? SVG_NAMESPACE : name === 'math' ? MATH_ML_NAMESPACE : null;
  }
  var SCHEDULER =
      new InjectionToken('SCHEDULER_TOKEN', {providedIn: 'root', factory: () => defaultScheduler});
  function createChainedInjector(rootViewInjector, moduleInjector) {
    return {
      get: (token, notFoundValue, flags) => {
        const value = rootViewInjector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
        if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||
            notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
          return value;
        }
        return moduleInjector.get(token, notFoundValue, flags);
      }
    };
  }
  var ComponentFactory$1 = class extends ComponentFactory {
    constructor(componentDef, ngModule) {
      super();
      this.componentDef = componentDef;
      this.ngModule = ngModule;
      this.componentType = componentDef.type;
      this.selector = stringifyCSSSelectorList(componentDef.selectors);
      this.ngContentSelectors =
          componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];
      this.isBoundToModule = !!ngModule;
    }
    get inputs() {
      return toRefArray(this.componentDef.inputs);
    }
    get outputs() {
      return toRefArray(this.componentDef.outputs);
    }
    create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
      ngModule = ngModule || this.ngModule;
      const rootViewInjector =
          ngModule ? createChainedInjector(injector, ngModule.injector) : injector;
      const rendererFactory = rootViewInjector.get(RendererFactory2, domRendererFactory3);
      const sanitizer = rootViewInjector.get(Sanitizer, null);
      const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);
      const elementName = this.componentDef.selectors[0][0] || 'div';
      const hostRNode = rootSelectorOrNode ?
          locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation) :
          createElementNode(
              rendererFactory.createRenderer(null, this.componentDef), elementName,
              getNamespace$1(elementName));
      const rootFlags = this.componentDef.onPush ? 64 | 512 : 16 | 512;
      const rootContext = createRootContext();
      const rootTView = createTView(0, null, null, 1, 0, null, null, null, null, null);
      const rootLView = createLView(
          null, rootTView, rootContext, rootFlags, null, null, rendererFactory, hostRenderer,
          sanitizer, rootViewInjector);
      enterView(rootLView);
      let component;
      let tElementNode;
      try {
        const componentView = createRootComponentView(
            hostRNode, this.componentDef, rootLView, rendererFactory, hostRenderer);
        if (hostRNode) {
          if (rootSelectorOrNode) {
            setUpAttributes(hostRenderer, hostRNode, ['ng-version', VERSION.full]);
          } else {
            const {attrs, classes} =
                extractAttrsAndClassesFromSelector(this.componentDef.selectors[0]);
            if (attrs) {
              setUpAttributes(hostRenderer, hostRNode, attrs);
            }
            if (classes && classes.length > 0) {
              writeDirectClass(hostRenderer, hostRNode, classes.join(' '));
            }
          }
        }
        tElementNode = getTNode(rootTView, HEADER_OFFSET);
        if (projectableNodes !== void 0) {
          const projection = tElementNode.projection = [];
          for (let i = 0; i < this.ngContentSelectors.length; i++) {
            const nodesforSlot = projectableNodes[i];
            projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);
          }
        }
        component = createRootComponent(
            componentView, this.componentDef, rootLView, rootContext, [LifecycleHooksFeature]);
        renderView(rootTView, rootLView, null);
      } finally {
        leaveView();
      }
      return new ComponentRef$1(
          this.componentType, component, createElementRef(tElementNode, rootLView), rootLView,
          tElementNode);
    }
  };
  var componentFactoryResolver = new ComponentFactoryResolver$1();
  var ComponentRef$1 = class extends ComponentRef {
    constructor(componentType, instance, location2, _rootLView, _tNode) {
      super();
      this.location = location2;
      this._rootLView = _rootLView;
      this._tNode = _tNode;
      this.instance = instance;
      this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView);
      this.componentType = componentType;
    }
    get injector() {
      return new NodeInjector(this._tNode, this._rootLView);
    }
    destroy() {
      this.hostView.destroy();
    }
    onDestroy(callback) {
      this.hostView.onDestroy(callback);
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function setClassMetadata(type, decorators, ctorParameters, propDecorators) {
    return noSideEffects(() => {
      const clazz = type;
      if (decorators !== null) {
        if (clazz.hasOwnProperty('decorators') && clazz.decorators !== void 0) {
          clazz.decorators.push(...decorators);
        } else {
          clazz.decorators = decorators;
        }
      }
      if (ctorParameters !== null) {
        clazz.ctorParameters = ctorParameters;
      }
      if (propDecorators !== null) {
        if (clazz.hasOwnProperty('propDecorators') && clazz.propDecorators !== void 0) {
          clazz.propDecorators =
              Object.assign(Object.assign({}, clazz.propDecorators), propDecorators);
        } else {
          clazz.propDecorators = propDecorators;
        }
      }
    });
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var modules = new Map();
  function assertSameOrNotExisting(id, type, incoming) {
    if (type && type !== incoming) {
      throw new Error(
          `Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);
    }
  }
  function registerNgModuleType(ngModuleType) {
    const visited = new Set();
    recurse(ngModuleType);
    function recurse(ngModuleType2) {
      const def = getNgModuleDef(ngModuleType2, true);
      const id = def.id;
      if (id !== null) {
        const existing = modules.get(id);
        assertSameOrNotExisting(id, existing, ngModuleType2);
        modules.set(id, ngModuleType2);
      }
      const imports = maybeUnwrapFn(def.imports);
      for (const i of imports) {
        if (!visited.has(i)) {
          visited.add(i);
          recurse(i);
        }
      }
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NgModuleRef$1 = class extends NgModuleRef {
    constructor(ngModuleType, _parent) {
      super();
      this._parent = _parent;
      this._bootstrapComponents = [];
      this.injector = this;
      this.destroyCbs = [];
      this.componentFactoryResolver = new ComponentFactoryResolver$1(this);
      const ngModuleDef = getNgModuleDef(ngModuleType);
      ngDevMode &&
          assertDefined(
              ngModuleDef,
              `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);
      const ngLocaleIdDef = getNgLocaleIdDef(ngModuleType);
      ngLocaleIdDef && setLocaleId(ngLocaleIdDef);
      this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
      this._r3Injector = createInjectorWithoutInjectorInstances(
          ngModuleType, _parent,
          [
            {provide: NgModuleRef, useValue: this},
            {provide: ComponentFactoryResolver, useValue: this.componentFactoryResolver}
          ],
          stringify(ngModuleType));
      this._r3Injector._resolveInjectorDefTypes();
      this.instance = this.get(ngModuleType);
    }
    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, injectFlags = InjectFlags.Default) {
      if (token === Injector || token === NgModuleRef || token === INJECTOR$1) {
        return this;
      }
      return this._r3Injector.get(token, notFoundValue, injectFlags);
    }
    destroy() {
      ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');
      const injector = this._r3Injector;
      !injector.destroyed && injector.destroy();
      this.destroyCbs.forEach((fn) => fn());
      this.destroyCbs = null;
    }
    onDestroy(callback) {
      ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');
      this.destroyCbs.push(callback);
    }
  };
  var NgModuleFactory$1 = class extends NgModuleFactory {
    constructor(moduleType) {
      super();
      this.moduleType = moduleType;
      const ngModuleDef = getNgModuleDef(moduleType);
      if (ngModuleDef !== null) {
        registerNgModuleType(moduleType);
      }
    }
    create(parentInjector) {
      return new NgModuleRef$1(this.moduleType, parentInjector);
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275pureFunction0(slotOffset, pureFn, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    return lView[bindingIndex] === NO_CHANGE ?
        updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) :
        getBinding(lView, bindingIndex);
  }
  function \u0275\u0275pureFunction1(slotOffset, pureFn, exp, thisArg) {
    return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);
  }
  function \u0275\u0275pureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
    return pureFunction2Internal(
        getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);
  }
  function \u0275\u0275pureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
    return pureFunction3Internal(
        getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);
  }
  function \u0275\u0275pureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
    return pureFunction4Internal(
        getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);
  }
  function \u0275\u0275pureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated(lView, bindingIndex + 4, exp5) || different ?
        updateBinding(
            lView, bindingIndex + 5,
            thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) :
                      pureFn(exp1, exp2, exp3, exp4, exp5)) :
        getBinding(lView, bindingIndex + 5);
  }
  function \u0275\u0275pureFunction6(
      slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ?
        updateBinding(
            lView, bindingIndex + 6,
            thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) :
                      pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) :
        getBinding(lView, bindingIndex + 6);
  }
  function \u0275\u0275pureFunction7(
      slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ?
        updateBinding(
            lView, bindingIndex + 7,
            thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) :
                      pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) :
        getBinding(lView, bindingIndex + 7);
  }
  function \u0275\u0275pureFunction8(
      slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ?
        updateBinding(
            lView, bindingIndex + 8,
            thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) :
                      pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) :
        getBinding(lView, bindingIndex + 8);
  }
  function \u0275\u0275pureFunctionV(slotOffset, pureFn, exps, thisArg) {
    return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);
  }
  function getPureFunctionReturnValue(lView, returnValueIndex) {
    ngDevMode && assertIndexInRange(lView, returnValueIndex);
    const lastReturnValue = lView[returnValueIndex];
    return lastReturnValue === NO_CHANGE ? void 0 : lastReturnValue;
  }
  function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated(lView, bindingIndex, exp) ?
        updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) :
        getPureFunctionReturnValue(lView, bindingIndex + 1);
  }
  function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated2(lView, bindingIndex, exp1, exp2) ?
        updateBinding(
            lView, bindingIndex + 2,
            thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) :
        getPureFunctionReturnValue(lView, bindingIndex + 2);
  }
  function pureFunction3Internal(
      lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ?
        updateBinding(
            lView, bindingIndex + 3,
            thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) :
        getPureFunctionReturnValue(lView, bindingIndex + 3);
  }
  function pureFunction4Internal(
      lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ?
        updateBinding(
            lView, bindingIndex + 4,
            thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) :
                      pureFn(exp1, exp2, exp3, exp4)) :
        getPureFunctionReturnValue(lView, bindingIndex + 4);
  }
  function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
    let bindingIndex = bindingRoot + slotOffset;
    let different = false;
    for (let i = 0; i < exps.length; i++) {
      bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);
    }
    return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) :
                       getPureFunctionReturnValue(lView, bindingIndex);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275pipe(index, pipeName) {
    const tView = getTView();
    let pipeDef;
    const adjustedIndex = index + HEADER_OFFSET;
    if (tView.firstCreatePass) {
      pipeDef = getPipeDef$1(pipeName, tView.pipeRegistry);
      tView.data[adjustedIndex] = pipeDef;
      if (pipeDef.onDestroy) {
        (tView.destroyHooks || (tView.destroyHooks = [])).push(adjustedIndex, pipeDef.onDestroy);
      }
    } else {
      pipeDef = tView.data[adjustedIndex];
    }
    const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));
    const previousInjectImplementation = setInjectImplementation(\u0275\u0275directiveInject);
    try {
      const previousIncludeViewProviders = setIncludeViewProviders(false);
      const pipeInstance = pipeFactory();
      setIncludeViewProviders(previousIncludeViewProviders);
      store(tView, getLView(), adjustedIndex, pipeInstance);
      return pipeInstance;
    } finally {
      setInjectImplementation(previousInjectImplementation);
    }
  }
  function getPipeDef$1(name, registry) {
    if (registry) {
      for (let i = registry.length - 1; i >= 0; i--) {
        const pipeDef = registry[i];
        if (name === pipeDef.name) {
          return pipeDef;
        }
      }
    }
    throw new RuntimeError('302', `The pipe '${name}' could not be found!`);
  }
  function \u0275\u0275pipeBind1(index, slotOffset, v1) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return unwrapValue$1(
        lView,
        isPure(lView, adjustedIndex) ?
            pureFunction1Internal(
                lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, pipeInstance) :
            pipeInstance.transform(v1));
  }
  function \u0275\u0275pipeBind2(index, slotOffset, v1, v2) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return unwrapValue$1(
        lView,
        isPure(lView, adjustedIndex) ?
            pureFunction2Internal(
                lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) :
            pipeInstance.transform(v1, v2));
  }
  function \u0275\u0275pipeBind3(index, slotOffset, v1, v2, v3) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return unwrapValue$1(
        lView,
        isPure(lView, adjustedIndex) ? pureFunction3Internal(
                                           lView, getBindingRoot(), slotOffset,
                                           pipeInstance.transform, v1, v2, v3, pipeInstance) :
                                       pipeInstance.transform(v1, v2, v3));
  }
  function \u0275\u0275pipeBind4(index, slotOffset, v1, v2, v3, v4) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return unwrapValue$1(
        lView,
        isPure(lView, adjustedIndex) ? pureFunction4Internal(
                                           lView, getBindingRoot(), slotOffset,
                                           pipeInstance.transform, v1, v2, v3, v4, pipeInstance) :
                                       pipeInstance.transform(v1, v2, v3, v4));
  }
  function \u0275\u0275pipeBindV(index, slotOffset, values) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return unwrapValue$1(
        lView,
        isPure(lView, adjustedIndex) ?
            pureFunctionVInternal(
                lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) :
            pipeInstance.transform.apply(pipeInstance, values));
  }
  function isPure(lView, index) {
    return lView[TVIEW].data[index].pure;
  }
  function unwrapValue$1(lView, newValue) {
    if (WrappedValue.isWrapped(newValue)) {
      newValue = WrappedValue.unwrap(newValue);
      const bindingToInvalidateIdx = getBindingIndex();
      lView[bindingToInvalidateIdx] = NO_CHANGE;
    }
    return newValue;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var EventEmitter_ = class extends Subject {
    constructor(isAsync = false) {
      super();
      this.__isAsync = isAsync;
    }
    emit(value) {
      super.next(value);
    }
    subscribe(generatorOrNext, error, complete) {
      let schedulerFn;
      let errorFn = (err) => null;
      let completeFn = () => null;
      if (generatorOrNext && typeof generatorOrNext === 'object') {
        schedulerFn = this.__isAsync ? (value) => {
          setTimeout(() => generatorOrNext.next(value));
        } : (value) => {
          generatorOrNext.next(value);
        };
        if (generatorOrNext.error) {
          errorFn = this.__isAsync ? (err) => {
            setTimeout(() => generatorOrNext.error(err));
          } : (err) => {
            generatorOrNext.error(err);
          };
        }
        if (generatorOrNext.complete) {
          completeFn = this.__isAsync ? () => {
            setTimeout(() => generatorOrNext.complete());
          } : () => {
            generatorOrNext.complete();
          };
        }
      } else {
        schedulerFn = this.__isAsync ? (value) => {
          setTimeout(() => generatorOrNext(value));
        } : (value) => {
          generatorOrNext(value);
        };
        if (error) {
          errorFn = this.__isAsync ? (err) => {
            setTimeout(() => error(err));
          } : (err) => {
            error(err);
          };
        }
        if (complete) {
          completeFn = this.__isAsync ? () => {
            setTimeout(() => complete());
          } : () => {
            complete();
          };
        }
      }
      const sink = super.subscribe(schedulerFn, errorFn, completeFn);
      if (generatorOrNext instanceof Subscription) {
        generatorOrNext.add(sink);
      }
      return sink;
    }
  };
  var EventEmitter = EventEmitter_;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function symbolIterator() {
    return this._results[getSymbolIterator2()]();
  }
  var QueryList = class {
    constructor() {
      this.dirty = true;
      this._results = [];
      this.changes = new EventEmitter();
      this.length = 0;
      const symbol = getSymbolIterator2();
      const proto = QueryList.prototype;
      if (!proto[symbol]) proto[symbol] = symbolIterator;
    }
    map(fn) {
      return this._results.map(fn);
    }
    filter(fn) {
      return this._results.filter(fn);
    }
    find(fn) {
      return this._results.find(fn);
    }
    reduce(fn, init) {
      return this._results.reduce(fn, init);
    }
    forEach(fn) {
      this._results.forEach(fn);
    }
    some(fn) {
      return this._results.some(fn);
    }
    toArray() {
      return this._results.slice();
    }
    toString() {
      return this._results.toString();
    }
    reset(resultsTree) {
      this._results = flatten(resultsTree);
      this.dirty = false;
      this.length = this._results.length;
      this.last = this._results[this.length - 1];
      this.first = this._results[0];
    }
    notifyOnChanges() {
      this.changes.emit(this);
    }
    setDirty() {
      this.dirty = true;
    }
    destroy() {
      this.changes.complete();
      this.changes.unsubscribe();
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var unusedValueExportToPlacateAjd$7 = 1;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var unusedValueExportToPlacateAjd$8 = 1;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var unusedValueToPlacateAjd$2 = unusedValueExportToPlacateAjd$7 +
      unusedValueExportToPlacateAjd$3 + unusedValueExportToPlacateAjd$4 +
      unusedValueExportToPlacateAjd$8;
  var LQuery_ = class {
    constructor(queryList) {
      this.queryList = queryList;
      this.matches = null;
    }
    clone() {
      return new LQuery_(this.queryList);
    }
    setDirty() {
      this.queryList.setDirty();
    }
  };
  var LQueries_ = class {
    constructor(queries = []) {
      this.queries = queries;
    }
    createEmbeddedView(tView) {
      const tQueries = tView.queries;
      if (tQueries !== null) {
        const noOfInheritedQueries =
            tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
        const viewLQueries = [];
        for (let i = 0; i < noOfInheritedQueries; i++) {
          const tQuery = tQueries.getByIndex(i);
          const parentLQuery = this.queries[tQuery.indexInDeclarationView];
          viewLQueries.push(parentLQuery.clone());
        }
        return new LQueries_(viewLQueries);
      }
      return null;
    }
    insertView(tView) {
      this.dirtyQueriesWithMatches(tView);
    }
    detachView(tView) {
      this.dirtyQueriesWithMatches(tView);
    }
    dirtyQueriesWithMatches(tView) {
      for (let i = 0; i < this.queries.length; i++) {
        if (getTQuery(tView, i).matches !== null) {
          this.queries[i].setDirty();
        }
      }
    }
  };
  var TQueryMetadata_ = class {
    constructor(predicate, descendants, isStatic, read = null) {
      this.predicate = predicate;
      this.descendants = descendants;
      this.isStatic = isStatic;
      this.read = read;
    }
  };
  var TQueries_ = class {
    constructor(queries = []) {
      this.queries = queries;
    }
    elementStart(tView, tNode) {
      ngDevMode &&
          assertFirstCreatePass(
              tView, 'Queries should collect results on the first template pass only');
      for (let i = 0; i < this.queries.length; i++) {
        this.queries[i].elementStart(tView, tNode);
      }
    }
    elementEnd(tNode) {
      for (let i = 0; i < this.queries.length; i++) {
        this.queries[i].elementEnd(tNode);
      }
    }
    embeddedTView(tNode) {
      let queriesForTemplateRef = null;
      for (let i = 0; i < this.length; i++) {
        const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
        const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
        if (tqueryClone) {
          tqueryClone.indexInDeclarationView = i;
          if (queriesForTemplateRef !== null) {
            queriesForTemplateRef.push(tqueryClone);
          } else {
            queriesForTemplateRef = [tqueryClone];
          }
        }
      }
      return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;
    }
    template(tView, tNode) {
      ngDevMode &&
          assertFirstCreatePass(
              tView, 'Queries should collect results on the first template pass only');
      for (let i = 0; i < this.queries.length; i++) {
        this.queries[i].template(tView, tNode);
      }
    }
    getByIndex(index) {
      ngDevMode && assertIndexInRange(this.queries, index);
      return this.queries[index];
    }
    get length() {
      return this.queries.length;
    }
    track(tquery) {
      this.queries.push(tquery);
    }
  };
  var TQuery_ = class {
    constructor(metadata, nodeIndex = -1) {
      this.metadata = metadata;
      this.matches = null;
      this.indexInDeclarationView = -1;
      this.crossesNgTemplate = false;
      this._appliesToNextNode = true;
      this._declarationNodeIndex = nodeIndex;
    }
    elementStart(tView, tNode) {
      if (this.isApplyingToNode(tNode)) {
        this.matchTNode(tView, tNode);
      }
    }
    elementEnd(tNode) {
      if (this._declarationNodeIndex === tNode.index) {
        this._appliesToNextNode = false;
      }
    }
    template(tView, tNode) {
      this.elementStart(tView, tNode);
    }
    embeddedTView(tNode, childQueryIndex) {
      if (this.isApplyingToNode(tNode)) {
        this.crossesNgTemplate = true;
        this.addMatch(-tNode.index, childQueryIndex);
        return new TQuery_(this.metadata);
      }
      return null;
    }
    isApplyingToNode(tNode) {
      if (this._appliesToNextNode && this.metadata.descendants === false) {
        const declarationNodeIdx = this._declarationNodeIndex;
        let parent = tNode.parent;
        while (parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx) {
          parent = parent.parent;
        }
        return declarationNodeIdx === (parent !== null ? parent.index : -1);
      }
      return this._appliesToNextNode;
    }
    matchTNode(tView, tNode) {
      const predicate = this.metadata.predicate;
      if (Array.isArray(predicate)) {
        for (let i = 0; i < predicate.length; i++) {
          const name = predicate[i];
          this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));
          this.matchTNodeWithReadOption(
              tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));
        }
      } else {
        if (predicate === TemplateRef) {
          if (tNode.type & 4) {
            this.matchTNodeWithReadOption(tView, tNode, -1);
          }
        } else {
          this.matchTNodeWithReadOption(
              tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
        }
      }
    }
    matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
      if (nodeMatchIdx !== null) {
        const read = this.metadata.read;
        if (read !== null) {
          if (read === ElementRef || read === ViewContainerRef ||
              read === TemplateRef && tNode.type & 4) {
            this.addMatch(tNode.index, -2);
          } else {
            const directiveOrProviderIdx =
                locateDirectiveOrProvider(tNode, tView, read, false, false);
            if (directiveOrProviderIdx !== null) {
              this.addMatch(tNode.index, directiveOrProviderIdx);
            }
          }
        } else {
          this.addMatch(tNode.index, nodeMatchIdx);
        }
      }
    }
    addMatch(tNodeIdx, matchIdx) {
      if (this.matches === null) {
        this.matches = [tNodeIdx, matchIdx];
      } else {
        this.matches.push(tNodeIdx, matchIdx);
      }
    }
  };
  function getIdxOfMatchingSelector(tNode, selector) {
    const localNames = tNode.localNames;
    if (localNames !== null) {
      for (let i = 0; i < localNames.length; i += 2) {
        if (localNames[i] === selector) {
          return localNames[i + 1];
        }
      }
    }
    return null;
  }
  function createResultByTNodeType(tNode, currentView) {
    if (tNode.type & (3 | 8)) {
      return createElementRef(tNode, currentView);
    } else if (tNode.type & 4) {
      return createTemplateRef(tNode, currentView);
    }
    return null;
  }
  function createResultForNode(lView, tNode, matchingIdx, read) {
    if (matchingIdx === -1) {
      return createResultByTNodeType(tNode, lView);
    } else if (matchingIdx === -2) {
      return createSpecialToken(lView, tNode, read);
    } else {
      return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);
    }
  }
  function createSpecialToken(lView, tNode, read) {
    if (read === ElementRef) {
      return createElementRef(tNode, lView);
    } else if (read === TemplateRef) {
      return createTemplateRef(tNode, lView);
    } else if (read === ViewContainerRef) {
      ngDevMode && assertTNodeType(tNode, 3 | 12);
      return createContainerRef(tNode, lView);
    } else {
      ngDevMode &&
          throwError2(
              `Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${
                  stringify(read)}.`);
    }
  }
  function materializeViewResults(tView, lView, tQuery, queryIndex) {
    const lQuery = lView[QUERIES].queries[queryIndex];
    if (lQuery.matches === null) {
      const tViewData = tView.data;
      const tQueryMatches = tQuery.matches;
      const result = [];
      for (let i = 0; i < tQueryMatches.length; i += 2) {
        const matchedNodeIdx = tQueryMatches[i];
        if (matchedNodeIdx < 0) {
          result.push(null);
        } else {
          ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);
          const tNode = tViewData[matchedNodeIdx];
          result.push(
              createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));
        }
      }
      lQuery.matches = result;
    }
    return lQuery.matches;
  }
  function collectQueryResults(tView, lView, queryIndex, result) {
    const tQuery = tView.queries.getByIndex(queryIndex);
    const tQueryMatches = tQuery.matches;
    if (tQueryMatches !== null) {
      const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
      for (let i = 0; i < tQueryMatches.length; i += 2) {
        const tNodeIdx = tQueryMatches[i];
        if (tNodeIdx > 0) {
          result.push(lViewResults[i / 2]);
        } else {
          const childQueryIndex = tQueryMatches[i + 1];
          const declarationLContainer = lView[-tNodeIdx];
          ngDevMode && assertLContainer(declarationLContainer);
          for (let i7 = CONTAINER_HEADER_OFFSET; i7 < declarationLContainer.length; i7++) {
            const embeddedLView = declarationLContainer[i7];
            if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {
              collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
            }
          }
          if (declarationLContainer[MOVED_VIEWS] !== null) {
            const embeddedLViews = declarationLContainer[MOVED_VIEWS];
            for (let i7 = 0; i7 < embeddedLViews.length; i7++) {
              const embeddedLView = embeddedLViews[i7];
              collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
            }
          }
        }
      }
    }
    return result;
  }
  function \u0275\u0275queryRefresh(queryList) {
    const lView = getLView();
    const tView = getTView();
    const queryIndex = getCurrentQueryIndex();
    setCurrentQueryIndex(queryIndex + 1);
    const tQuery = getTQuery(tView, queryIndex);
    if (queryList.dirty && isCreationMode(lView) === tQuery.metadata.isStatic) {
      if (tQuery.matches === null) {
        queryList.reset([]);
      } else {
        const result = tQuery.crossesNgTemplate ?
            collectQueryResults(tView, lView, queryIndex, []) :
            materializeViewResults(tView, lView, tQuery, queryIndex);
        queryList.reset(result);
        queryList.notifyOnChanges();
      }
      return true;
    }
    return false;
  }
  function \u0275\u0275staticViewQuery(predicate, descend, read) {
    viewQueryInternal(getTView(), getLView(), predicate, descend, read, true);
  }
  function \u0275\u0275viewQuery(predicate, descend, read) {
    viewQueryInternal(getTView(), getLView(), predicate, descend, read, false);
  }
  function viewQueryInternal(tView, lView, predicate, descend, read, isStatic) {
    if (tView.firstCreatePass) {
      createTQuery(tView, new TQueryMetadata_(predicate, descend, isStatic, read), -1);
      if (isStatic) {
        tView.staticViewQueries = true;
      }
    }
    createLQuery(tView, lView);
  }
  function \u0275\u0275contentQuery(directiveIndex, predicate, descend, read) {
    contentQueryInternal(
        getTView(), getLView(), predicate, descend, read, false, getCurrentTNode(), directiveIndex);
  }
  function \u0275\u0275staticContentQuery(directiveIndex, predicate, descend, read) {
    contentQueryInternal(
        getTView(), getLView(), predicate, descend, read, true, getCurrentTNode(), directiveIndex);
  }
  function contentQueryInternal(
      tView, lView, predicate, descend, read, isStatic, tNode, directiveIndex) {
    if (tView.firstCreatePass) {
      createTQuery(tView, new TQueryMetadata_(predicate, descend, isStatic, read), tNode.index);
      saveContentQueryAndDirectiveIndex(tView, directiveIndex);
      if (isStatic) {
        tView.staticContentQueries = true;
      }
    }
    createLQuery(tView, lView);
  }
  function \u0275\u0275loadQuery() {
    return loadQueryInternal(getLView(), getCurrentQueryIndex());
  }
  function loadQueryInternal(lView, queryIndex) {
    ngDevMode &&
        assertDefined(lView[QUERIES], 'LQueries should be defined when trying to load a query');
    ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);
    return lView[QUERIES].queries[queryIndex].queryList;
  }
  function createLQuery(tView, lView) {
    const queryList = new QueryList();
    storeCleanupWithContext(tView, lView, queryList, queryList.destroy);
    if (lView[QUERIES] === null) lView[QUERIES] = new LQueries_();
    lView[QUERIES].queries.push(new LQuery_(queryList));
  }
  function createTQuery(tView, metadata, nodeIndex) {
    if (tView.queries === null) tView.queries = new TQueries_();
    tView.queries.track(new TQuery_(metadata, nodeIndex));
  }
  function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
    const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
    const lastSavedDirectiveIndex =
        tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
    if (directiveIndex !== lastSavedDirectiveIndex) {
      tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
    }
  }
  function getTQuery(tView, index) {
    ngDevMode && assertDefined(tView.queries, 'TQueries must be defined to retrieve a TQuery');
    return tView.queries.getByIndex(index);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function \u0275\u0275templateRefExtractor(tNode, lView) {
    return createTemplateRef(tNode, lView);
  }
  function \u0275\u0275injectPipeChangeDetectorRef(flags = InjectFlags.Default) {
    const value = injectChangeDetectorRef(true);
    if (value == null && !(flags & InjectFlags.Optional)) {
      throwProviderNotFoundError('ChangeDetectorRef');
    } else {
      return value;
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var \u02750$c = () => ({
    \u0275\u0275attribute,
    \u0275\u0275attributeInterpolate1,
    \u0275\u0275attributeInterpolate2,
    \u0275\u0275attributeInterpolate3,
    \u0275\u0275attributeInterpolate4,
    \u0275\u0275attributeInterpolate5,
    \u0275\u0275attributeInterpolate6,
    \u0275\u0275attributeInterpolate7,
    \u0275\u0275attributeInterpolate8,
    \u0275\u0275attributeInterpolateV,
    \u0275\u0275defineComponent,
    \u0275\u0275defineDirective,
    \u0275\u0275defineInjectable,
    \u0275\u0275defineInjector,
    \u0275\u0275defineNgModule,
    \u0275\u0275definePipe,
    \u0275\u0275directiveInject,
    \u0275\u0275getFactoryOf,
    \u0275\u0275getInheritedFactory,
    \u0275\u0275inject,
    \u0275\u0275injectAttribute,
    \u0275\u0275invalidFactory,
    \u0275\u0275invalidFactoryDep,
    \u0275\u0275injectPipeChangeDetectorRef,
    \u0275\u0275templateRefExtractor,
    \u0275\u0275NgOnChangesFeature,
    \u0275\u0275ProvidersFeature,
    \u0275\u0275CopyDefinitionFeature,
    \u0275\u0275InheritDefinitionFeature,
    \u0275\u0275nextContext,
    \u0275\u0275namespaceHTML,
    \u0275\u0275namespaceMathML,
    \u0275\u0275namespaceSVG,
    \u0275\u0275enableBindings,
    \u0275\u0275disableBindings,
    \u0275\u0275elementStart,
    \u0275\u0275elementEnd,
    \u0275\u0275element,
    \u0275\u0275elementContainerStart,
    \u0275\u0275elementContainerEnd,
    \u0275\u0275elementContainer,
    \u0275\u0275pureFunction0,
    \u0275\u0275pureFunction1,
    \u0275\u0275pureFunction2,
    \u0275\u0275pureFunction3,
    \u0275\u0275pureFunction4,
    \u0275\u0275pureFunction5,
    \u0275\u0275pureFunction6,
    \u0275\u0275pureFunction7,
    \u0275\u0275pureFunction8,
    \u0275\u0275pureFunctionV,
    \u0275\u0275getCurrentView,
    \u0275\u0275restoreView,
    \u0275\u0275listener,
    \u0275\u0275projection,
    \u0275\u0275syntheticHostProperty,
    \u0275\u0275syntheticHostListener,
    \u0275\u0275pipeBind1,
    \u0275\u0275pipeBind2,
    \u0275\u0275pipeBind3,
    \u0275\u0275pipeBind4,
    \u0275\u0275pipeBindV,
    \u0275\u0275projectionDef,
    \u0275\u0275hostProperty,
    \u0275\u0275property,
    \u0275\u0275propertyInterpolate,
    \u0275\u0275propertyInterpolate1,
    \u0275\u0275propertyInterpolate2,
    \u0275\u0275propertyInterpolate3,
    \u0275\u0275propertyInterpolate4,
    \u0275\u0275propertyInterpolate5,
    \u0275\u0275propertyInterpolate6,
    \u0275\u0275propertyInterpolate7,
    \u0275\u0275propertyInterpolate8,
    \u0275\u0275propertyInterpolateV,
    \u0275\u0275pipe,
    \u0275\u0275queryRefresh,
    \u0275\u0275viewQuery,
    \u0275\u0275staticViewQuery,
    \u0275\u0275staticContentQuery,
    \u0275\u0275loadQuery,
    \u0275\u0275contentQuery,
    \u0275\u0275reference,
    \u0275\u0275classMap,
    \u0275\u0275classMapInterpolate1,
    \u0275\u0275classMapInterpolate2,
    \u0275\u0275classMapInterpolate3,
    \u0275\u0275classMapInterpolate4,
    \u0275\u0275classMapInterpolate5,
    \u0275\u0275classMapInterpolate6,
    \u0275\u0275classMapInterpolate7,
    \u0275\u0275classMapInterpolate8,
    \u0275\u0275classMapInterpolateV,
    \u0275\u0275styleMap,
    \u0275\u0275styleMapInterpolate1,
    \u0275\u0275styleMapInterpolate2,
    \u0275\u0275styleMapInterpolate3,
    \u0275\u0275styleMapInterpolate4,
    \u0275\u0275styleMapInterpolate5,
    \u0275\u0275styleMapInterpolate6,
    \u0275\u0275styleMapInterpolate7,
    \u0275\u0275styleMapInterpolate8,
    \u0275\u0275styleMapInterpolateV,
    \u0275\u0275styleProp,
    \u0275\u0275stylePropInterpolate1,
    \u0275\u0275stylePropInterpolate2,
    \u0275\u0275stylePropInterpolate3,
    \u0275\u0275stylePropInterpolate4,
    \u0275\u0275stylePropInterpolate5,
    \u0275\u0275stylePropInterpolate6,
    \u0275\u0275stylePropInterpolate7,
    \u0275\u0275stylePropInterpolate8,
    \u0275\u0275stylePropInterpolateV,
    \u0275\u0275classProp,
    \u0275\u0275advance,
    \u0275\u0275template,
    \u0275\u0275text,
    \u0275\u0275textInterpolate,
    \u0275\u0275textInterpolate1,
    \u0275\u0275textInterpolate2,
    \u0275\u0275textInterpolate3,
    \u0275\u0275textInterpolate4,
    \u0275\u0275textInterpolate5,
    \u0275\u0275textInterpolate6,
    \u0275\u0275textInterpolate7,
    \u0275\u0275textInterpolate8,
    \u0275\u0275textInterpolateV,
    \u0275\u0275i18n,
    \u0275\u0275i18nAttributes,
    \u0275\u0275i18nExp,
    \u0275\u0275i18nStart,
    \u0275\u0275i18nEnd,
    \u0275\u0275i18nApply,
    \u0275\u0275i18nPostprocess,
    \u0275\u0275resolveWindow,
    \u0275\u0275resolveDocument,
    \u0275\u0275resolveBody,
    \u0275\u0275setComponentScope,
    \u0275\u0275setNgModuleScope,
    \u0275\u0275sanitizeHtml,
    \u0275\u0275sanitizeStyle,
    \u0275\u0275sanitizeResourceUrl,
    \u0275\u0275sanitizeScript,
    \u0275\u0275sanitizeUrl,
    \u0275\u0275sanitizeUrlOrResourceUrl,
    \u0275\u0275trustConstantHtml,
    \u0275\u0275trustConstantScript,
    \u0275\u0275trustConstantResourceUrl
  });
  var angularCoreEnv = \u02750$c();
  var jitOptions = null;
  function setJitOptions(options) {
    if (jitOptions !== null) {
      if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
        ngDevMode &&
            console.error(
                'Provided value for `defaultEncapsulation` can not be changed once it has been set.');
        return;
      }
      if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
        ngDevMode &&
            console.error(
                'Provided value for `preserveWhitespaces` can not be changed once it has been set.');
        return;
      }
    }
    jitOptions = options;
  }
  function getJitOptions() {
    return jitOptions;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var EMPTY_ARRAY$5 = [];
  var moduleQueue = [];
  function enqueueModuleForDelayedScoping(moduleType, ngModule) {
    moduleQueue.push({moduleType, ngModule});
  }
  var flushingModuleQueue = false;
  function flushModuleScopingQueueAsMuchAsPossible() {
    if (!flushingModuleQueue) {
      flushingModuleQueue = true;
      try {
        for (let i = moduleQueue.length - 1; i >= 0; i--) {
          const {moduleType, ngModule} = moduleQueue[i];
          if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
            moduleQueue.splice(i, 1);
            setScopeOnDeclaredComponents(moduleType, ngModule);
          }
        }
      } finally {
        flushingModuleQueue = false;
      }
    }
  }
  function isResolvedDeclaration(declaration) {
    if (Array.isArray(declaration)) {
      return declaration.every(isResolvedDeclaration);
    }
    return !!resolveForwardRef(declaration);
  }
  function compileNgModule(moduleType, ngModule = {}) {
    compileNgModuleDefs(moduleType, ngModule);
    enqueueModuleForDelayedScoping(moduleType, ngModule);
  }
  function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
    ngDevMode && assertDefined(moduleType, 'Required value moduleType');
    ngDevMode && assertDefined(ngModule, 'Required value ngModule');
    const declarations = flatten(ngModule.declarations || EMPTY_ARRAY$5);
    let ngModuleDef = null;
    Object.defineProperty(moduleType, NG_MOD_DEF, {
      configurable: true,
      get: () => {
        if (ngModuleDef === null) {
          if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {
            throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);
          }
          ngModuleDef = getCompilerFacade().compileNgModule(
              angularCoreEnv, `ng:///${moduleType.name}/\u0275mod.js`, {
                type: moduleType,
                bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY$5).map(resolveForwardRef),
                declarations: declarations.map(resolveForwardRef),
                imports: flatten(ngModule.imports || EMPTY_ARRAY$5)
                             .map(resolveForwardRef)
                             .map(expandModuleWithProviders),
                exports: flatten(ngModule.exports || EMPTY_ARRAY$5)
                             .map(resolveForwardRef)
                             .map(expandModuleWithProviders),
                schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,
                id: ngModule.id || null
              });
          if (!ngModuleDef.schemas) {
            ngModuleDef.schemas = [];
          }
        }
        return ngModuleDef;
      }
    });
    let ngInjectorDef = null;
    Object.defineProperty(moduleType, NG_INJ_DEF, {
      get: () => {
        if (ngInjectorDef === null) {
          ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);
          const meta = {
            name: moduleType.name,
            type: moduleType,
            deps: reflectDependencies(moduleType),
            providers: ngModule.providers || EMPTY_ARRAY$5,
            imports: [
              (ngModule.imports || EMPTY_ARRAY$5).map(resolveForwardRef),
              (ngModule.exports || EMPTY_ARRAY$5).map(resolveForwardRef)
            ]
          };
          ngInjectorDef = getCompilerFacade().compileInjector(
              angularCoreEnv, `ng:///${moduleType.name}/\u0275inj.js`, meta);
        }
        return ngInjectorDef;
      },
      configurable: !!ngDevMode
    });
  }
  function verifySemanticsOfNgModuleDef(
      moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
    if (verifiedNgModule.get(moduleType)) return;
    verifiedNgModule.set(moduleType, true);
    moduleType = resolveForwardRef(moduleType);
    let ngModuleDef;
    if (importingModule) {
      ngModuleDef = getNgModuleDef(moduleType);
      if (!ngModuleDef) {
        throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${
            importingModule.name}'. Please add an @NgModule annotation.`);
      }
    } else {
      ngModuleDef = getNgModuleDef(moduleType, true);
    }
    const errors = [];
    const declarations = maybeUnwrapFn(ngModuleDef.declarations);
    const imports = maybeUnwrapFn(ngModuleDef.imports);
    flatten(imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {
      verifySemanticsOfNgModuleImport(mod, moduleType);
      verifySemanticsOfNgModuleDef(mod, false, moduleType);
    });
    const exports = maybeUnwrapFn(ngModuleDef.exports);
    declarations.forEach(verifyDeclarationsHaveDefinitions);
    declarations.forEach(verifyDirectivesHaveSelector);
    const combinedDeclarations = [
      ...declarations.map(resolveForwardRef),
      ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)
    ];
    exports.forEach(verifyExportsAreDeclaredOrReExported);
    declarations.forEach(
        (decl) => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
    declarations.forEach(verifyComponentEntryComponentsIsPartOfNgModule);
    const ngModule = getAnnotation(moduleType, 'NgModule');
    if (ngModule) {
      ngModule.imports &&
          flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {
            verifySemanticsOfNgModuleImport(mod, moduleType);
            verifySemanticsOfNgModuleDef(mod, false, moduleType);
          });
      ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);
      ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
      ngModule.entryComponents &&
          deepForEach(ngModule.entryComponents, verifyComponentIsPartOfNgModule);
    }
    if (errors.length) {
      throw new Error(errors.join('\n'));
    }
    function verifyDeclarationsHaveDefinitions(type) {
      type = resolveForwardRef(type);
      const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);
      if (!def) {
        errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${
            stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
      }
    }
    function verifyDirectivesHaveSelector(type) {
      type = resolveForwardRef(type);
      const def = getDirectiveDef(type);
      if (!getComponentDef(type) && def && def.selectors.length == 0) {
        errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);
      }
    }
    function verifyExportsAreDeclaredOrReExported(type) {
      type = resolveForwardRef(type);
      const kind = getComponentDef(type) && 'component' || getDirectiveDef(type) && 'directive' ||
          getPipeDef(type) && 'pipe';
      if (kind) {
        if (combinedDeclarations.lastIndexOf(type) === -1) {
          errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${
              stringifyForError(moduleType)} as it was neither declared nor imported!`);
        }
      }
    }
    function verifyDeclarationIsUnique(type, suppressErrors) {
      type = resolveForwardRef(type);
      const existingModule = ownerNgModule.get(type);
      if (existingModule && existingModule !== moduleType) {
        if (!suppressErrors) {
          const modules2 = [existingModule, moduleType].map(stringifyForError).sort();
          errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${
              modules2[0]} and ${modules2[1]}! Please consider moving ${
              stringifyForError(type)} to a higher module that imports ${modules2[0]} and ${
              modules2[1]}. You can also create a new NgModule that exports and includes ${
              stringifyForError(
                  type)} then import that NgModule in ${modules2[0]} and ${modules2[1]}.`);
        }
      } else {
        ownerNgModule.set(type, moduleType);
      }
    }
    function verifyComponentIsPartOfNgModule(type) {
      type = resolveForwardRef(type);
      const existingModule = ownerNgModule.get(type);
      if (!existingModule) {
        errors.push(`Component ${
            stringifyForError(
                type)} is not part of any NgModule or the module has not been imported into your module.`);
      }
    }
    function verifyCorrectBootstrapType(type) {
      type = resolveForwardRef(type);
      if (!getComponentDef(type)) {
        errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);
      }
    }
    function verifyComponentEntryComponentsIsPartOfNgModule(type) {
      type = resolveForwardRef(type);
      if (getComponentDef(type)) {
        const component = getAnnotation(type, 'Component');
        if (component && component.entryComponents) {
          deepForEach(component.entryComponents, verifyComponentIsPartOfNgModule);
        }
      }
    }
    function verifySemanticsOfNgModuleImport(type, importingModule2) {
      type = resolveForwardRef(type);
      if (getComponentDef(type) || getDirectiveDef(type)) {
        throw new Error(`Unexpected directive '${type.name}' imported by the module '${
            importingModule2.name}'. Please add an @NgModule annotation.`);
      }
      if (getPipeDef(type)) {
        throw new Error(`Unexpected pipe '${type.name}' imported by the module '${
            importingModule2.name}'. Please add an @NgModule annotation.`);
      }
    }
  }
  function unwrapModuleWithProvidersImports(typeOrWithProviders) {
    typeOrWithProviders = resolveForwardRef(typeOrWithProviders);
    return typeOrWithProviders.ngModule || typeOrWithProviders;
  }
  function getAnnotation(type, name) {
    let annotation = null;
    collect(type.__annotations__);
    collect(type.decorators);
    return annotation;
    function collect(annotations) {
      if (annotations) {
        annotations.forEach(readAnnotation);
      }
    }
    function readAnnotation(decorator) {
      if (!annotation) {
        const proto = Object.getPrototypeOf(decorator);
        if (proto.ngMetadataName == name) {
          annotation = decorator;
        } else if (decorator.type) {
          const proto2 = Object.getPrototypeOf(decorator.type);
          if (proto2.ngMetadataName == name) {
            annotation = decorator.args[0];
          }
        }
      }
    }
  }
  var ownerNgModule = new Map();
  var verifiedNgModule = new Map();
  function computeCombinedExports(type) {
    type = resolveForwardRef(type);
    const ngModuleDef = getNgModuleDef(type, true);
    return [...flatten(maybeUnwrapFn(ngModuleDef.exports).map((type2) => {
      const ngModuleDef2 = getNgModuleDef(type2);
      if (ngModuleDef2) {
        verifySemanticsOfNgModuleDef(type2, false);
        return computeCombinedExports(type2);
      } else {
        return type2;
      }
    }))];
  }
  function setScopeOnDeclaredComponents(moduleType, ngModule) {
    const declarations = flatten(ngModule.declarations || EMPTY_ARRAY$5);
    const transitiveScopes = transitiveScopesFor(moduleType);
    declarations.forEach((declaration) => {
      if (declaration.hasOwnProperty(NG_COMP_DEF)) {
        const component = declaration;
        const componentDef = getComponentDef(component);
        patchComponentDefWithScope(componentDef, transitiveScopes);
      } else if (
          !declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {
        declaration.ngSelectorScope = moduleType;
      }
    });
  }
  function patchComponentDefWithScope(componentDef, transitiveScopes) {
    componentDef.directiveDefs = () =>
        Array.from(transitiveScopes.compilation.directives)
            .map(
                (dir) =>
                    dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir) : getDirectiveDef(dir))
            .filter((def) => !!def);
    componentDef.pipeDefs = () =>
        Array.from(transitiveScopes.compilation.pipes).map((pipe2) => getPipeDef(pipe2));
    componentDef.schemas = transitiveScopes.schemas;
    componentDef.tView = null;
  }
  function transitiveScopesFor(moduleType) {
    if (!isNgModule(moduleType)) {
      throw new Error(`${moduleType.name} does not have a module def (\u0275mod property)`);
    }
    const def = getNgModuleDef(moduleType);
    if (def.transitiveCompileScopes !== null) {
      return def.transitiveCompileScopes;
    }
    const scopes = {
      schemas: def.schemas || null,
      compilation: {directives: new Set(), pipes: new Set()},
      exported: {directives: new Set(), pipes: new Set()}
    };
    maybeUnwrapFn(def.imports).forEach((imported) => {
      const importedType = imported;
      if (!isNgModule(importedType)) {
        throw new Error(`Importing ${importedType.name} which does not have a \u0275mod property`);
      }
      const importedScope = transitiveScopesFor(importedType);
      importedScope.exported.directives.forEach(
          (entry) => scopes.compilation.directives.add(entry));
      importedScope.exported.pipes.forEach((entry) => scopes.compilation.pipes.add(entry));
    });
    maybeUnwrapFn(def.declarations).forEach((declared) => {
      const declaredWithDefs = declared;
      if (getPipeDef(declaredWithDefs)) {
        scopes.compilation.pipes.add(declared);
      } else {
        scopes.compilation.directives.add(declared);
      }
    });
    maybeUnwrapFn(def.exports).forEach((exported) => {
      const exportedType = exported;
      if (isNgModule(exportedType)) {
        const exportedScope = transitiveScopesFor(exportedType);
        exportedScope.exported.directives.forEach((entry) => {
          scopes.compilation.directives.add(entry);
          scopes.exported.directives.add(entry);
        });
        exportedScope.exported.pipes.forEach((entry) => {
          scopes.compilation.pipes.add(entry);
          scopes.exported.pipes.add(entry);
        });
      } else if (getPipeDef(exportedType)) {
        scopes.exported.pipes.add(exportedType);
      } else {
        scopes.exported.directives.add(exportedType);
      }
    });
    def.transitiveCompileScopes = scopes;
    return scopes;
  }
  function expandModuleWithProviders(value) {
    if (isModuleWithProviders(value)) {
      return value.ngModule;
    }
    return value;
  }
  function isModuleWithProviders(value) {
    return value.ngModule !== void 0;
  }
  function isNgModule(value) {
    return !!getNgModuleDef(value);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var compilationDepth = 0;
  function compileComponent(type, metadata) {
    (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();
    let ngComponentDef = null;
    maybeQueueResolutionOfComponentResources(type, metadata);
    addDirectiveFactoryDef(type, metadata);
    Object.defineProperty(type, NG_COMP_DEF, {
      get: () => {
        if (ngComponentDef === null) {
          const compiler = getCompilerFacade();
          if (componentNeedsResolution(metadata)) {
            const error = [`Component '${type.name}' is not resolved:`];
            if (metadata.templateUrl) {
              error.push(` - templateUrl: ${metadata.templateUrl}`);
            }
            if (metadata.styleUrls && metadata.styleUrls.length) {
              error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
            }
            error.push(`Did you run and wait for 'resolveComponentResources()'?`);
            throw new Error(error.join('\n'));
          }
          const options = getJitOptions();
          let preserveWhitespaces = metadata.preserveWhitespaces;
          if (preserveWhitespaces === void 0) {
            if (options !== null && options.preserveWhitespaces !== void 0) {
              preserveWhitespaces = options.preserveWhitespaces;
            } else {
              preserveWhitespaces = false;
            }
          }
          let encapsulation = metadata.encapsulation;
          if (encapsulation === void 0) {
            if (options !== null && options.defaultEncapsulation !== void 0) {
              encapsulation = options.defaultEncapsulation;
            } else {
              encapsulation = ViewEncapsulation.Emulated;
            }
          }
          const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;
          const meta = Object.assign(Object.assign({}, directiveMetadata(type, metadata)), {
            typeSourceSpan: compiler.createParseSourceSpan('Component', type.name, templateUrl),
            template: metadata.template || '',
            preserveWhitespaces,
            styles: metadata.styles || EMPTY_ARRAY,
            animations: metadata.animations,
            directives: [],
            changeDetection: metadata.changeDetection,
            pipes: new Map(),
            encapsulation,
            interpolation: metadata.interpolation,
            viewProviders: metadata.viewProviders || null
          });
          compilationDepth++;
          try {
            if (meta.usesInheritance) {
              addDirectiveDefToUndecoratedParents(type);
            }
            ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);
          } finally {
            compilationDepth--;
          }
          if (compilationDepth === 0) {
            flushModuleScopingQueueAsMuchAsPossible();
          }
          if (hasSelectorScope(type)) {
            const scopes = transitiveScopesFor(type.ngSelectorScope);
            patchComponentDefWithScope(ngComponentDef, scopes);
          }
        }
        return ngComponentDef;
      },
      configurable: !!ngDevMode
    });
  }
  function hasSelectorScope(component) {
    return component.ngSelectorScope !== void 0;
  }
  function compileDirective(type, directive) {
    let ngDirectiveDef = null;
    addDirectiveFactoryDef(type, directive || {});
    Object.defineProperty(type, NG_DIR_DEF, {
      get: () => {
        if (ngDirectiveDef === null) {
          const meta = getDirectiveMetadata(type, directive || {});
          ngDirectiveDef = getCompilerFacade().compileDirective(
              angularCoreEnv, meta.sourceMapUrl, meta.metadata);
        }
        return ngDirectiveDef;
      },
      configurable: !!ngDevMode
    });
  }
  function getDirectiveMetadata(type, metadata) {
    const name = type && type.name;
    const sourceMapUrl = `ng:///${name}/\u0275dir.js`;
    const compiler = getCompilerFacade();
    const facade = directiveMetadata(type, metadata);
    facade.typeSourceSpan = compiler.createParseSourceSpan('Directive', name, sourceMapUrl);
    if (facade.usesInheritance) {
      addDirectiveDefToUndecoratedParents(type);
    }
    return {metadata: facade, sourceMapUrl};
  }
  function addDirectiveFactoryDef(type, metadata) {
    let ngFactoryDef = null;
    Object.defineProperty(type, NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const meta = getDirectiveMetadata(type, metadata);
          const compiler = getCompilerFacade();
          ngFactoryDef = compiler.compileFactory(
              angularCoreEnv, `ng:///${type.name}/\u0275fac.js`,
              Object.assign(
                  Object.assign({}, meta.metadata),
                  {injectFn: 'directiveInject', target: compiler.R3FactoryTarget.Directive}));
        }
        return ngFactoryDef;
      },
      configurable: !!ngDevMode
    });
  }
  function extendsDirectlyFromObject(type) {
    return Object.getPrototypeOf(type.prototype) === Object.prototype;
  }
  function directiveMetadata(type, metadata) {
    const reflect = getReflect();
    const propMetadata = reflect.ownPropMetadata(type);
    return {
      name: type.name,
      type,
      typeArgumentCount: 0,
      selector: metadata.selector !== void 0 ? metadata.selector : null,
      deps: reflectDependencies(type),
      host: metadata.host || EMPTY_OBJ,
      propMetadata,
      inputs: metadata.inputs || EMPTY_ARRAY,
      outputs: metadata.outputs || EMPTY_ARRAY,
      queries: extractQueriesMetadata(type, propMetadata, isContentQuery),
      lifecycle: {usesOnChanges: reflect.hasLifecycleHook(type, 'ngOnChanges')},
      typeSourceSpan: null,
      usesInheritance: !extendsDirectlyFromObject(type),
      exportAs: extractExportAs(metadata.exportAs),
      providers: metadata.providers || null,
      viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery)
    };
  }
  function addDirectiveDefToUndecoratedParents(type) {
    const objPrototype = Object.prototype;
    let parent = Object.getPrototypeOf(type.prototype).constructor;
    while (parent && parent !== objPrototype) {
      if (!getDirectiveDef(parent) && !getComponentDef(parent) &&
          shouldAddAbstractDirective(parent)) {
        compileDirective(parent, null);
      }
      parent = Object.getPrototypeOf(parent);
    }
  }
  function convertToR3QueryPredicate(selector) {
    return typeof selector === 'string' ? splitByComma(selector) : resolveForwardRef(selector);
  }
  function convertToR3QueryMetadata(propertyName, ann) {
    return {
      propertyName,
      predicate: convertToR3QueryPredicate(ann.selector),
      descendants: ann.descendants,
      first: ann.first,
      read: ann.read ? ann.read : null,
      static: !!ann.static
    };
  }
  function extractQueriesMetadata(type, propMetadata, isQueryAnn) {
    const queriesMeta = [];
    for (const field in propMetadata) {
      if (propMetadata.hasOwnProperty(field)) {
        const annotations = propMetadata[field];
        annotations.forEach((ann) => {
          if (isQueryAnn(ann)) {
            if (!ann.selector) {
              throw new Error(`Can't construct a query for the property "${field}" of "${
                  stringifyForError(type)}" since the query selector wasn't defined.`);
            }
            if (annotations.some(isInputAnnotation)) {
              throw new Error(`Cannot combine @Input decorators with query decorators`);
            }
            queriesMeta.push(convertToR3QueryMetadata(field, ann));
          }
        });
      }
    }
    return queriesMeta;
  }
  function extractExportAs(exportAs) {
    return exportAs === void 0 ? null : splitByComma(exportAs);
  }
  function isContentQuery(value) {
    const name = value.ngMetadataName;
    return name === 'ContentChild' || name === 'ContentChildren';
  }
  function isViewQuery(value) {
    const name = value.ngMetadataName;
    return name === 'ViewChild' || name === 'ViewChildren';
  }
  function isInputAnnotation(value) {
    return value.ngMetadataName === 'Input';
  }
  function splitByComma(value) {
    return value.split(',').map((piece) => piece.trim());
  }
  var LIFECYCLE_HOOKS = [
    'ngOnChanges', 'ngOnInit', 'ngOnDestroy', 'ngDoCheck', 'ngAfterViewInit', 'ngAfterViewChecked',
    'ngAfterContentInit', 'ngAfterContentChecked'
  ];
  function shouldAddAbstractDirective(type) {
    const reflect = getReflect();
    if (LIFECYCLE_HOOKS.some((hookName) => reflect.hasLifecycleHook(type, hookName))) {
      return true;
    }
    const propMetadata = reflect.propMetadata(type);
    for (const field in propMetadata) {
      const annotations = propMetadata[field];
      for (let i = 0; i < annotations.length; i++) {
        const current = annotations[i];
        const metadataName = current.ngMetadataName;
        if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) ||
            metadataName === 'Output' || metadataName === 'HostBinding' ||
            metadataName === 'HostListener') {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function compilePipe(type, meta) {
    let ngPipeDef = null;
    let ngFactoryDef = null;
    Object.defineProperty(type, NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const metadata = getPipeMetadata(type, meta);
          const compiler = getCompilerFacade();
          ngFactoryDef = compiler.compileFactory(
              angularCoreEnv, `ng:///${metadata.name}/\u0275fac.js`,
              Object.assign(
                  Object.assign({}, metadata),
                  {injectFn: 'directiveInject', target: compiler.R3FactoryTarget.Pipe}));
        }
        return ngFactoryDef;
      },
      configurable: !!ngDevMode
    });
    Object.defineProperty(type, NG_PIPE_DEF, {
      get: () => {
        if (ngPipeDef === null) {
          const metadata = getPipeMetadata(type, meta);
          ngPipeDef = getCompilerFacade().compilePipe(
              angularCoreEnv, `ng:///${metadata.name}/\u0275pipe.js`, metadata);
        }
        return ngPipeDef;
      },
      configurable: !!ngDevMode
    });
  }
  function getPipeMetadata(type, meta) {
    return {
      type,
      typeArgumentCount: 0,
      name: type.name,
      deps: reflectDependencies(type),
      pipeName: meta.name,
      pure: meta.pure !== void 0 ? meta.pure : true
    };
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var \u02750$d = (dir = {}) => dir;
  var \u02751$2 = (type, meta) => SWITCH_COMPILE_DIRECTIVE(type, meta);
  var Directive = makeDecorator('Directive', \u02750$d, void 0, void 0, \u02751$2);
  var \u02752$1 = (c = {}) => Object.assign({changeDetection: ChangeDetectionStrategy.Default}, c);
  var \u02753$1 = (type, meta) => SWITCH_COMPILE_COMPONENT(type, meta);
  var Component = makeDecorator('Component', \u02752$1, Directive, void 0, \u02753$1);
  var \u02754 = (p) => Object.assign({pure: true}, p);
  var \u02755 = (type, meta) => SWITCH_COMPILE_PIPE(type, meta);
  var Pipe = makeDecorator('Pipe', \u02754, void 0, void 0, \u02755);
  var \u02756 = (bindingPropertyName) => ({bindingPropertyName});
  var Input = makePropDecorator('Input', \u02756);
  var \u02757 = (bindingPropertyName) => ({bindingPropertyName});
  var Output = makePropDecorator('Output', \u02757);
  var \u02758 = (hostPropertyName) => ({hostPropertyName});
  var HostBinding = makePropDecorator('HostBinding', \u02758);
  var \u02759 = (eventName, args) => ({eventName, args});
  var HostListener = makePropDecorator('HostListener', \u02759);
  var SWITCH_COMPILE_COMPONENT__POST_R3__ = compileComponent;
  var SWITCH_COMPILE_DIRECTIVE__POST_R3__ = compileDirective;
  var SWITCH_COMPILE_PIPE__POST_R3__ = compilePipe;
  var SWITCH_COMPILE_COMPONENT = SWITCH_COMPILE_COMPONENT__POST_R3__;
  var SWITCH_COMPILE_DIRECTIVE = SWITCH_COMPILE_DIRECTIVE__POST_R3__;
  var SWITCH_COMPILE_PIPE = SWITCH_COMPILE_PIPE__POST_R3__;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var \u02750$e = (ngModule) => ngModule;
  var \u02751$3 = (type, meta) => SWITCH_COMPILE_NGMODULE(type, meta);
  var NgModule = makeDecorator('NgModule', \u02750$e, void 0, void 0, \u02751$3);
  var SWITCH_COMPILE_NGMODULE__POST_R3__ = compileNgModule;
  var SWITCH_COMPILE_NGMODULE = SWITCH_COMPILE_NGMODULE__POST_R3__;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var APP_INITIALIZER = new InjectionToken('Application Initializer');
  var ApplicationInitStatus = class {
    constructor(appInits) {
      this.appInits = appInits;
      this.resolve = noop2;
      this.reject = noop2;
      this.initialized = false;
      this.done = false;
      this.donePromise = new Promise((res, rej) => {
        this.resolve = res;
        this.reject = rej;
      });
    }
    runInitializers() {
      if (this.initialized) {
        return;
      }
      const asyncInitPromises = [];
      const complete = () => {
        this.done = true;
        this.resolve();
      };
      if (this.appInits) {
        for (let i = 0; i < this.appInits.length; i++) {
          const initResult = this.appInits[i]();
          if (isPromise2(initResult)) {
            asyncInitPromises.push(initResult);
          }
        }
      }
      Promise.all(asyncInitPromises)
          .then(() => {
            complete();
          })
          .catch((e) => {
            this.reject(e);
          });
      if (asyncInitPromises.length === 0) {
        complete();
      }
      this.initialized = true;
    }
  };
  ApplicationInitStatus.\u0275fac = function ApplicationInitStatus_Factory(t) {
    return new (t || ApplicationInitStatus)(\u0275\u0275inject(APP_INITIALIZER, 8));
  };
  ApplicationInitStatus.\u0275prov = \u0275\u0275defineInjectable(
      {token: ApplicationInitStatus, factory: ApplicationInitStatus.\u0275fac});
  ApplicationInitStatus.ctorParameters = () =>
      [{type: Array, decorators: [{type: Inject, args: [APP_INITIALIZER]}, {type: Optional}]}];
  (function() {
    setClassMetadata(ApplicationInitStatus, [{type: Injectable}], function() {
      return [
        {type: Array, decorators: [{type: Inject, args: [APP_INITIALIZER]}, {type: Optional}]}
      ];
    }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var APP_ID = new InjectionToken('AppId');
  function _appIdRandomProviderFactory() {
    return `${_randomChar()}${_randomChar()}${_randomChar()}`;
  }
  var APP_ID_RANDOM_PROVIDER = {provide: APP_ID, useFactory: _appIdRandomProviderFactory, deps: []};
  function _randomChar() {
    return String.fromCharCode(97 + Math.floor(Math.random() * 25));
  }
  var PLATFORM_INITIALIZER = new InjectionToken('Platform Initializer');
  var PLATFORM_ID = new InjectionToken('Platform ID');
  var APP_BOOTSTRAP_LISTENER = new InjectionToken('appBootstrapListener');
  var PACKAGE_ROOT_URL = new InjectionToken('Application Packages Root URL');
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var Console = class {
    log(message) {
      console.log(message);
    }
    warn(message) {
      console.warn(message);
    }
  };
  Console.\u0275fac = function Console_Factory(t) {
    return new (t || Console)();
  };
  Console.\u0275prov = \u0275\u0275defineInjectable({token: Console, factory: Console.\u0275fac});
  (function() {
    setClassMetadata(Console, [{type: Injectable}], null, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var LOCALE_ID$1 = new InjectionToken('LocaleId');
  var DEFAULT_CURRENCY_CODE = new InjectionToken('DefaultCurrencyCode');
  var TRANSLATIONS = new InjectionToken('Translations');
  var TRANSLATIONS_FORMAT = new InjectionToken('TranslationsFormat');
  var MissingTranslationStrategy;
  (function(MissingTranslationStrategy2) {
    MissingTranslationStrategy2[MissingTranslationStrategy2['Error'] = 0] = 'Error';
    MissingTranslationStrategy2[MissingTranslationStrategy2['Warning'] = 1] = 'Warning';
    MissingTranslationStrategy2[MissingTranslationStrategy2['Ignore'] = 2] = 'Ignore';
  })(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var SWITCH_IVY_ENABLED__POST_R3__ = true;
  var ivyEnabled = SWITCH_IVY_ENABLED__POST_R3__;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ModuleWithComponentFactories = class {
    constructor(ngModuleFactory, componentFactories) {
      this.ngModuleFactory = ngModuleFactory;
      this.componentFactories = componentFactories;
    }
  };
  var Compiler_compileModuleSync__POST_R3__ = function(moduleType) {
    return new NgModuleFactory$1(moduleType);
  };
  var Compiler_compileModuleSync = Compiler_compileModuleSync__POST_R3__;
  var Compiler_compileModuleAsync__POST_R3__ = function(moduleType) {
    return Promise.resolve(Compiler_compileModuleSync__POST_R3__(moduleType));
  };
  var Compiler_compileModuleAsync = Compiler_compileModuleAsync__POST_R3__;
  var Compiler_compileModuleAndAllComponentsSync__POST_R3__ = function(moduleType) {
    const ngModuleFactory = Compiler_compileModuleSync__POST_R3__(moduleType);
    const moduleDef = getNgModuleDef(moduleType);
    const componentFactories =
        maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {
          const componentDef = getComponentDef(declaration);
          componentDef && factories.push(new ComponentFactory$1(componentDef));
          return factories;
        }, []);
    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
  };
  var Compiler_compileModuleAndAllComponentsSync =
      Compiler_compileModuleAndAllComponentsSync__POST_R3__;
  var Compiler_compileModuleAndAllComponentsAsync__POST_R3__ = function(moduleType) {
    return Promise.resolve(Compiler_compileModuleAndAllComponentsSync__POST_R3__(moduleType));
  };
  var Compiler_compileModuleAndAllComponentsAsync =
      Compiler_compileModuleAndAllComponentsAsync__POST_R3__;
  var Compiler = class {
    constructor() {
      this.compileModuleSync = Compiler_compileModuleSync;
      this.compileModuleAsync = Compiler_compileModuleAsync;
      this.compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync;
      this.compileModuleAndAllComponentsAsync = Compiler_compileModuleAndAllComponentsAsync;
    }
    clearCache() {}
    clearCacheFor(type) {}
    getModuleId(moduleType) {
      return void 0;
    }
  };
  Compiler.\u0275fac = function Compiler_Factory(t) {
    return new (t || Compiler)();
  };
  Compiler.\u0275prov =
      \u0275\u0275defineInjectable({token: Compiler, factory: Compiler.\u0275fac});
  (function() {
    setClassMetadata(Compiler, [{type: Injectable}], function() {
      return [];
    }, null);
  })();
  var COMPILER_OPTIONS = new InjectionToken('compilerOptions');
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var promise = (() => Promise.resolve(0))();
  function scheduleMicroTask(fn) {
    if (typeof Zone === 'undefined') {
      promise.then(() => {
        fn && fn.apply(null, null);
      });
    } else {
      Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function getNativeRequestAnimationFrame() {
    let nativeRequestAnimationFrame = _global['requestAnimationFrame'];
    let nativeCancelAnimationFrame = _global['cancelAnimationFrame'];
    if (typeof Zone !== 'undefined' && nativeRequestAnimationFrame && nativeCancelAnimationFrame) {
      const unpatchedRequestAnimationFrame =
          nativeRequestAnimationFrame[Zone.__symbol__('OriginalDelegate')];
      if (unpatchedRequestAnimationFrame) {
        nativeRequestAnimationFrame = unpatchedRequestAnimationFrame;
      }
      const unpatchedCancelAnimationFrame =
          nativeCancelAnimationFrame[Zone.__symbol__('OriginalDelegate')];
      if (unpatchedCancelAnimationFrame) {
        nativeCancelAnimationFrame = unpatchedCancelAnimationFrame;
      }
    }
    return {nativeRequestAnimationFrame, nativeCancelAnimationFrame};
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NgZone = class {
    constructor({enableLongStackTrace = false, shouldCoalesceEventChangeDetection = false}) {
      this.hasPendingMacrotasks = false;
      this.hasPendingMicrotasks = false;
      this.isStable = true;
      this.onUnstable = new EventEmitter(false);
      this.onMicrotaskEmpty = new EventEmitter(false);
      this.onStable = new EventEmitter(false);
      this.onError = new EventEmitter(false);
      if (typeof Zone == 'undefined') {
        throw new Error(`In this configuration Angular requires Zone.js`);
      }
      Zone.assertZonePatched();
      const self2 = this;
      self2._nesting = 0;
      self2._outer = self2._inner = Zone.current;
      if (Zone['TaskTrackingZoneSpec']) {
        self2._inner = self2._inner.fork(new Zone['TaskTrackingZoneSpec']());
      }
      if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {
        self2._inner = self2._inner.fork(Zone['longStackTraceZoneSpec']);
      }
      self2.shouldCoalesceEventChangeDetection = shouldCoalesceEventChangeDetection;
      self2.lastRequestAnimationFrameId = -1;
      self2.nativeRequestAnimationFrame =
          getNativeRequestAnimationFrame().nativeRequestAnimationFrame;
      forkInnerZoneWithAngularBehavior(self2);
    }
    static isInAngularZone() {
      return Zone.current.get('isAngularZone') === true;
    }
    static assertInAngularZone() {
      if (!NgZone.isInAngularZone()) {
        throw new Error('Expected to be in Angular Zone, but it is not!');
      }
    }
    static assertNotInAngularZone() {
      if (NgZone.isInAngularZone()) {
        throw new Error('Expected to not be in Angular Zone, but it is!');
      }
    }
    run(fn, applyThis, applyArgs) {
      return this._inner.run(fn, applyThis, applyArgs);
    }
    runTask(fn, applyThis, applyArgs, name) {
      const zone = this._inner;
      const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop2, noop2);
      try {
        return zone.runTask(task, applyThis, applyArgs);
      } finally {
        zone.cancelTask(task);
      }
    }
    runGuarded(fn, applyThis, applyArgs) {
      return this._inner.runGuarded(fn, applyThis, applyArgs);
    }
    runOutsideAngular(fn) {
      return this._outer.run(fn);
    }
  };
  var EMPTY_PAYLOAD = {};
  function checkStable(zone) {
    if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
      try {
        zone._nesting++;
        zone.onMicrotaskEmpty.emit(null);
      } finally {
        zone._nesting--;
        if (!zone.hasPendingMicrotasks) {
          try {
            zone.runOutsideAngular(() => zone.onStable.emit(null));
          } finally {
            zone.isStable = true;
          }
        }
      }
    }
  }
  function delayChangeDetectionForEvents(zone) {
    if (zone.lastRequestAnimationFrameId !== -1) {
      return;
    }
    zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(_global, () => {
      if (!zone.fakeTopEventTask) {
        zone.fakeTopEventTask = Zone.root.scheduleEventTask('fakeTopEventTask', () => {
          zone.lastRequestAnimationFrameId = -1;
          updateMicroTaskStatus(zone);
          checkStable(zone);
        }, void 0, () => {}, () => {});
      }
      zone.fakeTopEventTask.invoke();
    });
    updateMicroTaskStatus(zone);
  }
  function forkInnerZoneWithAngularBehavior(zone) {
    const delayChangeDetectionForEventsDelegate = () => {
      delayChangeDetectionForEvents(zone);
    };
    const maybeDelayChangeDetection = !!zone.shouldCoalesceEventChangeDetection &&
        zone.nativeRequestAnimationFrame && delayChangeDetectionForEventsDelegate;
    zone._inner = zone._inner.fork({
      name: 'angular',
      properties: {isAngularZone: true, maybeDelayChangeDetection},
      onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
        try {
          onEnter(zone);
          return delegate.invokeTask(target, task, applyThis, applyArgs);
        } finally {
          if (maybeDelayChangeDetection && task.type === 'eventTask') {
            maybeDelayChangeDetection();
          }
          onLeave(zone);
        }
      },
      onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
        try {
          onEnter(zone);
          return delegate.invoke(target, callback, applyThis, applyArgs, source);
        } finally {
          onLeave(zone);
        }
      },
      onHasTask: (delegate, current, target, hasTaskState) => {
        delegate.hasTask(target, hasTaskState);
        if (current === target) {
          if (hasTaskState.change == 'microTask') {
            zone._hasPendingMicrotasks = hasTaskState.microTask;
            updateMicroTaskStatus(zone);
            checkStable(zone);
          } else if (hasTaskState.change == 'macroTask') {
            zone.hasPendingMacrotasks = hasTaskState.macroTask;
          }
        }
      },
      onHandleError: (delegate, current, target, error) => {
        delegate.handleError(target, error);
        zone.runOutsideAngular(() => zone.onError.emit(error));
        return false;
      }
    });
  }
  function updateMicroTaskStatus(zone) {
    if (zone._hasPendingMicrotasks ||
        zone.shouldCoalesceEventChangeDetection && zone.lastRequestAnimationFrameId !== -1) {
      zone.hasPendingMicrotasks = true;
    } else {
      zone.hasPendingMicrotasks = false;
    }
  }
  function onEnter(zone) {
    zone._nesting++;
    if (zone.isStable) {
      zone.isStable = false;
      zone.onUnstable.emit(null);
    }
  }
  function onLeave(zone) {
    zone._nesting--;
    checkStable(zone);
  }
  var NoopNgZone = class {
    constructor() {
      this.hasPendingMicrotasks = false;
      this.hasPendingMacrotasks = false;
      this.isStable = true;
      this.onUnstable = new EventEmitter();
      this.onMicrotaskEmpty = new EventEmitter();
      this.onStable = new EventEmitter();
      this.onError = new EventEmitter();
    }
    run(fn, applyThis, applyArgs) {
      return fn.apply(applyThis, applyArgs);
    }
    runGuarded(fn, applyThis, applyArgs) {
      return fn.apply(applyThis, applyArgs);
    }
    runOutsideAngular(fn) {
      return fn();
    }
    runTask(fn, applyThis, applyArgs, name) {
      return fn.apply(applyThis, applyArgs);
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var Testability = class {
    constructor(_ngZone) {
      this._ngZone = _ngZone;
      this._pendingCount = 0;
      this._isZoneStable = true;
      this._didWork = false;
      this._callbacks = [];
      this.taskTrackingZone = null;
      this._watchAngularEvents();
      _ngZone.run(() => {
        this.taskTrackingZone =
            typeof Zone == 'undefined' ? null : Zone.current.get('TaskTrackingZone');
      });
    }
    _watchAngularEvents() {
      this._ngZone.onUnstable.subscribe({
        next: () => {
          this._didWork = true;
          this._isZoneStable = false;
        }
      });
      this._ngZone.runOutsideAngular(() => {
        this._ngZone.onStable.subscribe({
          next: () => {
            NgZone.assertNotInAngularZone();
            scheduleMicroTask(() => {
              this._isZoneStable = true;
              this._runCallbacksIfReady();
            });
          }
        });
      });
    }
    increasePendingRequestCount() {
      this._pendingCount += 1;
      this._didWork = true;
      return this._pendingCount;
    }
    decreasePendingRequestCount() {
      this._pendingCount -= 1;
      if (this._pendingCount < 0) {
        throw new Error('pending async requests below zero');
      }
      this._runCallbacksIfReady();
      return this._pendingCount;
    }
    isStable() {
      return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;
    }
    _runCallbacksIfReady() {
      if (this.isStable()) {
        scheduleMicroTask(() => {
          while (this._callbacks.length !== 0) {
            let cb = this._callbacks.pop();
            clearTimeout(cb.timeoutId);
            cb.doneCb(this._didWork);
          }
          this._didWork = false;
        });
      } else {
        let pending = this.getPendingTasks();
        this._callbacks = this._callbacks.filter((cb) => {
          if (cb.updateCb && cb.updateCb(pending)) {
            clearTimeout(cb.timeoutId);
            return false;
          }
          return true;
        });
        this._didWork = true;
      }
    }
    getPendingTasks() {
      if (!this.taskTrackingZone) {
        return [];
      }
      return this.taskTrackingZone.macroTasks.map((t) => {
        return {source: t.source, creationLocation: t.creationLocation, data: t.data};
      });
    }
    addCallback(cb, timeout2, updateCb) {
      let timeoutId = -1;
      if (timeout2 && timeout2 > 0) {
        timeoutId = setTimeout(() => {
          this._callbacks = this._callbacks.filter((cb2) => cb2.timeoutId !== timeoutId);
          cb(this._didWork, this.getPendingTasks());
        }, timeout2);
      }
      this._callbacks.push({doneCb: cb, timeoutId, updateCb});
    }
    whenStable(doneCb, timeout2, updateCb) {
      if (updateCb && !this.taskTrackingZone) {
        throw new Error(
            'Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');
      }
      this.addCallback(doneCb, timeout2, updateCb);
      this._runCallbacksIfReady();
    }
    getPendingRequestCount() {
      return this._pendingCount;
    }
    findProviders(using2, provider, exactMatch) {
      return [];
    }
  };
  Testability.\u0275fac = function Testability_Factory(t) {
    return new (t || Testability)(\u0275\u0275inject(NgZone));
  };
  Testability.\u0275prov =
      \u0275\u0275defineInjectable({token: Testability, factory: Testability.\u0275fac});
  Testability.ctorParameters = () => [{type: NgZone}];
  (function() {
    setClassMetadata(Testability, [{type: Injectable}], function() {
      return [{type: NgZone}];
    }, null);
  })();
  var TestabilityRegistry = class {
    constructor() {
      this._applications = new Map();
      _testabilityGetter.addToWindow(this);
    }
    registerApplication(token, testability) {
      this._applications.set(token, testability);
    }
    unregisterApplication(token) {
      this._applications.delete(token);
    }
    unregisterAllApplications() {
      this._applications.clear();
    }
    getTestability(elem) {
      return this._applications.get(elem) || null;
    }
    getAllTestabilities() {
      return Array.from(this._applications.values());
    }
    getAllRootElements() {
      return Array.from(this._applications.keys());
    }
    findTestabilityInTree(elem, findInAncestors = true) {
      return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
    }
  };
  TestabilityRegistry.\u0275fac = function TestabilityRegistry_Factory(t) {
    return new (t || TestabilityRegistry)();
  };
  TestabilityRegistry.\u0275prov = \u0275\u0275defineInjectable(
      {token: TestabilityRegistry, factory: TestabilityRegistry.\u0275fac});
  TestabilityRegistry.ctorParameters = () => [];
  (function() {
    setClassMetadata(TestabilityRegistry, [{type: Injectable}], function() {
      return [];
    }, null);
  })();
  var _NoopGetTestability = class {
    addToWindow(registry) {}
    findTestabilityInTree(registry, elem, findInAncestors) {
      return null;
    }
  };
  function setTestabilityGetter(getter) {
    _testabilityGetter = getter;
  }
  var _testabilityGetter = new _NoopGetTestability();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var _devMode = true;
  var _runModeLocked = false;
  function isDevMode() {
    _runModeLocked = true;
    return _devMode;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var _platform;
  var compileNgModuleFactory = compileNgModuleFactory__POST_R3__;
  function compileNgModuleFactory__POST_R3__(injector, options, moduleType) {
    ngDevMode && assertNgModuleType(moduleType);
    const moduleFactory = new NgModuleFactory$1(moduleType);
    if (typeof ngJitMode !== 'undefined' && !ngJitMode) {
      return Promise.resolve(moduleFactory);
    }
    const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);
    setJitOptions({
      defaultEncapsulation: _lastDefined(compilerOptions.map((opts) => opts.defaultEncapsulation)),
      preserveWhitespaces: _lastDefined(compilerOptions.map((opts) => opts.preserveWhitespaces))
    });
    if (isComponentResourceResolutionQueueEmpty()) {
      return Promise.resolve(moduleFactory);
    }
    const compilerProviders = _mergeArrays(compilerOptions.map((o) => o.providers));
    if (compilerProviders.length === 0) {
      return Promise.resolve(moduleFactory);
    }
    const compiler = getCompilerFacade();
    const compilerInjector = Injector.create({providers: compilerProviders});
    const resourceLoader = compilerInjector.get(compiler.ResourceLoader);
    return resolveComponentResources((url) => Promise.resolve(resourceLoader.get(url)))
        .then(() => moduleFactory);
  }
  function publishDefaultGlobalUtils__POST_R3__() {
    ngDevMode && publishDefaultGlobalUtils();
  }
  var publishDefaultGlobalUtils$1 = publishDefaultGlobalUtils__POST_R3__;
  var isBoundToModule = isBoundToModule__POST_R3__;
  function isBoundToModule__POST_R3__(cf) {
    return cf.isBoundToModule;
  }
  var ALLOW_MULTIPLE_PLATFORMS = new InjectionToken('AllowMultipleToken');
  var NgProbeToken = class {
    constructor(name, token) {
      this.name = name;
      this.token = token;
    }
  };
  function createPlatform(injector) {
    if (_platform && !_platform.destroyed &&
        !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
      throw new Error(
          'There can be only one platform. Destroy the previous one to create a new one.');
    }
    publishDefaultGlobalUtils$1();
    _platform = injector.get(PlatformRef);
    const inits = injector.get(PLATFORM_INITIALIZER, null);
    if (inits) inits.forEach((init) => init());
    return _platform;
  }
  function createPlatformFactory(parentPlatformFactory, name, providers = []) {
    const desc = `Platform: ${name}`;
    const marker = new InjectionToken(desc);
    return (extraProviders = []) => {
      let platform = getPlatform();
      if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
        if (parentPlatformFactory) {
          parentPlatformFactory(
              providers.concat(extraProviders).concat({provide: marker, useValue: true}));
        } else {
          const injectedProviders =
              providers.concat(extraProviders).concat({provide: marker, useValue: true}, {
                provide: INJECTOR_SCOPE,
                useValue: 'platform'
              });
          createPlatform(Injector.create({providers: injectedProviders, name: desc}));
        }
      }
      return assertPlatform(marker);
    };
  }
  function assertPlatform(requiredToken) {
    const platform = getPlatform();
    if (!platform) {
      throw new Error('No platform exists!');
    }
    if (!platform.injector.get(requiredToken, null)) {
      throw new Error(
          'A platform with a different configuration has been created. Please destroy it first.');
    }
    return platform;
  }
  function getPlatform() {
    return _platform && !_platform.destroyed ? _platform : null;
  }
  var PlatformRef = class {
    constructor(_injector) {
      this._injector = _injector;
      this._modules = [];
      this._destroyListeners = [];
      this._destroyed = false;
    }
    bootstrapModuleFactory(moduleFactory, options) {
      const ngZoneOption = options ? options.ngZone : void 0;
      const ngZoneEventCoalescing = options && options.ngZoneEventCoalescing || false;
      const ngZone = getNgZone(ngZoneOption, ngZoneEventCoalescing);
      const providers = [{provide: NgZone, useValue: ngZone}];
      return ngZone.run(() => {
        const ngZoneInjector = Injector.create(
            {providers, parent: this.injector, name: moduleFactory.moduleType.name});
        const moduleRef = moduleFactory.create(ngZoneInjector);
        const exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
        if (!exceptionHandler) {
          throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');
        }
        ngZone.runOutsideAngular(() => {
          const subscription = ngZone.onError.subscribe({
            next: (error) => {
              exceptionHandler.handleError(error);
            }
          });
          moduleRef.onDestroy(() => {
            remove(this._modules, moduleRef);
            subscription.unsubscribe();
          });
        });
        return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
          const initStatus = moduleRef.injector.get(ApplicationInitStatus);
          initStatus.runInitializers();
          return initStatus.donePromise.then(() => {
            if (ivyEnabled) {
              const localeId = moduleRef.injector.get(LOCALE_ID$1, DEFAULT_LOCALE_ID);
              setLocaleId(localeId || DEFAULT_LOCALE_ID);
            }
            this._moduleDoBootstrap(moduleRef);
            return moduleRef;
          });
        });
      });
    }
    bootstrapModule(moduleType, compilerOptions = []) {
      const options = optionsReducer({}, compilerOptions);
      return compileNgModuleFactory(this.injector, options, moduleType)
          .then((moduleFactory) => this.bootstrapModuleFactory(moduleFactory, options));
    }
    _moduleDoBootstrap(moduleRef) {
      const appRef = moduleRef.injector.get(ApplicationRef);
      if (moduleRef._bootstrapComponents.length > 0) {
        moduleRef._bootstrapComponents.forEach((f) => appRef.bootstrap(f));
      } else if (moduleRef.instance.ngDoBootstrap) {
        moduleRef.instance.ngDoBootstrap(appRef);
      } else {
        throw new Error(`The module ${
            stringify(
                moduleRef.instance
                    .constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);
      }
      this._modules.push(moduleRef);
    }
    onDestroy(callback) {
      this._destroyListeners.push(callback);
    }
    get injector() {
      return this._injector;
    }
    destroy() {
      if (this._destroyed) {
        throw new Error('The platform has already been destroyed!');
      }
      this._modules.slice().forEach((module) => module.destroy());
      this._destroyListeners.forEach((listener) => listener());
      this._destroyed = true;
    }
    get destroyed() {
      return this._destroyed;
    }
  };
  PlatformRef.\u0275fac = function PlatformRef_Factory(t) {
    return new (t || PlatformRef)(\u0275\u0275inject(Injector));
  };
  PlatformRef.\u0275prov =
      \u0275\u0275defineInjectable({token: PlatformRef, factory: PlatformRef.\u0275fac});
  PlatformRef.ctorParameters = () => [{type: Injector}];
  (function() {
    setClassMetadata(PlatformRef, [{type: Injectable}], function() {
      return [{type: Injector}];
    }, null);
  })();
  function getNgZone(ngZoneOption, ngZoneEventCoalescing) {
    let ngZone;
    if (ngZoneOption === 'noop') {
      ngZone = new NoopNgZone();
    } else {
      ngZone = (ngZoneOption === 'zone.js' ? void 0 : ngZoneOption) || new NgZone({
                 enableLongStackTrace: isDevMode(),
                 shouldCoalesceEventChangeDetection: ngZoneEventCoalescing
               });
    }
    return ngZone;
  }
  function _callAndReportToErrorHandler(errorHandler2, ngZone, callback) {
    try {
      const result = callback();
      if (isPromise2(result)) {
        return result.catch((e) => {
          ngZone.runOutsideAngular(() => errorHandler2.handleError(e));
          throw e;
        });
      }
      return result;
    } catch (e) {
      ngZone.runOutsideAngular(() => errorHandler2.handleError(e));
      throw e;
    }
  }
  function optionsReducer(dst, objs) {
    if (Array.isArray(objs)) {
      dst = objs.reduce(optionsReducer, dst);
    } else {
      dst = Object.assign(Object.assign({}, dst), objs);
    }
    return dst;
  }
  var ApplicationRef = class {
    constructor(
        _zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus) {
      this._zone = _zone;
      this._console = _console;
      this._injector = _injector;
      this._exceptionHandler = _exceptionHandler;
      this._componentFactoryResolver = _componentFactoryResolver;
      this._initStatus = _initStatus;
      this._bootstrapListeners = [];
      this._views = [];
      this._runningTick = false;
      this._stable = true;
      this.componentTypes = [];
      this.components = [];
      this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({
        next: () => {
          this._zone.run(() => {
            this.tick();
          });
        }
      });
      const isCurrentlyStable = new Observable((observer) => {
        this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks &&
            !this._zone.hasPendingMicrotasks;
        this._zone.runOutsideAngular(() => {
          observer.next(this._stable);
          observer.complete();
        });
      });
      const isStable = new Observable((observer) => {
        let stableSub;
        this._zone.runOutsideAngular(() => {
          stableSub = this._zone.onStable.subscribe(() => {
            NgZone.assertNotInAngularZone();
            scheduleMicroTask(() => {
              if (!this._stable && !this._zone.hasPendingMacrotasks &&
                  !this._zone.hasPendingMicrotasks) {
                this._stable = true;
                observer.next(true);
              }
            });
          });
        });
        const unstableSub = this._zone.onUnstable.subscribe(() => {
          NgZone.assertInAngularZone();
          if (this._stable) {
            this._stable = false;
            this._zone.runOutsideAngular(() => {
              observer.next(false);
            });
          }
        });
        return () => {
          stableSub.unsubscribe();
          unstableSub.unsubscribe();
        };
      });
      this.isStable = merge(isCurrentlyStable, isStable.pipe(share()));
    }
    bootstrap(componentOrFactory, rootSelectorOrNode) {
      if (!this._initStatus.done) {
        throw new Error(
            'Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');
      }
      let componentFactory;
      if (componentOrFactory instanceof ComponentFactory) {
        componentFactory = componentOrFactory;
      } else {
        componentFactory =
            this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);
      }
      this.componentTypes.push(componentFactory.componentType);
      const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef);
      const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
      const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);
      const nativeElement = compRef.location.nativeElement;
      const testability = compRef.injector.get(Testability, null);
      const testabilityRegistry = testability && compRef.injector.get(TestabilityRegistry);
      if (testability && testabilityRegistry) {
        testabilityRegistry.registerApplication(nativeElement, testability);
      }
      compRef.onDestroy(() => {
        this.detachView(compRef.hostView);
        remove(this.components, compRef);
        if (testabilityRegistry) {
          testabilityRegistry.unregisterApplication(nativeElement);
        }
      });
      this._loadComponent(compRef);
      if (isDevMode()) {
        this._console.log(
            `Angular is running in development mode. Call enableProdMode() to enable production mode.`);
      }
      return compRef;
    }
    tick() {
      if (this._runningTick) {
        throw new Error('ApplicationRef.tick is called recursively');
      }
      try {
        this._runningTick = true;
        for (let view of this._views) {
          view.detectChanges();
        }
        if ((typeof ngDevMode === 'undefined' || ngDevMode) && isDevMode()) {
          for (let view of this._views) {
            view.checkNoChanges();
          }
        }
      } catch (e) {
        this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e));
      } finally {
        this._runningTick = false;
      }
    }
    attachView(viewRef) {
      const view = viewRef;
      this._views.push(view);
      view.attachToAppRef(this);
    }
    detachView(viewRef) {
      const view = viewRef;
      remove(this._views, view);
      view.detachFromAppRef();
    }
    _loadComponent(componentRef) {
      this.attachView(componentRef.hostView);
      this.tick();
      this.components.push(componentRef);
      const listeners =
          this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);
      listeners.forEach((listener) => listener(componentRef));
    }
    ngOnDestroy() {
      this._views.slice().forEach((view) => view.destroy());
      this._onMicrotaskEmptySubscription.unsubscribe();
    }
    get viewCount() {
      return this._views.length;
    }
  };
  ApplicationRef.\u0275fac = function ApplicationRef_Factory(t) {
    return new (t || ApplicationRef)(
        \u0275\u0275inject(NgZone), \u0275\u0275inject(Console), \u0275\u0275inject(Injector),
        \u0275\u0275inject(ErrorHandler), \u0275\u0275inject(ComponentFactoryResolver),
        \u0275\u0275inject(ApplicationInitStatus));
  };
  ApplicationRef.\u0275prov =
      \u0275\u0275defineInjectable({token: ApplicationRef, factory: ApplicationRef.\u0275fac});
  ApplicationRef.ctorParameters = () =>
      [{type: NgZone}, {type: Console}, {type: Injector}, {type: ErrorHandler},
       {type: ComponentFactoryResolver}, {type: ApplicationInitStatus}];
  (function() {
    setClassMetadata(ApplicationRef, [{type: Injectable}], function() {
      return [
        {type: NgZone}, {type: Console}, {type: Injector}, {type: ErrorHandler},
        {type: ComponentFactoryResolver}, {type: ApplicationInitStatus}
      ];
    }, null);
  })();
  function remove(list, el) {
    const index = list.indexOf(el);
    if (index > -1) {
      list.splice(index, 1);
    }
  }
  function _lastDefined(args) {
    for (let i = args.length - 1; i >= 0; i--) {
      if (args[i] !== void 0) {
        return args[i];
      }
    }
    return void 0;
  }
  function _mergeArrays(parts) {
    const result = [];
    parts.forEach((part) => part && result.push(...part));
    return result;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NgModuleFactoryLoader = class {};
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var _SEPARATOR = '#';
  var FACTORY_CLASS_SUFFIX = 'NgFactory';
  var SystemJsNgModuleLoaderConfig = class {};
  var DEFAULT_CONFIG = {factoryPathPrefix: '', factoryPathSuffix: '.ngfactory'};
  var SystemJsNgModuleLoader = class {
    constructor(_compiler, config2) {
      this._compiler = _compiler;
      this._config = config2 || DEFAULT_CONFIG;
    }
    load(path) {
      const legacyOfflineMode = !ivyEnabled && this._compiler instanceof Compiler;
      return legacyOfflineMode ? this.loadFactory(path) : this.loadAndCompile(path);
    }
    loadAndCompile(path) {
      let [module, exportName] = path.split(_SEPARATOR);
      if (exportName === void 0) {
        exportName = 'default';
      }
      return System.import(module)
          .then((module2) => module2[exportName])
          .then((type) => checkNotEmpty(type, module, exportName))
          .then((type) => this._compiler.compileModuleAsync(type));
    }
    loadFactory(path) {
      let [module, exportName] = path.split(_SEPARATOR);
      let factoryClassSuffix = FACTORY_CLASS_SUFFIX;
      if (exportName === void 0) {
        exportName = 'default';
        factoryClassSuffix = '';
      }
      return System.import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)
          .then((module2) => module2[exportName + factoryClassSuffix])
          .then((factory) => checkNotEmpty(factory, module, exportName));
    }
  };
  SystemJsNgModuleLoader.\u0275fac = function SystemJsNgModuleLoader_Factory(t) {
    return new (t || SystemJsNgModuleLoader)(
        \u0275\u0275inject(Compiler), \u0275\u0275inject(SystemJsNgModuleLoaderConfig, 8));
  };
  SystemJsNgModuleLoader.\u0275prov = \u0275\u0275defineInjectable(
      {token: SystemJsNgModuleLoader, factory: SystemJsNgModuleLoader.\u0275fac});
  SystemJsNgModuleLoader.ctorParameters = () =>
      [{type: Compiler}, {type: SystemJsNgModuleLoaderConfig, decorators: [{type: Optional}]}];
  (function() {
    setClassMetadata(SystemJsNgModuleLoader, [{type: Injectable}], function() {
      return [
        {type: Compiler}, {type: SystemJsNgModuleLoaderConfig, decorators: [{type: Optional}]}
      ];
    }, null);
  })();
  function checkNotEmpty(value, modulePath, exportName) {
    if (!value) {
      throw new Error(`Cannot find '${exportName}' in '${modulePath}'`);
    }
    return value;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var _nativeNodeToDebugNode = new Map();
  function getDebugNodeR2__POST_R3__(_nativeNode) {
    return null;
  }
  var getDebugNodeR2 = getDebugNodeR2__POST_R3__;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var _CORE_PLATFORM_PROVIDERS = [
    {provide: PLATFORM_ID, useValue: 'unknown'}, {provide: PlatformRef, deps: [Injector]},
    {provide: TestabilityRegistry, deps: []}, {provide: Console, deps: []}
  ];
  var platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function _iterableDiffersFactory() {
    return defaultIterableDiffers;
  }
  function _keyValueDiffersFactory() {
    return defaultKeyValueDiffers;
  }
  function _localeFactory(locale) {
    locale = locale || getGlobalLocale();
    if (ivyEnabled) {
      setLocaleId(locale);
    }
    return locale;
  }
  function getGlobalLocale() {
    if (typeof ngI18nClosureMode !== 'undefined' && ngI18nClosureMode &&
        typeof goog !== 'undefined' && goog.LOCALE !== 'en') {
      return goog.LOCALE;
    } else {
      return ivyEnabled && typeof $localize !== 'undefined' && $localize.locale ||
          DEFAULT_LOCALE_ID;
    }
  }
  var \u02750$f = USD_CURRENCY_CODE;
  var APPLICATION_MODULE_PROVIDERS = [
    {
      provide: ApplicationRef,
      useClass: ApplicationRef,
      deps:
          [NgZone, Console, Injector, ErrorHandler, ComponentFactoryResolver, ApplicationInitStatus]
    },
    {provide: SCHEDULER, deps: [NgZone], useFactory: zoneSchedulerFactory}, {
      provide: ApplicationInitStatus,
      useClass: ApplicationInitStatus,
      deps: [[new Optional(), APP_INITIALIZER]]
    },
    {provide: Compiler, useClass: Compiler, deps: []}, APP_ID_RANDOM_PROVIDER,
    {provide: IterableDiffers, useFactory: _iterableDiffersFactory, deps: []},
    {provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory, deps: []}, {
      provide: LOCALE_ID$1,
      useFactory: _localeFactory,
      deps: [[new Inject(LOCALE_ID$1), new Optional(), new SkipSelf()]]
    },
    {provide: DEFAULT_CURRENCY_CODE, useValue: \u02750$f}
  ];
  function zoneSchedulerFactory(ngZone) {
    let queue2 = [];
    ngZone.onStable.subscribe(() => {
      while (queue2.length) {
        queue2.pop()();
      }
    });
    return function(fn) {
      queue2.push(fn);
    };
  }
  var ApplicationModule = class {
    constructor(appRef) {}
  };
  ApplicationModule.\u0275mod = \u0275\u0275defineNgModule({type: ApplicationModule});
  ApplicationModule.\u0275inj = \u0275\u0275defineInjector({
    factory: function ApplicationModule_Factory(t) {
      return new (t || ApplicationModule)(\u0275\u0275inject(ApplicationRef));
    },
    providers: APPLICATION_MODULE_PROVIDERS
  });
  ApplicationModule.ctorParameters = () => [{type: ApplicationRef}];
  (function() {
    setClassMetadata(
        ApplicationModule,
        [{type: NgModule, args: [{providers: APPLICATION_MODULE_PROVIDERS}]}], function() {
          return [{type: ApplicationRef}];
        }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ViewAction;
  (function(ViewAction2) {
    ViewAction2[ViewAction2['CreateViewNodes'] = 0] = 'CreateViewNodes';
    ViewAction2[ViewAction2['CheckNoChanges'] = 1] = 'CheckNoChanges';
    ViewAction2[ViewAction2['CheckNoChangesProjectedViews'] = 2] = 'CheckNoChangesProjectedViews';
    ViewAction2[ViewAction2['CheckAndUpdate'] = 3] = 'CheckAndUpdate';
    ViewAction2[ViewAction2['CheckAndUpdateProjectedViews'] = 4] = 'CheckAndUpdateProjectedViews';
    ViewAction2[ViewAction2['Destroy'] = 5] = 'Destroy';
  })(ViewAction || (ViewAction = {}));
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var providerOverrides = new Map();
  var providerOverridesWithScope = new Map();
  var viewDefOverrides = new Map();
  var DebugAction;
  (function(DebugAction2) {
    DebugAction2[DebugAction2['create'] = 0] = 'create';
    DebugAction2[DebugAction2['detectChanges'] = 1] = 'detectChanges';
    DebugAction2[DebugAction2['checkNoChanges'] = 2] = 'checkNoChanges';
    DebugAction2[DebugAction2['destroy'] = 3] = 'destroy';
    DebugAction2[DebugAction2['handleEvent'] = 4] = 'handleEvent';
  })(DebugAction || (DebugAction = {}));
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  if (typeof ngDevMode !== 'undefined' && ngDevMode) {
    _global.$localize = _global.$localize || function() {
      throw new Error(
          'It looks like your application or one of its dependencies is using i18n.\nAngular 9 introduced a global `$localize()` function that needs to be loaded.\nPlease run `ng add @angular/localize` from the Angular CLI.\n(For non-CLI projects, add `import \'@angular/localize/init\';` to your `polyfills.ts` file.\nFor server-side rendering applications add the import to your `main.server.ts` file.)');
    };
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */

  // external/npm/node_modules/@angular/common/fesm2015/common.js
  /**
   * @license Angular v11.0.9
   * (c) 2010-2020 Google LLC. https://angular.io/
   * License: MIT
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var _DOM = null;
  function getDOM() {
    return _DOM;
  }
  function setRootDomAdapter(adapter) {
    if (!_DOM) {
      _DOM = adapter;
    }
  }
  var DomAdapter = class {};
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var DOCUMENT2 = new InjectionToken('DocumentToken');
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var PlatformLocation = class {};
  PlatformLocation.\u0275fac = function PlatformLocation_Factory(t) {
    return new (t || PlatformLocation)();
  };
  PlatformLocation.\u0275prov = \u0275\u0275defineInjectable(
      {factory: useBrowserPlatformLocation, token: PlatformLocation, providedIn: 'platform'});
  (function() {
    setClassMetadata(
        PlatformLocation, [{
          type: Injectable,
          args: [{providedIn: 'platform', useFactory: useBrowserPlatformLocation}]
        }],
        null, null);
  })();
  function useBrowserPlatformLocation() {
    return \u0275\u0275inject(BrowserPlatformLocation);
  }
  var LOCATION_INITIALIZED = new InjectionToken('Location Initialized');
  var BrowserPlatformLocation = class extends PlatformLocation {
    constructor(_doc) {
      super();
      this._doc = _doc;
      this._init();
    }
    _init() {
      this.location = getDOM().getLocation();
      this._history = getDOM().getHistory();
    }
    getBaseHrefFromDOM() {
      return getDOM().getBaseHref(this._doc);
    }
    onPopState(fn) {
      getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('popstate', fn, false);
    }
    onHashChange(fn) {
      getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('hashchange', fn, false);
    }
    get href() {
      return this.location.href;
    }
    get protocol() {
      return this.location.protocol;
    }
    get hostname() {
      return this.location.hostname;
    }
    get port() {
      return this.location.port;
    }
    get pathname() {
      return this.location.pathname;
    }
    get search() {
      return this.location.search;
    }
    get hash() {
      return this.location.hash;
    }
    set pathname(newPath) {
      this.location.pathname = newPath;
    }
    pushState(state, title, url) {
      if (supportsState()) {
        this._history.pushState(state, title, url);
      } else {
        this.location.hash = url;
      }
    }
    replaceState(state, title, url) {
      if (supportsState()) {
        this._history.replaceState(state, title, url);
      } else {
        this.location.hash = url;
      }
    }
    forward() {
      this._history.forward();
    }
    back() {
      this._history.back();
    }
    getState() {
      return this._history.state;
    }
  };
  BrowserPlatformLocation.\u0275fac = function BrowserPlatformLocation_Factory(t) {
    return new (t || BrowserPlatformLocation)(\u0275\u0275inject(DOCUMENT2));
  };
  BrowserPlatformLocation.\u0275prov = \u0275\u0275defineInjectable({
    factory: createBrowserPlatformLocation,
    token: BrowserPlatformLocation,
    providedIn: 'platform'
  });
  BrowserPlatformLocation.ctorParameters =
      () => [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]}];
  (function() {
    setClassMetadata(
        BrowserPlatformLocation, [{
          type: Injectable,
          args: [{providedIn: 'platform', useFactory: createBrowserPlatformLocation}]
        }],
        function() {
          return [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]}];
        },
        null);
  })();
  function supportsState() {
    return !!window.history.pushState;
  }
  function createBrowserPlatformLocation() {
    return new BrowserPlatformLocation(\u0275\u0275inject(DOCUMENT2));
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function joinWithSlash(start, end) {
    if (start.length == 0) {
      return end;
    }
    if (end.length == 0) {
      return start;
    }
    let slashes = 0;
    if (start.endsWith('/')) {
      slashes++;
    }
    if (end.startsWith('/')) {
      slashes++;
    }
    if (slashes == 2) {
      return start + end.substring(1);
    }
    if (slashes == 1) {
      return start + end;
    }
    return start + '/' + end;
  }
  function stripTrailingSlash(url) {
    const match2 = url.match(/#|\?|$/);
    const pathEndIdx = match2 && match2.index || url.length;
    const droppedSlashIdx = pathEndIdx - (url[pathEndIdx - 1] === '/' ? 1 : 0);
    return url.slice(0, droppedSlashIdx) + url.slice(pathEndIdx);
  }
  function normalizeQueryParams(params) {
    return params && params[0] !== '?' ? '?' + params : params;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var LocationStrategy = class {};
  LocationStrategy.\u0275fac = function LocationStrategy_Factory(t) {
    return new (t || LocationStrategy)();
  };
  LocationStrategy.\u0275prov = \u0275\u0275defineInjectable(
      {factory: provideLocationStrategy, token: LocationStrategy, providedIn: 'root'});
  (function() {
    setClassMetadata(
        LocationStrategy,
        [{type: Injectable, args: [{providedIn: 'root', useFactory: provideLocationStrategy}]}],
        null, null);
  })();
  function provideLocationStrategy(platformLocation) {
    const location2 = \u0275\u0275inject(DOCUMENT2).location;
    return new PathLocationStrategy(
        \u0275\u0275inject(PlatformLocation), location2 && location2.origin || '');
  }
  var APP_BASE_HREF = new InjectionToken('appBaseHref');
  var PathLocationStrategy = class extends LocationStrategy {
    constructor(_platformLocation, href) {
      super();
      this._platformLocation = _platformLocation;
      if (href == null) {
        href = this._platformLocation.getBaseHrefFromDOM();
      }
      if (href == null) {
        throw new Error(
            `No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.`);
      }
      this._baseHref = href;
    }
    onPopState(fn) {
      this._platformLocation.onPopState(fn);
      this._platformLocation.onHashChange(fn);
    }
    getBaseHref() {
      return this._baseHref;
    }
    prepareExternalUrl(internal) {
      return joinWithSlash(this._baseHref, internal);
    }
    path(includeHash = false) {
      const pathname =
          this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search);
      const hash = this._platformLocation.hash;
      return hash && includeHash ? `${pathname}${hash}` : pathname;
    }
    pushState(state, title, url, queryParams) {
      const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
      this._platformLocation.pushState(state, title, externalUrl);
    }
    replaceState(state, title, url, queryParams) {
      const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
      this._platformLocation.replaceState(state, title, externalUrl);
    }
    forward() {
      this._platformLocation.forward();
    }
    back() {
      this._platformLocation.back();
    }
  };
  PathLocationStrategy.\u0275fac = function PathLocationStrategy_Factory(t) {
    return new (t || PathLocationStrategy)(
        \u0275\u0275inject(PlatformLocation), \u0275\u0275inject(APP_BASE_HREF, 8));
  };
  PathLocationStrategy.\u0275prov = \u0275\u0275defineInjectable(
      {token: PathLocationStrategy, factory: PathLocationStrategy.\u0275fac});
  PathLocationStrategy.ctorParameters = () => [{type: PlatformLocation}, {
    type: String,
    decorators: [{type: Optional}, {type: Inject, args: [APP_BASE_HREF]}]
  }];
  (function() {
    setClassMetadata(PathLocationStrategy, [{type: Injectable}], function() {
      return [
        {type: PlatformLocation},
        {type: String, decorators: [{type: Optional}, {type: Inject, args: [APP_BASE_HREF]}]}
      ];
    }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var HashLocationStrategy = class extends LocationStrategy {
    constructor(_platformLocation, _baseHref) {
      super();
      this._platformLocation = _platformLocation;
      this._baseHref = '';
      if (_baseHref != null) {
        this._baseHref = _baseHref;
      }
    }
    onPopState(fn) {
      this._platformLocation.onPopState(fn);
      this._platformLocation.onHashChange(fn);
    }
    getBaseHref() {
      return this._baseHref;
    }
    path(includeHash = false) {
      let path = this._platformLocation.hash;
      if (path == null) path = '#';
      return path.length > 0 ? path.substring(1) : path;
    }
    prepareExternalUrl(internal) {
      const url = joinWithSlash(this._baseHref, internal);
      return url.length > 0 ? '#' + url : url;
    }
    pushState(state, title, path, queryParams) {
      let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
      if (url.length == 0) {
        url = this._platformLocation.pathname;
      }
      this._platformLocation.pushState(state, title, url);
    }
    replaceState(state, title, path, queryParams) {
      let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
      if (url.length == 0) {
        url = this._platformLocation.pathname;
      }
      this._platformLocation.replaceState(state, title, url);
    }
    forward() {
      this._platformLocation.forward();
    }
    back() {
      this._platformLocation.back();
    }
  };
  HashLocationStrategy.\u0275fac = function HashLocationStrategy_Factory(t) {
    return new (t || HashLocationStrategy)(
        \u0275\u0275inject(PlatformLocation), \u0275\u0275inject(APP_BASE_HREF, 8));
  };
  HashLocationStrategy.\u0275prov = \u0275\u0275defineInjectable(
      {token: HashLocationStrategy, factory: HashLocationStrategy.\u0275fac});
  HashLocationStrategy.ctorParameters = () => [{type: PlatformLocation}, {
    type: String,
    decorators: [{type: Optional}, {type: Inject, args: [APP_BASE_HREF]}]
  }];
  (function() {
    setClassMetadata(HashLocationStrategy, [{type: Injectable}], function() {
      return [
        {type: PlatformLocation},
        {type: String, decorators: [{type: Optional}, {type: Inject, args: [APP_BASE_HREF]}]}
      ];
    }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var Location = class {
    constructor(platformStrategy, platformLocation) {
      this._subject = new EventEmitter();
      this._urlChangeListeners = [];
      this._platformStrategy = platformStrategy;
      const browserBaseHref = this._platformStrategy.getBaseHref();
      this._platformLocation = platformLocation;
      this._baseHref = stripTrailingSlash(_stripIndexHtml(browserBaseHref));
      this._platformStrategy.onPopState((ev) => {
        this._subject.emit({url: this.path(true), pop: true, state: ev.state, type: ev.type});
      });
    }
    path(includeHash = false) {
      return this.normalize(this._platformStrategy.path(includeHash));
    }
    getState() {
      return this._platformLocation.getState();
    }
    isCurrentPathEqualTo(path, query = '') {
      return this.path() == this.normalize(path + normalizeQueryParams(query));
    }
    normalize(url) {
      return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
    }
    prepareExternalUrl(url) {
      if (url && url[0] !== '/') {
        url = '/' + url;
      }
      return this._platformStrategy.prepareExternalUrl(url);
    }
    go(path, query = '', state = null) {
      this._platformStrategy.pushState(state, '', path, query);
      this._notifyUrlChangeListeners(
          this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
    }
    replaceState(path, query = '', state = null) {
      this._platformStrategy.replaceState(state, '', path, query);
      this._notifyUrlChangeListeners(
          this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
    }
    forward() {
      this._platformStrategy.forward();
    }
    back() {
      this._platformStrategy.back();
    }
    onUrlChange(fn) {
      this._urlChangeListeners.push(fn);
      if (!this._urlChangeSubscription) {
        this._urlChangeSubscription = this.subscribe((v) => {
          this._notifyUrlChangeListeners(v.url, v.state);
        });
      }
    }
    _notifyUrlChangeListeners(url = '', state) {
      this._urlChangeListeners.forEach((fn) => fn(url, state));
    }
    subscribe(onNext, onThrow, onReturn) {
      return this._subject.subscribe({next: onNext, error: onThrow, complete: onReturn});
    }
  };
  Location.\u0275fac = function Location_Factory(t) {
    return new (t || Location)(
        \u0275\u0275inject(LocationStrategy), \u0275\u0275inject(PlatformLocation));
  };
  Location.normalizeQueryParams = normalizeQueryParams;
  Location.joinWithSlash = joinWithSlash;
  Location.stripTrailingSlash = stripTrailingSlash;
  Location.\u0275prov =
      \u0275\u0275defineInjectable({factory: createLocation, token: Location, providedIn: 'root'});
  Location.ctorParameters = () => [{type: LocationStrategy}, {type: PlatformLocation}];
  (function() {
    setClassMetadata(
        Location,
        [{type: Injectable, args: [{providedIn: 'root', useFactory: createLocation}]}], function() {
          return [{type: LocationStrategy}, {type: PlatformLocation}];
        }, null);
  })();
  function createLocation() {
    return new Location(\u0275\u0275inject(LocationStrategy), \u0275\u0275inject(PlatformLocation));
  }
  function _stripBaseHref(baseHref, url) {
    return baseHref && url.startsWith(baseHref) ? url.substring(baseHref.length) : url;
  }
  function _stripIndexHtml(url) {
    return url.replace(/\/index.html$/, '');
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var CURRENCIES_EN = {
    ADP: [void 0, void 0, 0],
    AFN: [void 0, void 0, 0],
    ALL: [void 0, void 0, 0],
    AMD: [void 0, void 0, 2],
    AOA: [void 0, 'Kz'],
    ARS: [void 0, '$'],
    AUD: ['A$', '$'],
    BAM: [void 0, 'KM'],
    BBD: [void 0, '$'],
    BDT: [void 0, '\u09F3'],
    BHD: [void 0, void 0, 3],
    BIF: [void 0, void 0, 0],
    BMD: [void 0, '$'],
    BND: [void 0, '$'],
    BOB: [void 0, 'Bs'],
    BRL: ['R$'],
    BSD: [void 0, '$'],
    BWP: [void 0, 'P'],
    BYN: [void 0, '\u0440.', 2],
    BYR: [void 0, void 0, 0],
    BZD: [void 0, '$'],
    CAD: ['CA$', '$', 2],
    CHF: [void 0, void 0, 2],
    CLF: [void 0, void 0, 4],
    CLP: [void 0, '$', 0],
    CNY: ['CN\xA5', '\xA5'],
    COP: [void 0, '$', 2],
    CRC: [void 0, '\u20A1', 2],
    CUC: [void 0, '$'],
    CUP: [void 0, '$'],
    CZK: [void 0, 'K\u010D', 2],
    DJF: [void 0, void 0, 0],
    DKK: [void 0, 'kr', 2],
    DOP: [void 0, '$'],
    EGP: [void 0, 'E\xA3'],
    ESP: [void 0, '\u20A7', 0],
    EUR: ['\u20AC'],
    FJD: [void 0, '$'],
    FKP: [void 0, '\xA3'],
    GBP: ['\xA3'],
    GEL: [void 0, '\u20BE'],
    GIP: [void 0, '\xA3'],
    GNF: [void 0, 'FG', 0],
    GTQ: [void 0, 'Q'],
    GYD: [void 0, '$', 2],
    HKD: ['HK$', '$'],
    HNL: [void 0, 'L'],
    HRK: [void 0, 'kn'],
    HUF: [void 0, 'Ft', 2],
    IDR: [void 0, 'Rp', 2],
    ILS: ['\u20AA'],
    INR: ['\u20B9'],
    IQD: [void 0, void 0, 0],
    IRR: [void 0, void 0, 0],
    ISK: [void 0, 'kr', 0],
    ITL: [void 0, void 0, 0],
    JMD: [void 0, '$'],
    JOD: [void 0, void 0, 3],
    JPY: ['\xA5', void 0, 0],
    KHR: [void 0, '\u17DB'],
    KMF: [void 0, 'CF', 0],
    KPW: [void 0, '\u20A9', 0],
    KRW: ['\u20A9', void 0, 0],
    KWD: [void 0, void 0, 3],
    KYD: [void 0, '$'],
    KZT: [void 0, '\u20B8'],
    LAK: [void 0, '\u20AD', 0],
    LBP: [void 0, 'L\xA3', 0],
    LKR: [void 0, 'Rs'],
    LRD: [void 0, '$'],
    LTL: [void 0, 'Lt'],
    LUF: [void 0, void 0, 0],
    LVL: [void 0, 'Ls'],
    LYD: [void 0, void 0, 3],
    MGA: [void 0, 'Ar', 0],
    MGF: [void 0, void 0, 0],
    MMK: [void 0, 'K', 0],
    MNT: [void 0, '\u20AE', 2],
    MRO: [void 0, void 0, 0],
    MUR: [void 0, 'Rs', 2],
    MXN: ['MX$', '$'],
    MYR: [void 0, 'RM'],
    NAD: [void 0, '$'],
    NGN: [void 0, '\u20A6'],
    NIO: [void 0, 'C$'],
    NOK: [void 0, 'kr', 2],
    NPR: [void 0, 'Rs'],
    NZD: ['NZ$', '$'],
    OMR: [void 0, void 0, 3],
    PHP: [void 0, '\u20B1'],
    PKR: [void 0, 'Rs', 2],
    PLN: [void 0, 'z\u0142'],
    PYG: [void 0, '\u20B2', 0],
    RON: [void 0, 'lei'],
    RSD: [void 0, void 0, 0],
    RUB: [void 0, '\u20BD'],
    RUR: [void 0, '\u0440.'],
    RWF: [void 0, 'RF', 0],
    SBD: [void 0, '$'],
    SEK: [void 0, 'kr', 2],
    SGD: [void 0, '$'],
    SHP: [void 0, '\xA3'],
    SLL: [void 0, void 0, 0],
    SOS: [void 0, void 0, 0],
    SRD: [void 0, '$'],
    SSP: [void 0, '\xA3'],
    STD: [void 0, void 0, 0],
    STN: [void 0, 'Db'],
    SYP: [void 0, '\xA3', 0],
    THB: [void 0, '\u0E3F'],
    TMM: [void 0, void 0, 0],
    TND: [void 0, void 0, 3],
    TOP: [void 0, 'T$'],
    TRL: [void 0, void 0, 0],
    TRY: [void 0, '\u20BA'],
    TTD: [void 0, '$'],
    TWD: ['NT$', '$', 2],
    TZS: [void 0, void 0, 2],
    UAH: [void 0, '\u20B4'],
    UGX: [void 0, void 0, 0],
    USD: ['$'],
    UYI: [void 0, void 0, 0],
    UYU: [void 0, '$'],
    UYW: [void 0, void 0, 4],
    UZS: [void 0, void 0, 2],
    VEF: [void 0, 'Bs', 2],
    VND: ['\u20AB', void 0, 0],
    VUV: [void 0, void 0, 0],
    XAF: ['FCFA', void 0, 0],
    XCD: ['EC$', '$'],
    XOF: ['CFA', void 0, 0],
    XPF: ['CFPF', void 0, 0],
    XXX: ['\xA4'],
    YER: [void 0, void 0, 0],
    ZAR: [void 0, 'R'],
    ZMK: [void 0, void 0, 0],
    ZMW: [void 0, 'ZK'],
    ZWD: [void 0, void 0, 0]
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NumberFormatStyle;
  (function(NumberFormatStyle2) {
    NumberFormatStyle2[NumberFormatStyle2['Decimal'] = 0] = 'Decimal';
    NumberFormatStyle2[NumberFormatStyle2['Percent'] = 1] = 'Percent';
    NumberFormatStyle2[NumberFormatStyle2['Currency'] = 2] = 'Currency';
    NumberFormatStyle2[NumberFormatStyle2['Scientific'] = 3] = 'Scientific';
  })(NumberFormatStyle || (NumberFormatStyle = {}));
  var Plural;
  (function(Plural2) {
    Plural2[Plural2['Zero'] = 0] = 'Zero';
    Plural2[Plural2['One'] = 1] = 'One';
    Plural2[Plural2['Two'] = 2] = 'Two';
    Plural2[Plural2['Few'] = 3] = 'Few';
    Plural2[Plural2['Many'] = 4] = 'Many';
    Plural2[Plural2['Other'] = 5] = 'Other';
  })(Plural || (Plural = {}));
  var FormStyle;
  (function(FormStyle2) {
    FormStyle2[FormStyle2['Format'] = 0] = 'Format';
    FormStyle2[FormStyle2['Standalone'] = 1] = 'Standalone';
  })(FormStyle || (FormStyle = {}));
  var TranslationWidth;
  (function(TranslationWidth2) {
    TranslationWidth2[TranslationWidth2['Narrow'] = 0] = 'Narrow';
    TranslationWidth2[TranslationWidth2['Abbreviated'] = 1] = 'Abbreviated';
    TranslationWidth2[TranslationWidth2['Wide'] = 2] = 'Wide';
    TranslationWidth2[TranslationWidth2['Short'] = 3] = 'Short';
  })(TranslationWidth || (TranslationWidth = {}));
  var FormatWidth;
  (function(FormatWidth2) {
    FormatWidth2[FormatWidth2['Short'] = 0] = 'Short';
    FormatWidth2[FormatWidth2['Medium'] = 1] = 'Medium';
    FormatWidth2[FormatWidth2['Long'] = 2] = 'Long';
    FormatWidth2[FormatWidth2['Full'] = 3] = 'Full';
  })(FormatWidth || (FormatWidth = {}));
  var NumberSymbol;
  (function(NumberSymbol2) {
    NumberSymbol2[NumberSymbol2['Decimal'] = 0] = 'Decimal';
    NumberSymbol2[NumberSymbol2['Group'] = 1] = 'Group';
    NumberSymbol2[NumberSymbol2['List'] = 2] = 'List';
    NumberSymbol2[NumberSymbol2['PercentSign'] = 3] = 'PercentSign';
    NumberSymbol2[NumberSymbol2['PlusSign'] = 4] = 'PlusSign';
    NumberSymbol2[NumberSymbol2['MinusSign'] = 5] = 'MinusSign';
    NumberSymbol2[NumberSymbol2['Exponential'] = 6] = 'Exponential';
    NumberSymbol2[NumberSymbol2['SuperscriptingExponent'] = 7] = 'SuperscriptingExponent';
    NumberSymbol2[NumberSymbol2['PerMille'] = 8] = 'PerMille';
    NumberSymbol2[NumberSymbol2['Infinity'] = 9] = 'Infinity';
    NumberSymbol2[NumberSymbol2['NaN'] = 10] = 'NaN';
    NumberSymbol2[NumberSymbol2['TimeSeparator'] = 11] = 'TimeSeparator';
    NumberSymbol2[NumberSymbol2['CurrencyDecimal'] = 12] = 'CurrencyDecimal';
    NumberSymbol2[NumberSymbol2['CurrencyGroup'] = 13] = 'CurrencyGroup';
  })(NumberSymbol || (NumberSymbol = {}));
  var WeekDay;
  (function(WeekDay2) {
    WeekDay2[WeekDay2['Sunday'] = 0] = 'Sunday';
    WeekDay2[WeekDay2['Monday'] = 1] = 'Monday';
    WeekDay2[WeekDay2['Tuesday'] = 2] = 'Tuesday';
    WeekDay2[WeekDay2['Wednesday'] = 3] = 'Wednesday';
    WeekDay2[WeekDay2['Thursday'] = 4] = 'Thursday';
    WeekDay2[WeekDay2['Friday'] = 5] = 'Friday';
    WeekDay2[WeekDay2['Saturday'] = 6] = 'Saturday';
  })(WeekDay || (WeekDay = {}));
  function getLocaleId2(locale) {
    return findLocaleData(locale)[LocaleDataIndex.LocaleId];
  }
  function getLocaleDayPeriods(locale, formStyle, width) {
    const data = findLocaleData(locale);
    const amPmData =
        [data[LocaleDataIndex.DayPeriodsFormat], data[LocaleDataIndex.DayPeriodsStandalone]];
    const amPm = getLastDefinedValue(amPmData, formStyle);
    return getLastDefinedValue(amPm, width);
  }
  function getLocaleDayNames(locale, formStyle, width) {
    const data = findLocaleData(locale);
    const daysData = [data[LocaleDataIndex.DaysFormat], data[LocaleDataIndex.DaysStandalone]];
    const days = getLastDefinedValue(daysData, formStyle);
    return getLastDefinedValue(days, width);
  }
  function getLocaleMonthNames(locale, formStyle, width) {
    const data = findLocaleData(locale);
    const monthsData = [data[LocaleDataIndex.MonthsFormat], data[LocaleDataIndex.MonthsStandalone]];
    const months = getLastDefinedValue(monthsData, formStyle);
    return getLastDefinedValue(months, width);
  }
  function getLocaleEraNames(locale, width) {
    const data = findLocaleData(locale);
    const erasData = data[LocaleDataIndex.Eras];
    return getLastDefinedValue(erasData, width);
  }
  function getLocaleDateFormat(locale, width) {
    const data = findLocaleData(locale);
    return getLastDefinedValue(data[LocaleDataIndex.DateFormat], width);
  }
  function getLocaleTimeFormat(locale, width) {
    const data = findLocaleData(locale);
    return getLastDefinedValue(data[LocaleDataIndex.TimeFormat], width);
  }
  function getLocaleDateTimeFormat(locale, width) {
    const data = findLocaleData(locale);
    const dateTimeFormatData = data[LocaleDataIndex.DateTimeFormat];
    return getLastDefinedValue(dateTimeFormatData, width);
  }
  function getLocaleNumberSymbol(locale, symbol) {
    const data = findLocaleData(locale);
    const res = data[LocaleDataIndex.NumberSymbols][symbol];
    if (typeof res === 'undefined') {
      if (symbol === NumberSymbol.CurrencyDecimal) {
        return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Decimal];
      } else if (symbol === NumberSymbol.CurrencyGroup) {
        return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Group];
      }
    }
    return res;
  }
  function getLocaleNumberFormat(locale, type) {
    const data = findLocaleData(locale);
    return data[LocaleDataIndex.NumberFormats][type];
  }
  function getLocaleCurrencies(locale) {
    const data = findLocaleData(locale);
    return data[LocaleDataIndex.Currencies];
  }
  var getLocalePluralCase2 = getLocalePluralCase;
  function checkFullData(data) {
    if (!data[LocaleDataIndex.ExtraData]) {
      throw new Error(`Missing extra locale data for the locale "${
          data[LocaleDataIndex
                   .LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`);
    }
  }
  function getLocaleExtraDayPeriodRules(locale) {
    const data = findLocaleData(locale);
    checkFullData(data);
    const rules = data[LocaleDataIndex.ExtraData][2] || [];
    return rules.map((rule) => {
      if (typeof rule === 'string') {
        return extractTime(rule);
      }
      return [extractTime(rule[0]), extractTime(rule[1])];
    });
  }
  function getLocaleExtraDayPeriods(locale, formStyle, width) {
    const data = findLocaleData(locale);
    checkFullData(data);
    const dayPeriodsData = [data[LocaleDataIndex.ExtraData][0], data[LocaleDataIndex.ExtraData][1]];
    const dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];
    return getLastDefinedValue(dayPeriods, width) || [];
  }
  function getLastDefinedValue(data, index) {
    for (let i = index; i > -1; i--) {
      if (typeof data[i] !== 'undefined') {
        return data[i];
      }
    }
    throw new Error('Locale data API: locale data undefined');
  }
  function extractTime(time) {
    const [h, m] = time.split(':');
    return {hours: +h, minutes: +m};
  }
  function getCurrencySymbol(code, format, locale = 'en') {
    const currency = getLocaleCurrencies(locale)[code] || CURRENCIES_EN[code] || [];
    const symbolNarrow = currency[1];
    if (format === 'narrow' && typeof symbolNarrow === 'string') {
      return symbolNarrow;
    }
    return currency[0] || code;
  }
  var DEFAULT_NB_OF_CURRENCY_DIGITS = 2;
  function getNumberOfCurrencyDigits(code) {
    let digits;
    const currency = CURRENCIES_EN[code];
    if (currency) {
      digits = currency[2];
    }
    return typeof digits === 'number' ? digits : DEFAULT_NB_OF_CURRENCY_DIGITS;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ISO8601_DATE_REGEX =
      /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
  var NAMED_FORMATS = {};
  var DATE_FORMATS_SPLIT =
      /((?:[^GyYMLwWdEabBhHmsSzZO']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
  var ZoneWidth;
  (function(ZoneWidth2) {
    ZoneWidth2[ZoneWidth2['Short'] = 0] = 'Short';
    ZoneWidth2[ZoneWidth2['ShortGMT'] = 1] = 'ShortGMT';
    ZoneWidth2[ZoneWidth2['Long'] = 2] = 'Long';
    ZoneWidth2[ZoneWidth2['Extended'] = 3] = 'Extended';
  })(ZoneWidth || (ZoneWidth = {}));
  var DateType;
  (function(DateType2) {
    DateType2[DateType2['FullYear'] = 0] = 'FullYear';
    DateType2[DateType2['Month'] = 1] = 'Month';
    DateType2[DateType2['Date'] = 2] = 'Date';
    DateType2[DateType2['Hours'] = 3] = 'Hours';
    DateType2[DateType2['Minutes'] = 4] = 'Minutes';
    DateType2[DateType2['Seconds'] = 5] = 'Seconds';
    DateType2[DateType2['FractionalSeconds'] = 6] = 'FractionalSeconds';
    DateType2[DateType2['Day'] = 7] = 'Day';
  })(DateType || (DateType = {}));
  var TranslationType;
  (function(TranslationType2) {
    TranslationType2[TranslationType2['DayPeriods'] = 0] = 'DayPeriods';
    TranslationType2[TranslationType2['Days'] = 1] = 'Days';
    TranslationType2[TranslationType2['Months'] = 2] = 'Months';
    TranslationType2[TranslationType2['Eras'] = 3] = 'Eras';
  })(TranslationType || (TranslationType = {}));
  function formatDate(value, format, locale, timezone) {
    let date = toDate(value);
    const namedFormat = getNamedFormat(locale, format);
    format = namedFormat || format;
    let parts = [];
    let match2;
    while (format) {
      match2 = DATE_FORMATS_SPLIT.exec(format);
      if (match2) {
        parts = parts.concat(match2.slice(1));
        const part = parts.pop();
        if (!part) {
          break;
        }
        format = part;
      } else {
        parts.push(format);
        break;
      }
    }
    let dateTimezoneOffset = date.getTimezoneOffset();
    if (timezone) {
      dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
      date = convertTimezoneToLocal(date, timezone, true);
    }
    let text = '';
    parts.forEach((value2) => {
      const dateFormatter = getDateFormatter(value2);
      text += dateFormatter ?
          dateFormatter(date, locale, dateTimezoneOffset) :
          value2 === '\'\'' ? '\'' : value2.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
    });
    return text;
  }
  function getNamedFormat(locale, format) {
    const localeId = getLocaleId2(locale);
    NAMED_FORMATS[localeId] = NAMED_FORMATS[localeId] || {};
    if (NAMED_FORMATS[localeId][format]) {
      return NAMED_FORMATS[localeId][format];
    }
    let formatValue = '';
    switch (format) {
      case 'shortDate':
        formatValue = getLocaleDateFormat(locale, FormatWidth.Short);
        break;
      case 'mediumDate':
        formatValue = getLocaleDateFormat(locale, FormatWidth.Medium);
        break;
      case 'longDate':
        formatValue = getLocaleDateFormat(locale, FormatWidth.Long);
        break;
      case 'fullDate':
        formatValue = getLocaleDateFormat(locale, FormatWidth.Full);
        break;
      case 'shortTime':
        formatValue = getLocaleTimeFormat(locale, FormatWidth.Short);
        break;
      case 'mediumTime':
        formatValue = getLocaleTimeFormat(locale, FormatWidth.Medium);
        break;
      case 'longTime':
        formatValue = getLocaleTimeFormat(locale, FormatWidth.Long);
        break;
      case 'fullTime':
        formatValue = getLocaleTimeFormat(locale, FormatWidth.Full);
        break;
      case 'short':
        const shortTime = getNamedFormat(locale, 'shortTime');
        const shortDate = getNamedFormat(locale, 'shortDate');
        formatValue = formatDateTime(
            getLocaleDateTimeFormat(locale, FormatWidth.Short), [shortTime, shortDate]);
        break;
      case 'medium':
        const mediumTime = getNamedFormat(locale, 'mediumTime');
        const mediumDate = getNamedFormat(locale, 'mediumDate');
        formatValue = formatDateTime(
            getLocaleDateTimeFormat(locale, FormatWidth.Medium), [mediumTime, mediumDate]);
        break;
      case 'long':
        const longTime = getNamedFormat(locale, 'longTime');
        const longDate = getNamedFormat(locale, 'longDate');
        formatValue =
            formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Long), [longTime, longDate]);
        break;
      case 'full':
        const fullTime = getNamedFormat(locale, 'fullTime');
        const fullDate = getNamedFormat(locale, 'fullDate');
        formatValue =
            formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Full), [fullTime, fullDate]);
        break;
    }
    if (formatValue) {
      NAMED_FORMATS[localeId][format] = formatValue;
    }
    return formatValue;
  }
  function formatDateTime(str, opt_values) {
    if (opt_values) {
      str = str.replace(/\{([^}]+)}/g, function(match2, key) {
        return opt_values != null && key in opt_values ? opt_values[key] : match2;
      });
    }
    return str;
  }
  function padNumber(num, digits, minusSign = '-', trim, negWrap) {
    let neg = '';
    if (num < 0 || negWrap && num <= 0) {
      if (negWrap) {
        num = -num + 1;
      } else {
        num = -num;
        neg = minusSign;
      }
    }
    let strNum = String(num);
    while (strNum.length < digits) {
      strNum = '0' + strNum;
    }
    if (trim) {
      strNum = strNum.substr(strNum.length - digits);
    }
    return neg + strNum;
  }
  function formatFractionalSeconds(milliseconds, digits) {
    const strMs = padNumber(milliseconds, 3);
    return strMs.substr(0, digits);
  }
  function dateGetter(name, size, offset = 0, trim = false, negWrap = false) {
    return function(date, locale) {
      let part = getDatePart(name, date);
      if (offset > 0 || part > -offset) {
        part += offset;
      }
      if (name === DateType.Hours) {
        if (part === 0 && offset === -12) {
          part = 12;
        }
      } else if (name === DateType.FractionalSeconds) {
        return formatFractionalSeconds(part, size);
      }
      const localeMinus = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
      return padNumber(part, size, localeMinus, trim, negWrap);
    };
  }
  function getDatePart(part, date) {
    switch (part) {
      case DateType.FullYear:
        return date.getFullYear();
      case DateType.Month:
        return date.getMonth();
      case DateType.Date:
        return date.getDate();
      case DateType.Hours:
        return date.getHours();
      case DateType.Minutes:
        return date.getMinutes();
      case DateType.Seconds:
        return date.getSeconds();
      case DateType.FractionalSeconds:
        return date.getMilliseconds();
      case DateType.Day:
        return date.getDay();
      default:
        throw new Error(`Unknown DateType value "${part}".`);
    }
  }
  function dateStrGetter(name, width, form = FormStyle.Format, extended = false) {
    return function(date, locale) {
      return getDateTranslation(date, locale, name, width, form, extended);
    };
  }
  function getDateTranslation(date, locale, name, width, form, extended) {
    switch (name) {
      case TranslationType.Months:
        return getLocaleMonthNames(locale, form, width)[date.getMonth()];
      case TranslationType.Days:
        return getLocaleDayNames(locale, form, width)[date.getDay()];
      case TranslationType.DayPeriods:
        const currentHours = date.getHours();
        const currentMinutes = date.getMinutes();
        if (extended) {
          const rules = getLocaleExtraDayPeriodRules(locale);
          const dayPeriods = getLocaleExtraDayPeriods(locale, form, width);
          const index = rules.findIndex((rule) => {
            if (Array.isArray(rule)) {
              const [from2, to] = rule;
              const afterFrom = currentHours >= from2.hours && currentMinutes >= from2.minutes;
              const beforeTo = currentHours < to.hours ||
                  currentHours === to.hours && currentMinutes < to.minutes;
              if (from2.hours < to.hours) {
                if (afterFrom && beforeTo) {
                  return true;
                }
              } else if (afterFrom || beforeTo) {
                return true;
              }
            } else {
              if (rule.hours === currentHours && rule.minutes === currentMinutes) {
                return true;
              }
            }
            return false;
          });
          if (index !== -1) {
            return dayPeriods[index];
          }
        }
        return getLocaleDayPeriods(locale, form, width)[currentHours < 12 ? 0 : 1];
      case TranslationType.Eras:
        return getLocaleEraNames(locale, width)[date.getFullYear() <= 0 ? 0 : 1];
      default:
        const unexpected = name;
        throw new Error(`unexpected translation type ${unexpected}`);
    }
  }
  function timeZoneGetter(width) {
    return function(date, locale, offset) {
      const zone = -1 * offset;
      const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
      const hours = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);
      switch (width) {
        case ZoneWidth.Short:
          return (zone >= 0 ? '+' : '') + padNumber(hours, 2, minusSign) +
              padNumber(Math.abs(zone % 60), 2, minusSign);
        case ZoneWidth.ShortGMT:
          return 'GMT' + (zone >= 0 ? '+' : '') + padNumber(hours, 1, minusSign);
        case ZoneWidth.Long:
          return 'GMT' + (zone >= 0 ? '+' : '') + padNumber(hours, 2, minusSign) + ':' +
              padNumber(Math.abs(zone % 60), 2, minusSign);
        case ZoneWidth.Extended:
          if (offset === 0) {
            return 'Z';
          } else {
            return (zone >= 0 ? '+' : '') + padNumber(hours, 2, minusSign) + ':' +
                padNumber(Math.abs(zone % 60), 2, minusSign);
          }
        default:
          throw new Error(`Unknown zone width "${width}"`);
      }
    };
  }
  var JANUARY = 0;
  var THURSDAY = 4;
  function getFirstThursdayOfYear(year) {
    const firstDayOfYear = new Date(year, JANUARY, 1).getDay();
    return new Date(
        year, 0, 1 + (firstDayOfYear <= THURSDAY ? THURSDAY : THURSDAY + 7) - firstDayOfYear);
  }
  function getThursdayThisWeek(datetime) {
    return new Date(
        datetime.getFullYear(), datetime.getMonth(),
        datetime.getDate() + (THURSDAY - datetime.getDay()));
  }
  function weekGetter(size, monthBased = false) {
    return function(date, locale) {
      let result;
      if (monthBased) {
        const nbDaysBefore1stDayOfMonth =
            new Date(date.getFullYear(), date.getMonth(), 1).getDay() - 1;
        const today = date.getDate();
        result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7);
      } else {
        const thisThurs = getThursdayThisWeek(date);
        const firstThurs = getFirstThursdayOfYear(thisThurs.getFullYear());
        const diff = thisThurs.getTime() - firstThurs.getTime();
        result = 1 + Math.round(diff / 6048e5);
      }
      return padNumber(result, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
    };
  }
  function weekNumberingYearGetter(size, trim = false) {
    return function(date, locale) {
      const thisThurs = getThursdayThisWeek(date);
      const weekNumberingYear = thisThurs.getFullYear();
      return padNumber(
          weekNumberingYear, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), trim);
    };
  }
  var DATE_FORMATS = {};
  function getDateFormatter(format) {
    if (DATE_FORMATS[format]) {
      return DATE_FORMATS[format];
    }
    let formatter;
    switch (format) {
      case 'G':
      case 'GG':
      case 'GGG':
        formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Abbreviated);
        break;
      case 'GGGG':
        formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Wide);
        break;
      case 'GGGGG':
        formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Narrow);
        break;
      case 'y':
        formatter = dateGetter(DateType.FullYear, 1, 0, false, true);
        break;
      case 'yy':
        formatter = dateGetter(DateType.FullYear, 2, 0, true, true);
        break;
      case 'yyy':
        formatter = dateGetter(DateType.FullYear, 3, 0, false, true);
        break;
      case 'yyyy':
        formatter = dateGetter(DateType.FullYear, 4, 0, false, true);
        break;
      case 'Y':
        formatter = weekNumberingYearGetter(1);
        break;
      case 'YY':
        formatter = weekNumberingYearGetter(2, true);
        break;
      case 'YYY':
        formatter = weekNumberingYearGetter(3);
        break;
      case 'YYYY':
        formatter = weekNumberingYearGetter(4);
        break;
      case 'M':
      case 'L':
        formatter = dateGetter(DateType.Month, 1, 1);
        break;
      case 'MM':
      case 'LL':
        formatter = dateGetter(DateType.Month, 2, 1);
        break;
      case 'MMM':
        formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated);
        break;
      case 'MMMM':
        formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide);
        break;
      case 'MMMMM':
        formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow);
        break;
      case 'LLL':
        formatter = dateStrGetter(
            TranslationType.Months, TranslationWidth.Abbreviated, FormStyle.Standalone);
        break;
      case 'LLLL':
        formatter =
            dateStrGetter(TranslationType.Months, TranslationWidth.Wide, FormStyle.Standalone);
        break;
      case 'LLLLL':
        formatter =
            dateStrGetter(TranslationType.Months, TranslationWidth.Narrow, FormStyle.Standalone);
        break;
      case 'w':
        formatter = weekGetter(1);
        break;
      case 'ww':
        formatter = weekGetter(2);
        break;
      case 'W':
        formatter = weekGetter(1, true);
        break;
      case 'd':
        formatter = dateGetter(DateType.Date, 1);
        break;
      case 'dd':
        formatter = dateGetter(DateType.Date, 2);
        break;
      case 'E':
      case 'EE':
      case 'EEE':
        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated);
        break;
      case 'EEEE':
        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide);
        break;
      case 'EEEEE':
        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow);
        break;
      case 'EEEEEE':
        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short);
        break;
      case 'a':
      case 'aa':
      case 'aaa':
        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated);
        break;
      case 'aaaa':
        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide);
        break;
      case 'aaaaa':
        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow);
        break;
      case 'b':
      case 'bb':
      case 'bbb':
        formatter = dateStrGetter(
            TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Standalone, true);
        break;
      case 'bbbb':
        formatter = dateStrGetter(
            TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Standalone, true);
        break;
      case 'bbbbb':
        formatter = dateStrGetter(
            TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Standalone, true);
        break;
      case 'B':
      case 'BB':
      case 'BBB':
        formatter = dateStrGetter(
            TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Format, true);
        break;
      case 'BBBB':
        formatter = dateStrGetter(
            TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Format, true);
        break;
      case 'BBBBB':
        formatter = dateStrGetter(
            TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Format, true);
        break;
      case 'h':
        formatter = dateGetter(DateType.Hours, 1, -12);
        break;
      case 'hh':
        formatter = dateGetter(DateType.Hours, 2, -12);
        break;
      case 'H':
        formatter = dateGetter(DateType.Hours, 1);
        break;
      case 'HH':
        formatter = dateGetter(DateType.Hours, 2);
        break;
      case 'm':
        formatter = dateGetter(DateType.Minutes, 1);
        break;
      case 'mm':
        formatter = dateGetter(DateType.Minutes, 2);
        break;
      case 's':
        formatter = dateGetter(DateType.Seconds, 1);
        break;
      case 'ss':
        formatter = dateGetter(DateType.Seconds, 2);
        break;
      case 'S':
        formatter = dateGetter(DateType.FractionalSeconds, 1);
        break;
      case 'SS':
        formatter = dateGetter(DateType.FractionalSeconds, 2);
        break;
      case 'SSS':
        formatter = dateGetter(DateType.FractionalSeconds, 3);
        break;
      case 'Z':
      case 'ZZ':
      case 'ZZZ':
        formatter = timeZoneGetter(ZoneWidth.Short);
        break;
      case 'ZZZZZ':
        formatter = timeZoneGetter(ZoneWidth.Extended);
        break;
      case 'O':
      case 'OO':
      case 'OOO':
      case 'z':
      case 'zz':
      case 'zzz':
        formatter = timeZoneGetter(ZoneWidth.ShortGMT);
        break;
      case 'OOOO':
      case 'ZZZZ':
      case 'zzzz':
        formatter = timeZoneGetter(ZoneWidth.Long);
        break;
      default:
        return null;
    }
    DATE_FORMATS[format] = formatter;
    return formatter;
  }
  function timezoneToOffset(timezone, fallback) {
    timezone = timezone.replace(/:/g, '');
    const requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 6e4;
    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
  }
  function addDateMinutes(date, minutes) {
    date = new Date(date.getTime());
    date.setMinutes(date.getMinutes() + minutes);
    return date;
  }
  function convertTimezoneToLocal(date, timezone, reverse) {
    const reverseValue = reverse ? -1 : 1;
    const dateTimezoneOffset = date.getTimezoneOffset();
    const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    return addDateMinutes(date, reverseValue * (timezoneOffset - dateTimezoneOffset));
  }
  function toDate(value) {
    if (isDate2(value)) {
      return value;
    }
    if (typeof value === 'number' && !isNaN(value)) {
      return new Date(value);
    }
    if (typeof value === 'string') {
      value = value.trim();
      const parsedNb = parseFloat(value);
      if (!isNaN(value - parsedNb)) {
        return new Date(parsedNb);
      }
      if (/^(\d{4}-\d{1,2}-\d{1,2})$/.test(value)) {
        const [y, m, d] = value.split('-').map((val) => +val);
        return new Date(y, m - 1, d);
      }
      let match2;
      if (match2 = value.match(ISO8601_DATE_REGEX)) {
        return isoStringToDate(match2);
      }
    }
    const date = new Date(value);
    if (!isDate2(date)) {
      throw new Error(`Unable to convert "${value}" into a date`);
    }
    return date;
  }
  function isoStringToDate(match2) {
    const date = new Date(0);
    let tzHour = 0;
    let tzMin = 0;
    const dateSetter = match2[8] ? date.setUTCFullYear : date.setFullYear;
    const timeSetter = match2[8] ? date.setUTCHours : date.setHours;
    if (match2[9]) {
      tzHour = Number(match2[9] + match2[10]);
      tzMin = Number(match2[9] + match2[11]);
    }
    dateSetter.call(date, Number(match2[1]), Number(match2[2]) - 1, Number(match2[3]));
    const h = Number(match2[4] || 0) - tzHour;
    const m = Number(match2[5] || 0) - tzMin;
    const s = Number(match2[6] || 0);
    const ms = Math.floor(parseFloat('0.' + (match2[7] || 0)) * 1e3);
    timeSetter.call(date, h, m, s, ms);
    return date;
  }
  function isDate2(value) {
    return value instanceof Date && !isNaN(value.valueOf());
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
  var MAX_DIGITS = 22;
  var DECIMAL_SEP = '.';
  var ZERO_CHAR = '0';
  var PATTERN_SEP = ';';
  var GROUP_SEP = ',';
  var DIGIT_CHAR = '#';
  var CURRENCY_CHAR = '\xA4';
  var PERCENT_CHAR = '%';
  function formatNumberToLocaleString(
      value, pattern, locale, groupSymbol, decimalSymbol, digitsInfo, isPercent = false) {
    let formattedText = '';
    let isZero = false;
    if (!isFinite(value)) {
      formattedText = getLocaleNumberSymbol(locale, NumberSymbol.Infinity);
    } else {
      let parsedNumber = parseNumber(value);
      if (isPercent) {
        parsedNumber = toPercent(parsedNumber);
      }
      let minInt = pattern.minInt;
      let minFraction = pattern.minFrac;
      let maxFraction = pattern.maxFrac;
      if (digitsInfo) {
        const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);
        if (parts === null) {
          throw new Error(`${digitsInfo} is not a valid digit info`);
        }
        const minIntPart = parts[1];
        const minFractionPart = parts[3];
        const maxFractionPart = parts[5];
        if (minIntPart != null) {
          minInt = parseIntAutoRadix(minIntPart);
        }
        if (minFractionPart != null) {
          minFraction = parseIntAutoRadix(minFractionPart);
        }
        if (maxFractionPart != null) {
          maxFraction = parseIntAutoRadix(maxFractionPart);
        } else if (minFractionPart != null && minFraction > maxFraction) {
          maxFraction = minFraction;
        }
      }
      roundNumber(parsedNumber, minFraction, maxFraction);
      let digits = parsedNumber.digits;
      let integerLen = parsedNumber.integerLen;
      const exponent = parsedNumber.exponent;
      let decimals = [];
      isZero = digits.every((d) => !d);
      for (; integerLen < minInt; integerLen++) {
        digits.unshift(0);
      }
      for (; integerLen < 0; integerLen++) {
        digits.unshift(0);
      }
      if (integerLen > 0) {
        decimals = digits.splice(integerLen, digits.length);
      } else {
        decimals = digits;
        digits = [0];
      }
      const groups = [];
      if (digits.length >= pattern.lgSize) {
        groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));
      }
      while (digits.length > pattern.gSize) {
        groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));
      }
      if (digits.length) {
        groups.unshift(digits.join(''));
      }
      formattedText = groups.join(getLocaleNumberSymbol(locale, groupSymbol));
      if (decimals.length) {
        formattedText += getLocaleNumberSymbol(locale, decimalSymbol) + decimals.join('');
      }
      if (exponent) {
        formattedText += getLocaleNumberSymbol(locale, NumberSymbol.Exponential) + '+' + exponent;
      }
    }
    if (value < 0 && !isZero) {
      formattedText = pattern.negPre + formattedText + pattern.negSuf;
    } else {
      formattedText = pattern.posPre + formattedText + pattern.posSuf;
    }
    return formattedText;
  }
  function formatCurrency(value, locale, currency, currencyCode, digitsInfo) {
    const format = getLocaleNumberFormat(locale, NumberFormatStyle.Currency);
    const pattern =
        parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
    pattern.minFrac = getNumberOfCurrencyDigits(currencyCode);
    pattern.maxFrac = pattern.minFrac;
    const res = formatNumberToLocaleString(
        value, pattern, locale, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal,
        digitsInfo);
    return res.replace(CURRENCY_CHAR, currency).replace(CURRENCY_CHAR, '').trim();
  }
  function formatPercent(value, locale, digitsInfo) {
    const format = getLocaleNumberFormat(locale, NumberFormatStyle.Percent);
    const pattern =
        parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
    const res = formatNumberToLocaleString(
        value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);
    return res.replace(
        new RegExp(PERCENT_CHAR, 'g'), getLocaleNumberSymbol(locale, NumberSymbol.PercentSign));
  }
  function formatNumber(value, locale, digitsInfo) {
    const format = getLocaleNumberFormat(locale, NumberFormatStyle.Decimal);
    const pattern =
        parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
    return formatNumberToLocaleString(
        value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);
  }
  function parseNumberFormat(format, minusSign = '-') {
    const p = {
      minInt: 1,
      minFrac: 0,
      maxFrac: 0,
      posPre: '',
      posSuf: '',
      negPre: '',
      negSuf: '',
      gSize: 0,
      lgSize: 0
    };
    const patternParts = format.split(PATTERN_SEP);
    const positive = patternParts[0];
    const negative = patternParts[1];
    const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ?
        positive.split(DECIMAL_SEP) :
        [
          positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1),
          positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1)
        ],
          integer = positiveParts[0], fraction = positiveParts[1] || '';
    p.posPre = integer.substr(0, integer.indexOf(DIGIT_CHAR));
    for (let i = 0; i < fraction.length; i++) {
      const ch = fraction.charAt(i);
      if (ch === ZERO_CHAR) {
        p.minFrac = p.maxFrac = i + 1;
      } else if (ch === DIGIT_CHAR) {
        p.maxFrac = i + 1;
      } else {
        p.posSuf += ch;
      }
    }
    const groups = integer.split(GROUP_SEP);
    p.gSize = groups[1] ? groups[1].length : 0;
    p.lgSize = groups[2] || groups[1] ? (groups[2] || groups[1]).length : 0;
    if (negative) {
      const trunkLen = positive.length - p.posPre.length - p.posSuf.length,
            pos = negative.indexOf(DIGIT_CHAR);
      p.negPre = negative.substr(0, pos).replace(/'/g, '');
      p.negSuf = negative.substr(pos + trunkLen).replace(/'/g, '');
    } else {
      p.negPre = minusSign + p.posPre;
      p.negSuf = p.posSuf;
    }
    return p;
  }
  function toPercent(parsedNumber) {
    if (parsedNumber.digits[0] === 0) {
      return parsedNumber;
    }
    const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;
    if (parsedNumber.exponent) {
      parsedNumber.exponent += 2;
    } else {
      if (fractionLen === 0) {
        parsedNumber.digits.push(0, 0);
      } else if (fractionLen === 1) {
        parsedNumber.digits.push(0);
      }
      parsedNumber.integerLen += 2;
    }
    return parsedNumber;
  }
  function parseNumber(num) {
    let numStr = Math.abs(num) + '';
    let exponent = 0, digits, integerLen;
    let i, j, zeros;
    if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {
      numStr = numStr.replace(DECIMAL_SEP, '');
    }
    if ((i = numStr.search(/e/i)) > 0) {
      if (integerLen < 0) integerLen = i;
      integerLen += +numStr.slice(i + 1);
      numStr = numStr.substring(0, i);
    } else if (integerLen < 0) {
      integerLen = numStr.length;
    }
    for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {
    }
    if (i === (zeros = numStr.length)) {
      digits = [0];
      integerLen = 1;
    } else {
      zeros--;
      while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;
      integerLen -= i;
      digits = [];
      for (j = 0; i <= zeros; i++, j++) {
        digits[j] = Number(numStr.charAt(i));
      }
    }
    if (integerLen > MAX_DIGITS) {
      digits = digits.splice(0, MAX_DIGITS - 1);
      exponent = integerLen - 1;
      integerLen = 1;
    }
    return {digits, exponent, integerLen};
  }
  function roundNumber(parsedNumber, minFrac, maxFrac) {
    if (minFrac > maxFrac) {
      throw new Error(`The minimum number of digits after fraction (${
          minFrac}) is higher than the maximum (${maxFrac}).`);
    }
    let digits = parsedNumber.digits;
    let fractionLen = digits.length - parsedNumber.integerLen;
    const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);
    let roundAt = fractionSize + parsedNumber.integerLen;
    let digit = digits[roundAt];
    if (roundAt > 0) {
      digits.splice(Math.max(parsedNumber.integerLen, roundAt));
      for (let j = roundAt; j < digits.length; j++) {
        digits[j] = 0;
      }
    } else {
      fractionLen = Math.max(0, fractionLen);
      parsedNumber.integerLen = 1;
      digits.length = Math.max(1, roundAt = fractionSize + 1);
      digits[0] = 0;
      for (let i = 1; i < roundAt; i++) digits[i] = 0;
    }
    if (digit >= 5) {
      if (roundAt - 1 < 0) {
        for (let k = 0; k > roundAt; k--) {
          digits.unshift(0);
          parsedNumber.integerLen++;
        }
        digits.unshift(1);
        parsedNumber.integerLen++;
      } else {
        digits[roundAt - 1]++;
      }
    }
    for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
    let dropTrailingZeros = fractionSize !== 0;
    const minLen = minFrac + parsedNumber.integerLen;
    const carry = digits.reduceRight(function(carry2, d, i, digits2) {
      d = d + carry2;
      digits2[i] = d < 10 ? d : d - 10;
      if (dropTrailingZeros) {
        if (digits2[i] === 0 && i >= minLen) {
          digits2.pop();
        } else {
          dropTrailingZeros = false;
        }
      }
      return d >= 10 ? 1 : 0;
    }, 0);
    if (carry) {
      digits.unshift(carry);
      parsedNumber.integerLen++;
    }
  }
  function parseIntAutoRadix(text) {
    const result = parseInt(text);
    if (isNaN(result)) {
      throw new Error('Invalid integer literal when parsing ' + text);
    }
    return result;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NgLocalization = class {};
  function getPluralCategory(value, cases, ngLocalization, locale) {
    let key = `=${value}`;
    if (cases.indexOf(key) > -1) {
      return key;
    }
    key = ngLocalization.getPluralCategory(value, locale);
    if (cases.indexOf(key) > -1) {
      return key;
    }
    if (cases.indexOf('other') > -1) {
      return 'other';
    }
    throw new Error(`No plural message found for value "${value}"`);
  }
  var NgLocaleLocalization = class extends NgLocalization {
    constructor(locale) {
      super();
      this.locale = locale;
    }
    getPluralCategory(value, locale) {
      const plural2 = getLocalePluralCase2(locale || this.locale)(value);
      switch (plural2) {
        case Plural.Zero:
          return 'zero';
        case Plural.One:
          return 'one';
        case Plural.Two:
          return 'two';
        case Plural.Few:
          return 'few';
        case Plural.Many:
          return 'many';
        default:
          return 'other';
      }
    }
  };
  NgLocaleLocalization.\u0275fac = function NgLocaleLocalization_Factory(t) {
    return new (t || NgLocaleLocalization)(\u0275\u0275inject(LOCALE_ID$1));
  };
  NgLocaleLocalization.\u0275prov = \u0275\u0275defineInjectable(
      {token: NgLocaleLocalization, factory: NgLocaleLocalization.\u0275fac});
  NgLocaleLocalization.ctorParameters =
      () => [{type: String, decorators: [{type: Inject, args: [LOCALE_ID$1]}]}];
  (function() {
    setClassMetadata(NgLocaleLocalization, [{type: Injectable}], function() {
      return [{type: String, decorators: [{type: Inject, args: [LOCALE_ID$1]}]}];
    }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function parseCookieValue(cookieStr, name) {
    name = encodeURIComponent(name);
    for (const cookie of cookieStr.split(';')) {
      const eqIndex = cookie.indexOf('=');
      const [cookieName, cookieValue] =
          eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];
      if (cookieName.trim() === name) {
        return decodeURIComponent(cookieValue);
      }
    }
    return null;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NgClass = class {
    constructor(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
      this._iterableDiffers = _iterableDiffers;
      this._keyValueDiffers = _keyValueDiffers;
      this._ngEl = _ngEl;
      this._renderer = _renderer;
      this._iterableDiffer = null;
      this._keyValueDiffer = null;
      this._initialClasses = [];
      this._rawClass = null;
    }
    set klass(value) {
      this._removeClasses(this._initialClasses);
      this._initialClasses = typeof value === 'string' ? value.split(/\s+/) : [];
      this._applyClasses(this._initialClasses);
      this._applyClasses(this._rawClass);
    }
    set ngClass(value) {
      this._removeClasses(this._rawClass);
      this._applyClasses(this._initialClasses);
      this._iterableDiffer = null;
      this._keyValueDiffer = null;
      this._rawClass = typeof value === 'string' ? value.split(/\s+/) : value;
      if (this._rawClass) {
        if (isListLikeIterable(this._rawClass)) {
          this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create();
        } else {
          this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create();
        }
      }
    }
    ngDoCheck() {
      if (this._iterableDiffer) {
        const iterableChanges = this._iterableDiffer.diff(this._rawClass);
        if (iterableChanges) {
          this._applyIterableChanges(iterableChanges);
        }
      } else if (this._keyValueDiffer) {
        const keyValueChanges = this._keyValueDiffer.diff(this._rawClass);
        if (keyValueChanges) {
          this._applyKeyValueChanges(keyValueChanges);
        }
      }
    }
    _applyKeyValueChanges(changes) {
      changes.forEachAddedItem((record) => this._toggleClass(record.key, record.currentValue));
      changes.forEachChangedItem((record) => this._toggleClass(record.key, record.currentValue));
      changes.forEachRemovedItem((record) => {
        if (record.previousValue) {
          this._toggleClass(record.key, false);
        }
      });
    }
    _applyIterableChanges(changes) {
      changes.forEachAddedItem((record) => {
        if (typeof record.item === 'string') {
          this._toggleClass(record.item, true);
        } else {
          throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${
              stringify(record.item)}`);
        }
      });
      changes.forEachRemovedItem((record) => this._toggleClass(record.item, false));
    }
    _applyClasses(rawClassVal) {
      if (rawClassVal) {
        if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
          rawClassVal.forEach((klass) => this._toggleClass(klass, true));
        } else {
          Object.keys(rawClassVal)
              .forEach((klass) => this._toggleClass(klass, !!rawClassVal[klass]));
        }
      }
    }
    _removeClasses(rawClassVal) {
      if (rawClassVal) {
        if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
          rawClassVal.forEach((klass) => this._toggleClass(klass, false));
        } else {
          Object.keys(rawClassVal).forEach((klass) => this._toggleClass(klass, false));
        }
      }
    }
    _toggleClass(klass, enabled) {
      klass = klass.trim();
      if (klass) {
        klass.split(/\s+/g).forEach((klass2) => {
          if (enabled) {
            this._renderer.addClass(this._ngEl.nativeElement, klass2);
          } else {
            this._renderer.removeClass(this._ngEl.nativeElement, klass2);
          }
        });
      }
    }
  };
  NgClass.\u0275fac = function NgClass_Factory(t) {
    return new (t || NgClass)(
        \u0275\u0275directiveInject(IterableDiffers), \u0275\u0275directiveInject(KeyValueDiffers),
        \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
  };
  NgClass.\u0275dir = \u0275\u0275defineDirective({
    type: NgClass,
    selectors: [['', 'ngClass', '']],
    inputs: {klass: ['class', 'klass'], ngClass: 'ngClass'}
  });
  NgClass.ctorParameters =
      () => [{type: IterableDiffers}, {type: KeyValueDiffers}, {type: ElementRef}, {
        type: Renderer2
      }];
  NgClass.propDecorators = {
    klass: [{type: Input, args: ['class']}],
    ngClass: [{type: Input, args: ['ngClass']}]
  };
  (function() {
    setClassMetadata(NgClass, [{type: Directive, args: [{selector: '[ngClass]'}]}], function() {
      return [
        {type: IterableDiffers}, {type: KeyValueDiffers}, {type: ElementRef}, {type: Renderer2}
      ];
    }, {klass: [{type: Input, args: ['class']}], ngClass: [{type: Input, args: ['ngClass']}]});
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NgComponentOutlet = class {
    constructor(_viewContainerRef) {
      this._viewContainerRef = _viewContainerRef;
      this._componentRef = null;
      this._moduleRef = null;
    }
    ngOnChanges(changes) {
      this._viewContainerRef.clear();
      this._componentRef = null;
      if (this.ngComponentOutlet) {
        const elInjector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
        if (changes['ngComponentOutletNgModuleFactory']) {
          if (this._moduleRef) this._moduleRef.destroy();
          if (this.ngComponentOutletNgModuleFactory) {
            const parentModule = elInjector.get(NgModuleRef);
            this._moduleRef = this.ngComponentOutletNgModuleFactory.create(parentModule.injector);
          } else {
            this._moduleRef = null;
          }
        }
        const componentFactoryResolver2 = this._moduleRef ?
            this._moduleRef.componentFactoryResolver :
            elInjector.get(ComponentFactoryResolver);
        const componentFactory =
            componentFactoryResolver2.resolveComponentFactory(this.ngComponentOutlet);
        this._componentRef = this._viewContainerRef.createComponent(
            componentFactory, this._viewContainerRef.length, elInjector,
            this.ngComponentOutletContent);
      }
    }
    ngOnDestroy() {
      if (this._moduleRef) this._moduleRef.destroy();
    }
  };
  NgComponentOutlet.\u0275fac = function NgComponentOutlet_Factory(t) {
    return new (t || NgComponentOutlet)(\u0275\u0275directiveInject(ViewContainerRef));
  };
  NgComponentOutlet.\u0275dir = \u0275\u0275defineDirective({
    type: NgComponentOutlet,
    selectors: [['', 'ngComponentOutlet', '']],
    inputs: {
      ngComponentOutlet: 'ngComponentOutlet',
      ngComponentOutletInjector: 'ngComponentOutletInjector',
      ngComponentOutletContent: 'ngComponentOutletContent',
      ngComponentOutletNgModuleFactory: 'ngComponentOutletNgModuleFactory'
    },
    features: [\u0275\u0275NgOnChangesFeature]
  });
  NgComponentOutlet.ctorParameters = () => [{type: ViewContainerRef}];
  NgComponentOutlet.propDecorators = {
    ngComponentOutlet: [{type: Input}],
    ngComponentOutletInjector: [{type: Input}],
    ngComponentOutletContent: [{type: Input}],
    ngComponentOutletNgModuleFactory: [{type: Input}]
  };
  (function() {
    setClassMetadata(
        NgComponentOutlet,
        [{type: Directive, args: [{selector: '[ngComponentOutlet]'}]}], function() {
          return [{type: ViewContainerRef}];
        }, {
          ngComponentOutlet: [{type: Input}],
          ngComponentOutletInjector: [{type: Input}],
          ngComponentOutletContent: [{type: Input}],
          ngComponentOutletNgModuleFactory: [{type: Input}]
        });
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NgForOfContext = class {
    constructor($implicit, ngForOf, index, count2) {
      this.$implicit = $implicit;
      this.ngForOf = ngForOf;
      this.index = index;
      this.count = count2;
    }
    get first() {
      return this.index === 0;
    }
    get last() {
      return this.index === this.count - 1;
    }
    get even() {
      return this.index % 2 === 0;
    }
    get odd() {
      return !this.even;
    }
  };
  var NgForOf = class {
    constructor(_viewContainer, _template, _differs) {
      this._viewContainer = _viewContainer;
      this._template = _template;
      this._differs = _differs;
      this._ngForOf = null;
      this._ngForOfDirty = true;
      this._differ = null;
    }
    set ngForOf(ngForOf) {
      this._ngForOf = ngForOf;
      this._ngForOfDirty = true;
    }
    set ngForTrackBy(fn) {
      if ((typeof ngDevMode === 'undefined' || ngDevMode) && fn != null &&
          typeof fn !== 'function') {
        if (console && console.warn) {
          console.warn(`trackBy must be a function, but received ${
              JSON.stringify(
                  fn)}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`);
        }
      }
      this._trackByFn = fn;
    }
    get ngForTrackBy() {
      return this._trackByFn;
    }
    set ngForTemplate(value) {
      if (value) {
        this._template = value;
      }
    }
    ngDoCheck() {
      if (this._ngForOfDirty) {
        this._ngForOfDirty = false;
        const value = this._ngForOf;
        if (!this._differ && value) {
          try {
            this._differ = this._differs.find(value).create(this.ngForTrackBy);
          } catch (_a) {
            throw new Error(`Cannot find a differ supporting object '${value}' of type '${
                getTypeName2(value)}'. NgFor only supports binding to Iterables such as Arrays.`);
          }
        }
      }
      if (this._differ) {
        const changes = this._differ.diff(this._ngForOf);
        if (changes) this._applyChanges(changes);
      }
    }
    _applyChanges(changes) {
      const insertTuples = [];
      changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
        if (item.previousIndex == null) {
          const view = this._viewContainer.createEmbeddedView(
              this._template, new NgForOfContext(null, this._ngForOf, -1, -1),
              currentIndex === null ? void 0 : currentIndex);
          const tuple = new RecordViewTuple(item, view);
          insertTuples.push(tuple);
        } else if (currentIndex == null) {
          this._viewContainer.remove(
              adjustedPreviousIndex === null ? void 0 : adjustedPreviousIndex);
        } else if (adjustedPreviousIndex !== null) {
          const view = this._viewContainer.get(adjustedPreviousIndex);
          this._viewContainer.move(view, currentIndex);
          const tuple = new RecordViewTuple(item, view);
          insertTuples.push(tuple);
        }
      });
      for (let i = 0; i < insertTuples.length; i++) {
        this._perViewChange(insertTuples[i].view, insertTuples[i].record);
      }
      for (let i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
        const viewRef = this._viewContainer.get(i);
        viewRef.context.index = i;
        viewRef.context.count = ilen;
        viewRef.context.ngForOf = this._ngForOf;
      }
      changes.forEachIdentityChange((record) => {
        const viewRef = this._viewContainer.get(record.currentIndex);
        viewRef.context.$implicit = record.item;
      });
    }
    _perViewChange(view, record) {
      view.context.$implicit = record.item;
    }
    static ngTemplateContextGuard(dir, ctx) {
      return true;
    }
  };
  NgForOf.\u0275fac = function NgForOf_Factory(t) {
    return new (t || NgForOf)(
        \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef),
        \u0275\u0275directiveInject(IterableDiffers));
  };
  NgForOf.\u0275dir = \u0275\u0275defineDirective({
    type: NgForOf,
    selectors: [['', 'ngFor', '', 'ngForOf', '']],
    inputs: {ngForOf: 'ngForOf', ngForTrackBy: 'ngForTrackBy', ngForTemplate: 'ngForTemplate'}
  });
  NgForOf.ctorParameters =
      () => [{type: ViewContainerRef}, {type: TemplateRef}, {type: IterableDiffers}];
  NgForOf.propDecorators = {
    ngForOf: [{type: Input}],
    ngForTrackBy: [{type: Input}],
    ngForTemplate: [{type: Input}]
  };
  (function() {
    setClassMetadata(
        NgForOf, [{type: Directive, args: [{selector: '[ngFor][ngForOf]'}]}],
        function() {
          return [{type: ViewContainerRef}, {type: TemplateRef}, {type: IterableDiffers}];
        },
        {ngForOf: [{type: Input}], ngForTrackBy: [{type: Input}], ngForTemplate: [{type: Input}]});
  })();
  var RecordViewTuple = class {
    constructor(record, view) {
      this.record = record;
      this.view = view;
    }
  };
  function getTypeName2(type) {
    return type['name'] || typeof type;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NgIf = class {
    constructor(_viewContainer, templateRef) {
      this._viewContainer = _viewContainer;
      this._context = new NgIfContext();
      this._thenTemplateRef = null;
      this._elseTemplateRef = null;
      this._thenViewRef = null;
      this._elseViewRef = null;
      this._thenTemplateRef = templateRef;
    }
    set ngIf(condition) {
      this._context.$implicit = this._context.ngIf = condition;
      this._updateView();
    }
    set ngIfThen(templateRef) {
      assertTemplate('ngIfThen', templateRef);
      this._thenTemplateRef = templateRef;
      this._thenViewRef = null;
      this._updateView();
    }
    set ngIfElse(templateRef) {
      assertTemplate('ngIfElse', templateRef);
      this._elseTemplateRef = templateRef;
      this._elseViewRef = null;
      this._updateView();
    }
    _updateView() {
      if (this._context.$implicit) {
        if (!this._thenViewRef) {
          this._viewContainer.clear();
          this._elseViewRef = null;
          if (this._thenTemplateRef) {
            this._thenViewRef =
                this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
          }
        }
      } else {
        if (!this._elseViewRef) {
          this._viewContainer.clear();
          this._thenViewRef = null;
          if (this._elseTemplateRef) {
            this._elseViewRef =
                this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
          }
        }
      }
    }
    static ngTemplateContextGuard(dir, ctx) {
      return true;
    }
  };
  NgIf.\u0275fac = function NgIf_Factory(t) {
    return new (t || NgIf)(
        \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef));
  };
  NgIf.\u0275dir = \u0275\u0275defineDirective({
    type: NgIf,
    selectors: [['', 'ngIf', '']],
    inputs: {ngIf: 'ngIf', ngIfThen: 'ngIfThen', ngIfElse: 'ngIfElse'}
  });
  NgIf.ctorParameters = () => [{type: ViewContainerRef}, {type: TemplateRef}];
  NgIf.propDecorators = {
    ngIf: [{type: Input}],
    ngIfThen: [{type: Input}],
    ngIfElse: [{type: Input}]
  };
  (function() {
    setClassMetadata(NgIf, [{type: Directive, args: [{selector: '[ngIf]'}]}], function() {
      return [{type: ViewContainerRef}, {type: TemplateRef}];
    }, {ngIf: [{type: Input}], ngIfThen: [{type: Input}], ngIfElse: [{type: Input}]});
  })();
  var NgIfContext = class {
    constructor() {
      this.$implicit = null;
      this.ngIf = null;
    }
  };
  function assertTemplate(property, templateRef) {
    const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);
    if (!isTemplateRefOrNull) {
      throw new Error(
          `${property} must be a TemplateRef, but received '${stringify(templateRef)}'.`);
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var SwitchView = class {
    constructor(_viewContainerRef, _templateRef) {
      this._viewContainerRef = _viewContainerRef;
      this._templateRef = _templateRef;
      this._created = false;
    }
    create() {
      this._created = true;
      this._viewContainerRef.createEmbeddedView(this._templateRef);
    }
    destroy() {
      this._created = false;
      this._viewContainerRef.clear();
    }
    enforceState(created) {
      if (created && !this._created) {
        this.create();
      } else if (!created && this._created) {
        this.destroy();
      }
    }
  };
  var NgSwitch = class {
    constructor() {
      this._defaultUsed = false;
      this._caseCount = 0;
      this._lastCaseCheckIndex = 0;
      this._lastCasesMatched = false;
    }
    set ngSwitch(newValue) {
      this._ngSwitch = newValue;
      if (this._caseCount === 0) {
        this._updateDefaultCases(true);
      }
    }
    _addCase() {
      return this._caseCount++;
    }
    _addDefault(view) {
      if (!this._defaultViews) {
        this._defaultViews = [];
      }
      this._defaultViews.push(view);
    }
    _matchCase(value) {
      const matched = value == this._ngSwitch;
      this._lastCasesMatched = this._lastCasesMatched || matched;
      this._lastCaseCheckIndex++;
      if (this._lastCaseCheckIndex === this._caseCount) {
        this._updateDefaultCases(!this._lastCasesMatched);
        this._lastCaseCheckIndex = 0;
        this._lastCasesMatched = false;
      }
      return matched;
    }
    _updateDefaultCases(useDefault) {
      if (this._defaultViews && useDefault !== this._defaultUsed) {
        this._defaultUsed = useDefault;
        for (let i = 0; i < this._defaultViews.length; i++) {
          const defaultView = this._defaultViews[i];
          defaultView.enforceState(useDefault);
        }
      }
    }
  };
  NgSwitch.\u0275fac = function NgSwitch_Factory(t) {
    return new (t || NgSwitch)();
  };
  NgSwitch.\u0275dir = \u0275\u0275defineDirective(
      {type: NgSwitch, selectors: [['', 'ngSwitch', '']], inputs: {ngSwitch: 'ngSwitch'}});
  NgSwitch.propDecorators = {ngSwitch: [{type: Input}]};
  (function() {
    setClassMetadata(NgSwitch, [{type: Directive, args: [{selector: '[ngSwitch]'}]}], function() {
      return [];
    }, {ngSwitch: [{type: Input}]});
  })();
  var NgSwitchCase = class {
    constructor(viewContainer, templateRef, ngSwitch) {
      this.ngSwitch = ngSwitch;
      ngSwitch._addCase();
      this._view = new SwitchView(viewContainer, templateRef);
    }
    ngDoCheck() {
      this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));
    }
  };
  NgSwitchCase.\u0275fac = function NgSwitchCase_Factory(t) {
    return new (t || NgSwitchCase)(
        \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef),
        \u0275\u0275directiveInject(NgSwitch, 1));
  };
  NgSwitchCase.\u0275dir = \u0275\u0275defineDirective({
    type: NgSwitchCase,
    selectors: [['', 'ngSwitchCase', '']],
    inputs: {ngSwitchCase: 'ngSwitchCase'}
  });
  NgSwitchCase.ctorParameters = () =>
      [{type: ViewContainerRef}, {type: TemplateRef}, {type: NgSwitch, decorators: [{type: Host}]}];
  NgSwitchCase.propDecorators = {ngSwitchCase: [{type: Input}]};
  (function() {
    setClassMetadata(
        NgSwitchCase, [{type: Directive, args: [{selector: '[ngSwitchCase]'}]}], function() {
          return [
            {type: ViewContainerRef}, {type: TemplateRef},
            {type: NgSwitch, decorators: [{type: Host}]}
          ];
        }, {ngSwitchCase: [{type: Input}]});
  })();
  var NgSwitchDefault = class {
    constructor(viewContainer, templateRef, ngSwitch) {
      ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
    }
  };
  NgSwitchDefault.\u0275fac = function NgSwitchDefault_Factory(t) {
    return new (t || NgSwitchDefault)(
        \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef),
        \u0275\u0275directiveInject(NgSwitch, 1));
  };
  NgSwitchDefault.\u0275dir = \u0275\u0275defineDirective(
      {type: NgSwitchDefault, selectors: [['', 'ngSwitchDefault', '']]});
  NgSwitchDefault.ctorParameters = () =>
      [{type: ViewContainerRef}, {type: TemplateRef}, {type: NgSwitch, decorators: [{type: Host}]}];
  (function() {
    setClassMetadata(
        NgSwitchDefault, [{type: Directive, args: [{selector: '[ngSwitchDefault]'}]}], function() {
          return [
            {type: ViewContainerRef}, {type: TemplateRef},
            {type: NgSwitch, decorators: [{type: Host}]}
          ];
        }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NgPlural = class {
    constructor(_localization) {
      this._localization = _localization;
      this._caseViews = {};
    }
    set ngPlural(value) {
      this._switchValue = value;
      this._updateView();
    }
    addCase(value, switchView) {
      this._caseViews[value] = switchView;
    }
    _updateView() {
      this._clearViews();
      const cases = Object.keys(this._caseViews);
      const key = getPluralCategory(this._switchValue, cases, this._localization);
      this._activateView(this._caseViews[key]);
    }
    _clearViews() {
      if (this._activeView) this._activeView.destroy();
    }
    _activateView(view) {
      if (view) {
        this._activeView = view;
        this._activeView.create();
      }
    }
  };
  NgPlural.\u0275fac = function NgPlural_Factory(t) {
    return new (t || NgPlural)(\u0275\u0275directiveInject(NgLocalization));
  };
  NgPlural.\u0275dir = \u0275\u0275defineDirective(
      {type: NgPlural, selectors: [['', 'ngPlural', '']], inputs: {ngPlural: 'ngPlural'}});
  NgPlural.ctorParameters = () => [{type: NgLocalization}];
  NgPlural.propDecorators = {ngPlural: [{type: Input}]};
  (function() {
    setClassMetadata(NgPlural, [{type: Directive, args: [{selector: '[ngPlural]'}]}], function() {
      return [{type: NgLocalization}];
    }, {ngPlural: [{type: Input}]});
  })();
  var NgPluralCase = class {
    constructor(value, template, viewContainer, ngPlural) {
      this.value = value;
      const isANumber = !isNaN(Number(value));
      ngPlural.addCase(isANumber ? `=${value}` : value, new SwitchView(viewContainer, template));
    }
  };
  NgPluralCase.\u0275fac = function NgPluralCase_Factory(t) {
    return new (t || NgPluralCase)(
        \u0275\u0275injectAttribute('ngPluralCase'), \u0275\u0275directiveInject(TemplateRef),
        \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(NgPlural, 1));
  };
  NgPluralCase.\u0275dir =
      \u0275\u0275defineDirective({type: NgPluralCase, selectors: [['', 'ngPluralCase', '']]});
  NgPluralCase.ctorParameters = () =>
      [{type: String, decorators: [{type: Attribute, args: ['ngPluralCase']}]}, {type: TemplateRef},
       {type: ViewContainerRef}, {type: NgPlural, decorators: [{type: Host}]}];
  (function() {
    setClassMetadata(
        NgPluralCase, [{type: Directive, args: [{selector: '[ngPluralCase]'}]}], function() {
          return [
            {type: String, decorators: [{type: Attribute, args: ['ngPluralCase']}]},
            {type: TemplateRef}, {type: ViewContainerRef},
            {type: NgPlural, decorators: [{type: Host}]}
          ];
        }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NgStyle = class {
    constructor(_ngEl, _differs, _renderer) {
      this._ngEl = _ngEl;
      this._differs = _differs;
      this._renderer = _renderer;
      this._ngStyle = null;
      this._differ = null;
    }
    set ngStyle(values) {
      this._ngStyle = values;
      if (!this._differ && values) {
        this._differ = this._differs.find(values).create();
      }
    }
    ngDoCheck() {
      if (this._differ) {
        const changes = this._differ.diff(this._ngStyle);
        if (changes) {
          this._applyChanges(changes);
        }
      }
    }
    _setStyle(nameAndUnit, value) {
      const [name, unit] = nameAndUnit.split('.');
      value = value != null && unit ? `${value}${unit}` : value;
      if (value != null) {
        this._renderer.setStyle(this._ngEl.nativeElement, name, value);
      } else {
        this._renderer.removeStyle(this._ngEl.nativeElement, name);
      }
    }
    _applyChanges(changes) {
      changes.forEachRemovedItem((record) => this._setStyle(record.key, null));
      changes.forEachAddedItem((record) => this._setStyle(record.key, record.currentValue));
      changes.forEachChangedItem((record) => this._setStyle(record.key, record.currentValue));
    }
  };
  NgStyle.\u0275fac = function NgStyle_Factory(t) {
    return new (t || NgStyle)(
        \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(KeyValueDiffers),
        \u0275\u0275directiveInject(Renderer2));
  };
  NgStyle.\u0275dir = \u0275\u0275defineDirective(
      {type: NgStyle, selectors: [['', 'ngStyle', '']], inputs: {ngStyle: 'ngStyle'}});
  NgStyle.ctorParameters = () => [{type: ElementRef}, {type: KeyValueDiffers}, {type: Renderer2}];
  NgStyle.propDecorators = {ngStyle: [{type: Input, args: ['ngStyle']}]};
  (function() {
    setClassMetadata(NgStyle, [{type: Directive, args: [{selector: '[ngStyle]'}]}], function() {
      return [{type: ElementRef}, {type: KeyValueDiffers}, {type: Renderer2}];
    }, {ngStyle: [{type: Input, args: ['ngStyle']}]});
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NgTemplateOutlet = class {
    constructor(_viewContainerRef) {
      this._viewContainerRef = _viewContainerRef;
      this._viewRef = null;
      this.ngTemplateOutletContext = null;
      this.ngTemplateOutlet = null;
    }
    ngOnChanges(changes) {
      const recreateView = this._shouldRecreateView(changes);
      if (recreateView) {
        const viewContainerRef = this._viewContainerRef;
        if (this._viewRef) {
          viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));
        }
        this._viewRef = this.ngTemplateOutlet ?
            viewContainerRef.createEmbeddedView(
                this.ngTemplateOutlet, this.ngTemplateOutletContext) :
            null;
      } else if (this._viewRef && this.ngTemplateOutletContext) {
        this._updateExistingContext(this.ngTemplateOutletContext);
      }
    }
    _shouldRecreateView(changes) {
      const ctxChange = changes['ngTemplateOutletContext'];
      return !!changes['ngTemplateOutlet'] || ctxChange && this._hasContextShapeChanged(ctxChange);
    }
    _hasContextShapeChanged(ctxChange) {
      const prevCtxKeys = Object.keys(ctxChange.previousValue || {});
      const currCtxKeys = Object.keys(ctxChange.currentValue || {});
      if (prevCtxKeys.length === currCtxKeys.length) {
        for (let propName of currCtxKeys) {
          if (prevCtxKeys.indexOf(propName) === -1) {
            return true;
          }
        }
        return false;
      }
      return true;
    }
    _updateExistingContext(ctx) {
      for (let propName of Object.keys(ctx)) {
        this._viewRef.context[propName] = this.ngTemplateOutletContext[propName];
      }
    }
  };
  NgTemplateOutlet.\u0275fac = function NgTemplateOutlet_Factory(t) {
    return new (t || NgTemplateOutlet)(\u0275\u0275directiveInject(ViewContainerRef));
  };
  NgTemplateOutlet.\u0275dir = \u0275\u0275defineDirective({
    type: NgTemplateOutlet,
    selectors: [['', 'ngTemplateOutlet', '']],
    inputs:
        {ngTemplateOutletContext: 'ngTemplateOutletContext', ngTemplateOutlet: 'ngTemplateOutlet'},
    features: [\u0275\u0275NgOnChangesFeature]
  });
  NgTemplateOutlet.ctorParameters = () => [{type: ViewContainerRef}];
  NgTemplateOutlet.propDecorators = {
    ngTemplateOutletContext: [{type: Input}],
    ngTemplateOutlet: [{type: Input}]
  };
  (function() {
    setClassMetadata(
        NgTemplateOutlet,
        [{type: Directive, args: [{selector: '[ngTemplateOutlet]'}]}], function() {
          return [{type: ViewContainerRef}];
        }, {ngTemplateOutletContext: [{type: Input}], ngTemplateOutlet: [{type: Input}]});
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var COMMON_DIRECTIVES = [
    NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase,
    NgSwitchDefault, NgPlural, NgPluralCase
  ];
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function invalidPipeArgumentError(type, value) {
    return Error(`InvalidPipeArgument: '${value}' for pipe '${stringify(type)}'`);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ObservableStrategy = class {
    createSubscription(async2, updateLatestValue) {
      return async2.subscribe({
        next: updateLatestValue,
        error: (e) => {
          throw e;
        }
      });
    }
    dispose(subscription) {
      subscription.unsubscribe();
    }
    onDestroy(subscription) {
      subscription.unsubscribe();
    }
  };
  var PromiseStrategy = class {
    createSubscription(async2, updateLatestValue) {
      return async2.then(updateLatestValue, (e) => {
        throw e;
      });
    }
    dispose(subscription) {}
    onDestroy(subscription) {}
  };
  var _promiseStrategy = new PromiseStrategy();
  var _observableStrategy = new ObservableStrategy();
  var AsyncPipe = class {
    constructor(_ref) {
      this._ref = _ref;
      this._latestValue = null;
      this._subscription = null;
      this._obj = null;
      this._strategy = null;
    }
    ngOnDestroy() {
      if (this._subscription) {
        this._dispose();
      }
    }
    transform(obj) {
      if (!this._obj) {
        if (obj) {
          this._subscribe(obj);
        }
        return this._latestValue;
      }
      if (obj !== this._obj) {
        this._dispose();
        return this.transform(obj);
      }
      return this._latestValue;
    }
    _subscribe(obj) {
      this._obj = obj;
      this._strategy = this._selectStrategy(obj);
      this._subscription =
          this._strategy.createSubscription(obj, (value) => this._updateLatestValue(obj, value));
    }
    _selectStrategy(obj) {
      if (isPromise2(obj)) {
        return _promiseStrategy;
      }
      if (isObservable2(obj)) {
        return _observableStrategy;
      }
      throw invalidPipeArgumentError(AsyncPipe, obj);
    }
    _dispose() {
      this._strategy.dispose(this._subscription);
      this._latestValue = null;
      this._subscription = null;
      this._obj = null;
    }
    _updateLatestValue(async2, value) {
      if (async2 === this._obj) {
        this._latestValue = value;
        this._ref.markForCheck();
      }
    }
  };
  AsyncPipe.\u0275fac = function AsyncPipe_Factory(t) {
    return new (t || AsyncPipe)(\u0275\u0275injectPipeChangeDetectorRef());
  };
  AsyncPipe.\u0275pipe = \u0275\u0275definePipe({name: 'async', type: AsyncPipe, pure: false});
  AsyncPipe.ctorParameters = () => [{type: ChangeDetectorRef}];
  (function() {
    setClassMetadata(AsyncPipe, [{type: Pipe, args: [{name: 'async', pure: false}]}], function() {
      return [{type: ChangeDetectorRef}];
    }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var LowerCasePipe = class {
    transform(value) {
      if (value == null) return null;
      if (typeof value !== 'string') {
        throw invalidPipeArgumentError(LowerCasePipe, value);
      }
      return value.toLowerCase();
    }
  };
  LowerCasePipe.\u0275fac = function LowerCasePipe_Factory(t) {
    return new (t || LowerCasePipe)();
  };
  LowerCasePipe.\u0275pipe =
      \u0275\u0275definePipe({name: 'lowercase', type: LowerCasePipe, pure: true});
  (function() {
    setClassMetadata(LowerCasePipe, [{type: Pipe, args: [{name: 'lowercase'}]}], null, null);
  })();
  var unicodeWordMatch =
      /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D])\S*/g;
  var TitleCasePipe = class {
    transform(value) {
      if (value == null) return null;
      if (typeof value !== 'string') {
        throw invalidPipeArgumentError(TitleCasePipe, value);
      }
      return value.replace(
          unicodeWordMatch, (txt) => txt[0].toUpperCase() + txt.substr(1).toLowerCase());
    }
  };
  TitleCasePipe.\u0275fac = function TitleCasePipe_Factory(t) {
    return new (t || TitleCasePipe)();
  };
  TitleCasePipe.\u0275pipe =
      \u0275\u0275definePipe({name: 'titlecase', type: TitleCasePipe, pure: true});
  (function() {
    setClassMetadata(TitleCasePipe, [{type: Pipe, args: [{name: 'titlecase'}]}], null, null);
  })();
  var UpperCasePipe = class {
    transform(value) {
      if (value == null) return null;
      if (typeof value !== 'string') {
        throw invalidPipeArgumentError(UpperCasePipe, value);
      }
      return value.toUpperCase();
    }
  };
  UpperCasePipe.\u0275fac = function UpperCasePipe_Factory(t) {
    return new (t || UpperCasePipe)();
  };
  UpperCasePipe.\u0275pipe =
      \u0275\u0275definePipe({name: 'uppercase', type: UpperCasePipe, pure: true});
  (function() {
    setClassMetadata(UpperCasePipe, [{type: Pipe, args: [{name: 'uppercase'}]}], null, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var DatePipe = class {
    constructor(locale) {
      this.locale = locale;
    }
    transform(value, format = 'mediumDate', timezone, locale) {
      if (value == null || value === '' || value !== value) return null;
      try {
        return formatDate(value, format, locale || this.locale, timezone);
      } catch (error) {
        throw invalidPipeArgumentError(DatePipe, error.message);
      }
    }
  };
  DatePipe.\u0275fac = function DatePipe_Factory(t) {
    return new (t || DatePipe)(\u0275\u0275directiveInject(LOCALE_ID$1));
  };
  DatePipe.\u0275pipe = \u0275\u0275definePipe({name: 'date', type: DatePipe, pure: true});
  DatePipe.ctorParameters =
      () => [{type: String, decorators: [{type: Inject, args: [LOCALE_ID$1]}]}];
  (function() {
    setClassMetadata(DatePipe, [{type: Pipe, args: [{name: 'date', pure: true}]}], function() {
      return [{type: String, decorators: [{type: Inject, args: [LOCALE_ID$1]}]}];
    }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var _INTERPOLATION_REGEXP = /#/g;
  var I18nPluralPipe = class {
    constructor(_localization) {
      this._localization = _localization;
    }
    transform(value, pluralMap, locale) {
      if (value == null) return '';
      if (typeof pluralMap !== 'object' || pluralMap === null) {
        throw invalidPipeArgumentError(I18nPluralPipe, pluralMap);
      }
      const key = getPluralCategory(value, Object.keys(pluralMap), this._localization, locale);
      return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
    }
  };
  I18nPluralPipe.\u0275fac = function I18nPluralPipe_Factory(t) {
    return new (t || I18nPluralPipe)(\u0275\u0275directiveInject(NgLocalization));
  };
  I18nPluralPipe.\u0275pipe =
      \u0275\u0275definePipe({name: 'i18nPlural', type: I18nPluralPipe, pure: true});
  I18nPluralPipe.ctorParameters = () => [{type: NgLocalization}];
  (function() {
    setClassMetadata(
        I18nPluralPipe, [{type: Pipe, args: [{name: 'i18nPlural', pure: true}]}], function() {
          return [{type: NgLocalization}];
        }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var I18nSelectPipe = class {
    transform(value, mapping) {
      if (value == null) return '';
      if (typeof mapping !== 'object' || typeof value !== 'string') {
        throw invalidPipeArgumentError(I18nSelectPipe, mapping);
      }
      if (mapping.hasOwnProperty(value)) {
        return mapping[value];
      }
      if (mapping.hasOwnProperty('other')) {
        return mapping['other'];
      }
      return '';
    }
  };
  I18nSelectPipe.\u0275fac = function I18nSelectPipe_Factory(t) {
    return new (t || I18nSelectPipe)();
  };
  I18nSelectPipe.\u0275pipe =
      \u0275\u0275definePipe({name: 'i18nSelect', type: I18nSelectPipe, pure: true});
  (function() {
    setClassMetadata(
        I18nSelectPipe, [{type: Pipe, args: [{name: 'i18nSelect', pure: true}]}], null, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var JsonPipe = class {
    transform(value) {
      return JSON.stringify(value, null, 2);
    }
  };
  JsonPipe.\u0275fac = function JsonPipe_Factory(t) {
    return new (t || JsonPipe)();
  };
  JsonPipe.\u0275pipe = \u0275\u0275definePipe({name: 'json', type: JsonPipe, pure: false});
  (function() {
    setClassMetadata(JsonPipe, [{type: Pipe, args: [{name: 'json', pure: false}]}], null, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function makeKeyValuePair(key, value) {
    return {key, value};
  }
  var KeyValuePipe = class {
    constructor(differs) {
      this.differs = differs;
      this.keyValues = [];
    }
    transform(input, compareFn = defaultComparator) {
      if (!input || !(input instanceof Map) && typeof input !== 'object') {
        return null;
      }
      if (!this.differ) {
        this.differ = this.differs.find(input).create();
      }
      const differChanges = this.differ.diff(input);
      if (differChanges) {
        this.keyValues = [];
        differChanges.forEachItem((r) => {
          this.keyValues.push(makeKeyValuePair(r.key, r.currentValue));
        });
        this.keyValues.sort(compareFn);
      }
      return this.keyValues;
    }
  };
  KeyValuePipe.\u0275fac = function KeyValuePipe_Factory(t) {
    return new (t || KeyValuePipe)(\u0275\u0275directiveInject(KeyValueDiffers));
  };
  KeyValuePipe.\u0275pipe =
      \u0275\u0275definePipe({name: 'keyvalue', type: KeyValuePipe, pure: false});
  KeyValuePipe.ctorParameters = () => [{type: KeyValueDiffers}];
  (function() {
    setClassMetadata(
        KeyValuePipe, [{type: Pipe, args: [{name: 'keyvalue', pure: false}]}], function() {
          return [{type: KeyValueDiffers}];
        }, null);
  })();
  function defaultComparator(keyValueA, keyValueB) {
    const a = keyValueA.key;
    const b = keyValueB.key;
    if (a === b) return 0;
    if (a === void 0) return 1;
    if (b === void 0) return -1;
    if (a === null) return 1;
    if (b === null) return -1;
    if (typeof a == 'string' && typeof b == 'string') {
      return a < b ? -1 : 1;
    }
    if (typeof a == 'number' && typeof b == 'number') {
      return a - b;
    }
    if (typeof a == 'boolean' && typeof b == 'boolean') {
      return a < b ? -1 : 1;
    }
    const aString = String(a);
    const bString = String(b);
    return aString == bString ? 0 : aString < bString ? -1 : 1;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var DecimalPipe = class {
    constructor(_locale) {
      this._locale = _locale;
    }
    transform(value, digitsInfo, locale) {
      if (!isValue(value)) return null;
      locale = locale || this._locale;
      try {
        const num = strToNumber(value);
        return formatNumber(num, locale, digitsInfo);
      } catch (error) {
        throw invalidPipeArgumentError(DecimalPipe, error.message);
      }
    }
  };
  DecimalPipe.\u0275fac = function DecimalPipe_Factory(t) {
    return new (t || DecimalPipe)(\u0275\u0275directiveInject(LOCALE_ID$1));
  };
  DecimalPipe.\u0275pipe = \u0275\u0275definePipe({name: 'number', type: DecimalPipe, pure: true});
  DecimalPipe.ctorParameters =
      () => [{type: String, decorators: [{type: Inject, args: [LOCALE_ID$1]}]}];
  (function() {
    setClassMetadata(DecimalPipe, [{type: Pipe, args: [{name: 'number'}]}], function() {
      return [{type: String, decorators: [{type: Inject, args: [LOCALE_ID$1]}]}];
    }, null);
  })();
  var PercentPipe = class {
    constructor(_locale) {
      this._locale = _locale;
    }
    transform(value, digitsInfo, locale) {
      if (!isValue(value)) return null;
      locale = locale || this._locale;
      try {
        const num = strToNumber(value);
        return formatPercent(num, locale, digitsInfo);
      } catch (error) {
        throw invalidPipeArgumentError(PercentPipe, error.message);
      }
    }
  };
  PercentPipe.\u0275fac = function PercentPipe_Factory(t) {
    return new (t || PercentPipe)(\u0275\u0275directiveInject(LOCALE_ID$1));
  };
  PercentPipe.\u0275pipe = \u0275\u0275definePipe({name: 'percent', type: PercentPipe, pure: true});
  PercentPipe.ctorParameters =
      () => [{type: String, decorators: [{type: Inject, args: [LOCALE_ID$1]}]}];
  (function() {
    setClassMetadata(PercentPipe, [{type: Pipe, args: [{name: 'percent'}]}], function() {
      return [{type: String, decorators: [{type: Inject, args: [LOCALE_ID$1]}]}];
    }, null);
  })();
  var CurrencyPipe = class {
    constructor(_locale, _defaultCurrencyCode = 'USD') {
      this._locale = _locale;
      this._defaultCurrencyCode = _defaultCurrencyCode;
    }
    transform(value, currencyCode, display = 'symbol', digitsInfo, locale) {
      if (!isValue(value)) return null;
      locale = locale || this._locale;
      if (typeof display === 'boolean') {
        if ((typeof ngDevMode === 'undefined' || ngDevMode) && console && console.warn) {
          console.warn(
              `Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are "code", "symbol" or "symbol-narrow".`);
        }
        display = display ? 'symbol' : 'code';
      }
      let currency = currencyCode || this._defaultCurrencyCode;
      if (display !== 'code') {
        if (display === 'symbol' || display === 'symbol-narrow') {
          currency = getCurrencySymbol(currency, display === 'symbol' ? 'wide' : 'narrow', locale);
        } else {
          currency = display;
        }
      }
      try {
        const num = strToNumber(value);
        return formatCurrency(num, locale, currency, currencyCode, digitsInfo);
      } catch (error) {
        throw invalidPipeArgumentError(CurrencyPipe, error.message);
      }
    }
  };
  CurrencyPipe.\u0275fac = function CurrencyPipe_Factory(t) {
    return new (t || CurrencyPipe)(
        \u0275\u0275directiveInject(LOCALE_ID$1),
        \u0275\u0275directiveInject(DEFAULT_CURRENCY_CODE));
  };
  CurrencyPipe.\u0275pipe =
      \u0275\u0275definePipe({name: 'currency', type: CurrencyPipe, pure: true});
  CurrencyPipe.ctorParameters = () =>
      [{type: String, decorators: [{type: Inject, args: [LOCALE_ID$1]}]},
       {type: String, decorators: [{type: Inject, args: [DEFAULT_CURRENCY_CODE]}]}];
  (function() {
    setClassMetadata(CurrencyPipe, [{type: Pipe, args: [{name: 'currency'}]}], function() {
      return [
        {type: String, decorators: [{type: Inject, args: [LOCALE_ID$1]}]},
        {type: String, decorators: [{type: Inject, args: [DEFAULT_CURRENCY_CODE]}]}
      ];
    }, null);
  })();
  function isValue(value) {
    return !(value == null || value === '' || value !== value);
  }
  function strToNumber(value) {
    if (typeof value === 'string' && !isNaN(Number(value) - parseFloat(value))) {
      return Number(value);
    }
    if (typeof value !== 'number') {
      throw new Error(`${value} is not a number`);
    }
    return value;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var SlicePipe = class {
    transform(value, start, end) {
      if (value == null) return null;
      if (!this.supports(value)) {
        throw invalidPipeArgumentError(SlicePipe, value);
      }
      return value.slice(start, end);
    }
    supports(obj) {
      return typeof obj === 'string' || Array.isArray(obj);
    }
  };
  SlicePipe.\u0275fac = function SlicePipe_Factory(t) {
    return new (t || SlicePipe)();
  };
  SlicePipe.\u0275pipe = \u0275\u0275definePipe({name: 'slice', type: SlicePipe, pure: false});
  (function() {
    setClassMetadata(SlicePipe, [{type: Pipe, args: [{name: 'slice', pure: false}]}], null, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var COMMON_PIPES = [
    AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe,
    TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe
  ];
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var CommonModule = class {};
  CommonModule.\u0275mod = \u0275\u0275defineNgModule({type: CommonModule});
  CommonModule.\u0275inj = \u0275\u0275defineInjector({
    factory: function CommonModule_Factory(t) {
      return new (t || CommonModule)();
    },
    providers: [{provide: NgLocalization, useClass: NgLocaleLocalization}]
  });
  (function() {
    (typeof ngJitMode === 'undefined' || ngJitMode) && \u0275\u0275setNgModuleScope(CommonModule, {
      declarations: [
        NgClass,          NgComponentOutlet, NgForOf,        NgIf,
        NgTemplateOutlet, NgStyle,           NgSwitch,       NgSwitchCase,
        NgSwitchDefault,  NgPlural,          NgPluralCase,   AsyncPipe,
        UpperCasePipe,    LowerCasePipe,     JsonPipe,       SlicePipe,
        DecimalPipe,      PercentPipe,       TitleCasePipe,  CurrencyPipe,
        DatePipe,         I18nPluralPipe,    I18nSelectPipe, KeyValuePipe
      ],
      exports: [
        NgClass,          NgComponentOutlet, NgForOf,        NgIf,
        NgTemplateOutlet, NgStyle,           NgSwitch,       NgSwitchCase,
        NgSwitchDefault,  NgPlural,          NgPluralCase,   AsyncPipe,
        UpperCasePipe,    LowerCasePipe,     JsonPipe,       SlicePipe,
        DecimalPipe,      PercentPipe,       TitleCasePipe,  CurrencyPipe,
        DatePipe,         I18nPluralPipe,    I18nSelectPipe, KeyValuePipe
      ]
    });
  })();
  (function() {
    setClassMetadata(
        CommonModule, [{
          type: NgModule,
          args: [{
            declarations: [COMMON_DIRECTIVES, COMMON_PIPES],
            exports: [COMMON_DIRECTIVES, COMMON_PIPES],
            providers: [{provide: NgLocalization, useClass: NgLocaleLocalization}]
          }]
        }],
        null, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var PLATFORM_BROWSER_ID = 'browser';
  function isPlatformBrowser(platformId) {
    return platformId === PLATFORM_BROWSER_ID;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var VERSION2 = new Version('11.0.9');
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ViewportScroller = class {};
  ViewportScroller.\u0275prov = \u0275\u0275defineInjectable({
    token: ViewportScroller,
    providedIn: 'root',
    factory: () => new BrowserViewportScroller(\u0275\u0275inject(DOCUMENT2), window)
  });
  var BrowserViewportScroller = class {
    constructor(document2, window3) {
      this.document = document2;
      this.window = window3;
      this.offset = () => [0, 0];
    }
    setOffset(offset) {
      if (Array.isArray(offset)) {
        this.offset = () => offset;
      } else {
        this.offset = offset;
      }
    }
    getScrollPosition() {
      if (this.supportsScrolling()) {
        return [this.window.pageXOffset, this.window.pageYOffset];
      } else {
        return [0, 0];
      }
    }
    scrollToPosition(position) {
      if (this.supportsScrolling()) {
        this.window.scrollTo(position[0], position[1]);
      }
    }
    scrollToAnchor(target) {
      var _a;
      if (!this.supportsScrolling()) {
        return;
      }
      const elSelected = (_a = this.document.getElementById(target)) !== null && _a !== void 0 ?
          _a :
          this.document.getElementsByName(target)[0];
      if (elSelected === void 0) {
        return;
      }
      this.scrollToElement(elSelected);
      this.attemptFocus(elSelected);
    }
    setHistoryScrollRestoration(scrollRestoration) {
      if (this.supportScrollRestoration()) {
        const history = this.window.history;
        if (history && history.scrollRestoration) {
          history.scrollRestoration = scrollRestoration;
        }
      }
    }
    scrollToElement(el) {
      const rect = el.getBoundingClientRect();
      const left = rect.left + this.window.pageXOffset;
      const top = rect.top + this.window.pageYOffset;
      const offset = this.offset();
      this.window.scrollTo(left - offset[0], top - offset[1]);
    }
    attemptFocus(focusTarget) {
      focusTarget.focus();
      return this.document.activeElement === focusTarget;
    }
    supportScrollRestoration() {
      try {
        if (!this.supportsScrolling()) {
          return false;
        }
        const scrollRestorationDescriptor = getScrollRestorationProperty(this.window.history) ||
            getScrollRestorationProperty(Object.getPrototypeOf(this.window.history));
        return !!scrollRestorationDescriptor &&
            !!(scrollRestorationDescriptor.writable || scrollRestorationDescriptor.set);
      } catch (_a) {
        return false;
      }
    }
    supportsScrolling() {
      try {
        return !!this.window && !!this.window.scrollTo && 'pageXOffset' in this.window;
      } catch (_a) {
        return false;
      }
    }
  };
  function getScrollRestorationProperty(obj) {
    return Object.getOwnPropertyDescriptor(obj, 'scrollRestoration');
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */

  // external/npm/node_modules/@angular/platform-browser/fesm2015/platform-browser.js
  /**
   * @license Angular v11.0.9
   * (c) 2010-2020 Google LLC. https://angular.io/
   * License: MIT
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var GenericBrowserDomAdapter = class extends DomAdapter {
    constructor() {
      super();
    }
    supportsDOMEvents() {
      return true;
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var \u027502 = () => {
    if (_global['Node']) {
      return _global['Node'].prototype.contains || function(node) {
        return !!(this.compareDocumentPosition(node) & 16);
      };
    }
    return void 0;
  };
  var nodeContains = \u027502();
  var BrowserDomAdapter = class extends GenericBrowserDomAdapter {
    static makeCurrent() {
      setRootDomAdapter(new BrowserDomAdapter());
    }
    getProperty(el, name) {
      return el[name];
    }
    log(error) {
      if (window.console) {
        window.console.log && window.console.log(error);
      }
    }
    logGroup(error) {
      if (window.console) {
        window.console.group && window.console.group(error);
      }
    }
    logGroupEnd() {
      if (window.console) {
        window.console.groupEnd && window.console.groupEnd();
      }
    }
    onAndCancel(el, evt, listener) {
      el.addEventListener(evt, listener, false);
      return () => {
        el.removeEventListener(evt, listener, false);
      };
    }
    dispatchEvent(el, evt) {
      el.dispatchEvent(evt);
    }
    remove(node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
      return node;
    }
    getValue(el) {
      return el.value;
    }
    createElement(tagName, doc) {
      doc = doc || this.getDefaultDocument();
      return doc.createElement(tagName);
    }
    createHtmlDocument() {
      return document.implementation.createHTMLDocument('fakeTitle');
    }
    getDefaultDocument() {
      return document;
    }
    isElementNode(node) {
      return node.nodeType === Node.ELEMENT_NODE;
    }
    isShadowRoot(node) {
      return node instanceof DocumentFragment;
    }
    getGlobalEventTarget(doc, target) {
      if (target === 'window') {
        return window;
      }
      if (target === 'document') {
        return doc;
      }
      if (target === 'body') {
        return doc.body;
      }
      return null;
    }
    getHistory() {
      return window.history;
    }
    getLocation() {
      return window.location;
    }
    getBaseHref(doc) {
      const href = getBaseElementHref();
      return href == null ? null : relativePath(href);
    }
    resetBaseElement() {
      baseElement = null;
    }
    getUserAgent() {
      return window.navigator.userAgent;
    }
    performanceNow() {
      return window.performance && window.performance.now ? window.performance.now() :
                                                            new Date().getTime();
    }
    supportsCookies() {
      return true;
    }
    getCookie(name) {
      return parseCookieValue(document.cookie, name);
    }
  };
  var baseElement = null;
  function getBaseElementHref() {
    if (!baseElement) {
      baseElement = document.querySelector('base');
      if (!baseElement) {
        return null;
      }
    }
    return baseElement.getAttribute('href');
  }
  var urlParsingNode;
  function relativePath(url) {
    if (!urlParsingNode) {
      urlParsingNode = document.createElement('a');
    }
    urlParsingNode.setAttribute('href', url);
    return urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname :
                                                       '/' + urlParsingNode.pathname;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var TRANSITION_ID = new InjectionToken('TRANSITION_ID');
  function appInitializerFactory(transitionId, document2, injector) {
    return () => {
      injector.get(ApplicationInitStatus).donePromise.then(() => {
        const dom = getDOM();
        const styles =
            Array.prototype.slice.apply(document2.querySelectorAll(`style[ng-transition]`));
        styles.filter((el) => el.getAttribute('ng-transition') === transitionId)
            .forEach((el) => dom.remove(el));
      });
    };
  }
  var SERVER_TRANSITION_PROVIDERS = [{
    provide: APP_INITIALIZER,
    useFactory: appInitializerFactory,
    deps: [TRANSITION_ID, DOCUMENT2, Injector],
    multi: true
  }];
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var BrowserGetTestability = class {
    static init() {
      setTestabilityGetter(new BrowserGetTestability());
    }
    addToWindow(registry) {
      _global['getAngularTestability'] = (elem, findInAncestors = true) => {
        const testability = registry.findTestabilityInTree(elem, findInAncestors);
        if (testability == null) {
          throw new Error('Could not find testability for element.');
        }
        return testability;
      };
      _global['getAllAngularTestabilities'] = () => registry.getAllTestabilities();
      _global['getAllAngularRootElements'] = () => registry.getAllRootElements();
      const whenAllStable = (callback) => {
        const testabilities = _global['getAllAngularTestabilities']();
        let count2 = testabilities.length;
        let didWork = false;
        const decrement = function(didWork_) {
          didWork = didWork || didWork_;
          count2--;
          if (count2 == 0) {
            callback(didWork);
          }
        };
        testabilities.forEach(function(testability) {
          testability.whenStable(decrement);
        });
      };
      if (!_global['frameworkStabilizers']) {
        _global['frameworkStabilizers'] = [];
      }
      _global['frameworkStabilizers'].push(whenAllStable);
    }
    findTestabilityInTree(registry, elem, findInAncestors) {
      if (elem == null) {
        return null;
      }
      const t = registry.getTestability(elem);
      if (t != null) {
        return t;
      } else if (!findInAncestors) {
        return null;
      }
      if (getDOM().isShadowRoot(elem)) {
        return this.findTestabilityInTree(registry, elem.host, true);
      }
      return this.findTestabilityInTree(registry, elem.parentElement, true);
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function exportNgVar(name, value) {
    if (typeof COMPILED === 'undefined' || !COMPILED) {
      const ng = _global['ng'] = _global['ng'] || {};
      ng[name] = value;
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var \u02750$12 = () => ({ApplicationRef, NgZone});
  var CORE_TOKENS = \u02750$12();
  var INSPECT_GLOBAL_NAME = 'probe';
  var CORE_TOKENS_GLOBAL_NAME = 'coreTokens';
  function inspectNativeElementR2(element) {
    return getDebugNodeR2(element);
  }
  function _createNgProbeR2(coreTokens) {
    exportNgVar(INSPECT_GLOBAL_NAME, inspectNativeElementR2);
    exportNgVar(
        CORE_TOKENS_GLOBAL_NAME,
        Object.assign(Object.assign({}, CORE_TOKENS), _ngProbeTokensToMap(coreTokens || [])));
    return () => inspectNativeElementR2;
  }
  function _ngProbeTokensToMap(tokens) {
    return tokens.reduce((prev, t) => (prev[t.name] = t.token, prev), {});
  }
  var ELEMENT_PROBE_PROVIDERS__POST_R3__ = [];
  var ELEMENT_PROBE_PROVIDERS__PRE_R3__ = [{
    provide: APP_INITIALIZER,
    useFactory: _createNgProbeR2,
    deps: [[NgProbeToken, new Optional()]],
    multi: true
  }];
  var ELEMENT_PROBE_PROVIDERS = ELEMENT_PROBE_PROVIDERS__POST_R3__;
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var EVENT_MANAGER_PLUGINS = new InjectionToken('EventManagerPlugins');
  var EventManager = class {
    constructor(plugins, _zone) {
      this._zone = _zone;
      this._eventNameToPlugin = new Map();
      plugins.forEach((p) => p.manager = this);
      this._plugins = plugins.slice().reverse();
    }
    addEventListener(element, eventName, handler) {
      const plugin = this._findPluginFor(eventName);
      return plugin.addEventListener(element, eventName, handler);
    }
    addGlobalEventListener(target, eventName, handler) {
      const plugin = this._findPluginFor(eventName);
      return plugin.addGlobalEventListener(target, eventName, handler);
    }
    getZone() {
      return this._zone;
    }
    _findPluginFor(eventName) {
      const plugin = this._eventNameToPlugin.get(eventName);
      if (plugin) {
        return plugin;
      }
      const plugins = this._plugins;
      for (let i = 0; i < plugins.length; i++) {
        const plugin2 = plugins[i];
        if (plugin2.supports(eventName)) {
          this._eventNameToPlugin.set(eventName, plugin2);
          return plugin2;
        }
      }
      throw new Error(`No event manager plugin found for event ${eventName}`);
    }
  };
  EventManager.\u0275fac = function EventManager_Factory(t) {
    return new (t || EventManager)(
        \u0275\u0275inject(EVENT_MANAGER_PLUGINS), \u0275\u0275inject(NgZone));
  };
  EventManager.\u0275prov =
      \u0275\u0275defineInjectable({token: EventManager, factory: EventManager.\u0275fac});
  EventManager.ctorParameters =
      () => [{type: Array, decorators: [{type: Inject, args: [EVENT_MANAGER_PLUGINS]}]}, {
        type: NgZone
      }];
  (function() {
    setClassMetadata(EventManager, [{type: Injectable}], function() {
      return [
        {type: Array, decorators: [{type: Inject, args: [EVENT_MANAGER_PLUGINS]}]}, {type: NgZone}
      ];
    }, null);
  })();
  var EventManagerPlugin = class {
    constructor(_doc) {
      this._doc = _doc;
    }
    addGlobalEventListener(element, eventName, handler) {
      const target = getDOM().getGlobalEventTarget(this._doc, element);
      if (!target) {
        throw new Error(`Unsupported event target ${target} for event ${eventName}`);
      }
      return this.addEventListener(target, eventName, handler);
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var SharedStylesHost = class {
    constructor() {
      this._stylesSet = new Set();
    }
    addStyles(styles) {
      const additions = new Set();
      styles.forEach((style) => {
        if (!this._stylesSet.has(style)) {
          this._stylesSet.add(style);
          additions.add(style);
        }
      });
      this.onStylesAdded(additions);
    }
    onStylesAdded(additions) {}
    getAllStyles() {
      return Array.from(this._stylesSet);
    }
  };
  SharedStylesHost.\u0275fac = function SharedStylesHost_Factory(t) {
    return new (t || SharedStylesHost)();
  };
  SharedStylesHost.\u0275prov =
      \u0275\u0275defineInjectable({token: SharedStylesHost, factory: SharedStylesHost.\u0275fac});
  (function() {
    setClassMetadata(SharedStylesHost, [{type: Injectable}], function() {
      return [];
    }, null);
  })();
  var DomSharedStylesHost = class extends SharedStylesHost {
    constructor(_doc) {
      super();
      this._doc = _doc;
      this._hostNodes = new Set();
      this._styleNodes = new Set();
      this._hostNodes.add(_doc.head);
    }
    _addStylesToHost(styles, host) {
      styles.forEach((style) => {
        const styleEl = this._doc.createElement('style');
        styleEl.textContent = style;
        this._styleNodes.add(host.appendChild(styleEl));
      });
    }
    addHost(hostNode) {
      this._addStylesToHost(this._stylesSet, hostNode);
      this._hostNodes.add(hostNode);
    }
    removeHost(hostNode) {
      this._hostNodes.delete(hostNode);
    }
    onStylesAdded(additions) {
      this._hostNodes.forEach((hostNode) => this._addStylesToHost(additions, hostNode));
    }
    ngOnDestroy() {
      this._styleNodes.forEach((styleNode) => getDOM().remove(styleNode));
    }
  };
  DomSharedStylesHost.\u0275fac = function DomSharedStylesHost_Factory(t) {
    return new (t || DomSharedStylesHost)(\u0275\u0275inject(DOCUMENT2));
  };
  DomSharedStylesHost.\u0275prov = \u0275\u0275defineInjectable(
      {token: DomSharedStylesHost, factory: DomSharedStylesHost.\u0275fac});
  DomSharedStylesHost.ctorParameters =
      () => [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]}];
  (function() {
    setClassMetadata(DomSharedStylesHost, [{type: Injectable}], function() {
      return [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]}];
    }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NAMESPACE_URIS = {
    svg: 'http://www.w3.org/2000/svg',
    xhtml: 'http://www.w3.org/1999/xhtml',
    xlink: 'http://www.w3.org/1999/xlink',
    xml: 'http://www.w3.org/XML/1998/namespace',
    xmlns: 'http://www.w3.org/2000/xmlns/'
  };
  var COMPONENT_REGEX = /%COMP%/g;
  var NG_DEV_MODE2 = typeof ngDevMode === 'undefined' || !!ngDevMode;
  var COMPONENT_VARIABLE = '%COMP%';
  var HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
  var CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
  function shimContentAttribute(componentShortId) {
    return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
  }
  function shimHostAttribute(componentShortId) {
    return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
  }
  function flattenStyles(compId, styles, target) {
    for (let i = 0; i < styles.length; i++) {
      let style = styles[i];
      if (Array.isArray(style)) {
        flattenStyles(compId, style, target);
      } else {
        style = style.replace(COMPONENT_REGEX, compId);
        target.push(style);
      }
    }
    return target;
  }
  function decoratePreventDefault(eventHandler) {
    return (event) => {
      if (event === '__ngUnwrap__') {
        return eventHandler;
      }
      const allowDefaultBehavior = eventHandler(event);
      if (allowDefaultBehavior === false) {
        event.preventDefault();
        event.returnValue = false;
      }
      return void 0;
    };
  }
  var hasLoggedNativeEncapsulationWarning = false;
  var DomRendererFactory2 = class {
    constructor(eventManager, sharedStylesHost, appId) {
      this.eventManager = eventManager;
      this.sharedStylesHost = sharedStylesHost;
      this.appId = appId;
      this.rendererByCompId = new Map();
      this.defaultRenderer = new DefaultDomRenderer2(eventManager);
    }
    createRenderer(element, type) {
      if (!element || !type) {
        return this.defaultRenderer;
      }
      switch (type.encapsulation) {
        case ViewEncapsulation.Emulated: {
          let renderer = this.rendererByCompId.get(type.id);
          if (!renderer) {
            renderer = new EmulatedEncapsulationDomRenderer2(
                this.eventManager, this.sharedStylesHost, type, this.appId);
            this.rendererByCompId.set(type.id, renderer);
          }
          renderer.applyToHost(element);
          return renderer;
        }
        case 1:
        case ViewEncapsulation.ShadowDom:
          if ((typeof ngDevMode === 'undefined' || ngDevMode) &&
              !hasLoggedNativeEncapsulationWarning && type.encapsulation === 1) {
            hasLoggedNativeEncapsulationWarning = true;
            console.warn(
                'ViewEncapsulation.Native is no longer supported. Falling back to ViewEncapsulation.ShadowDom. The fallback will be removed in v12.');
          }
          return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);
        default: {
          if (!this.rendererByCompId.has(type.id)) {
            const styles = flattenStyles(type.id, type.styles, []);
            this.sharedStylesHost.addStyles(styles);
            this.rendererByCompId.set(type.id, this.defaultRenderer);
          }
          return this.defaultRenderer;
        }
      }
    }
    begin() {}
    end() {}
  };
  DomRendererFactory2.\u0275fac = function DomRendererFactory2_Factory(t) {
    return new (t || DomRendererFactory2)(
        \u0275\u0275inject(EventManager), \u0275\u0275inject(DomSharedStylesHost),
        \u0275\u0275inject(APP_ID));
  };
  DomRendererFactory2.\u0275prov = \u0275\u0275defineInjectable(
      {token: DomRendererFactory2, factory: DomRendererFactory2.\u0275fac});
  DomRendererFactory2.ctorParameters = () => [{type: EventManager}, {type: DomSharedStylesHost}, {
    type: String,
    decorators: [{type: Inject, args: [APP_ID]}]
  }];
  (function() {
    setClassMetadata(DomRendererFactory2, [{type: Injectable}], function() {
      return [
        {type: EventManager}, {type: DomSharedStylesHost},
        {type: String, decorators: [{type: Inject, args: [APP_ID]}]}
      ];
    }, null);
  })();
  var DefaultDomRenderer2 = class {
    constructor(eventManager) {
      this.eventManager = eventManager;
      this.data = Object.create(null);
    }
    destroy() {}
    createElement(name, namespace) {
      if (namespace) {
        return document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
      }
      return document.createElement(name);
    }
    createComment(value) {
      return document.createComment(value);
    }
    createText(value) {
      return document.createTextNode(value);
    }
    appendChild(parent, newChild) {
      parent.appendChild(newChild);
    }
    insertBefore(parent, newChild, refChild) {
      if (parent) {
        parent.insertBefore(newChild, refChild);
      }
    }
    removeChild(parent, oldChild) {
      if (parent) {
        parent.removeChild(oldChild);
      }
    }
    selectRootElement(selectorOrNode, preserveContent) {
      let el = typeof selectorOrNode === 'string' ? document.querySelector(selectorOrNode) :
                                                    selectorOrNode;
      if (!el) {
        throw new Error(`The selector "${selectorOrNode}" did not match any elements`);
      }
      if (!preserveContent) {
        el.textContent = '';
      }
      return el;
    }
    parentNode(node) {
      return node.parentNode;
    }
    nextSibling(node) {
      return node.nextSibling;
    }
    setAttribute(el, name, value, namespace) {
      if (namespace) {
        name = namespace + ':' + name;
        const namespaceUri = NAMESPACE_URIS[namespace];
        if (namespaceUri) {
          el.setAttributeNS(namespaceUri, name, value);
        } else {
          el.setAttribute(name, value);
        }
      } else {
        el.setAttribute(name, value);
      }
    }
    removeAttribute(el, name, namespace) {
      if (namespace) {
        const namespaceUri = NAMESPACE_URIS[namespace];
        if (namespaceUri) {
          el.removeAttributeNS(namespaceUri, name);
        } else {
          el.removeAttribute(`${namespace}:${name}`);
        }
      } else {
        el.removeAttribute(name);
      }
    }
    addClass(el, name) {
      el.classList.add(name);
    }
    removeClass(el, name) {
      el.classList.remove(name);
    }
    setStyle(el, style, value, flags) {
      if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {
        el.style.setProperty(
            style, value, flags & RendererStyleFlags2.Important ? 'important' : '');
      } else {
        el.style[style] = value;
      }
    }
    removeStyle(el, style, flags) {
      if (flags & RendererStyleFlags2.DashCase) {
        el.style.removeProperty(style);
      } else {
        el.style[style] = '';
      }
    }
    setProperty(el, name, value) {
      NG_DEV_MODE2 && checkNoSyntheticProp(name, 'property');
      el[name] = value;
    }
    setValue(node, value) {
      node.nodeValue = value;
    }
    listen(target, event, callback) {
      NG_DEV_MODE2 && checkNoSyntheticProp(event, 'listener');
      if (typeof target === 'string') {
        return this.eventManager.addGlobalEventListener(
            target, event, decoratePreventDefault(callback));
      }
      return this.eventManager.addEventListener(target, event, decoratePreventDefault(callback));
    }
  };
  var \u02750$22 = () => '@'.charCodeAt(0);
  var AT_CHARCODE = \u02750$22();
  function checkNoSyntheticProp(name, nameKind) {
    if (name.charCodeAt(0) === AT_CHARCODE) {
      throw new Error(`Found the synthetic ${nameKind} ${
          name}. Please include either "BrowserAnimationsModule" or "NoopAnimationsModule" in your application.`);
    }
  }
  var EmulatedEncapsulationDomRenderer2 = class extends DefaultDomRenderer2 {
    constructor(eventManager, sharedStylesHost, component, appId) {
      super(eventManager);
      this.component = component;
      const styles = flattenStyles(appId + '-' + component.id, component.styles, []);
      sharedStylesHost.addStyles(styles);
      this.contentAttr = shimContentAttribute(appId + '-' + component.id);
      this.hostAttr = shimHostAttribute(appId + '-' + component.id);
    }
    applyToHost(element) {
      super.setAttribute(element, this.hostAttr, '');
    }
    createElement(parent, name) {
      const el = super.createElement(parent, name);
      super.setAttribute(el, this.contentAttr, '');
      return el;
    }
  };
  var ShadowDomRenderer = class extends DefaultDomRenderer2 {
    constructor(eventManager, sharedStylesHost, hostEl, component) {
      super(eventManager);
      this.sharedStylesHost = sharedStylesHost;
      this.hostEl = hostEl;
      this.shadowRoot = hostEl.attachShadow({mode: 'open'});
      this.sharedStylesHost.addHost(this.shadowRoot);
      const styles = flattenStyles(component.id, component.styles, []);
      for (let i = 0; i < styles.length; i++) {
        const styleEl = document.createElement('style');
        styleEl.textContent = styles[i];
        this.shadowRoot.appendChild(styleEl);
      }
    }
    nodeOrShadowRoot(node) {
      return node === this.hostEl ? this.shadowRoot : node;
    }
    destroy() {
      this.sharedStylesHost.removeHost(this.shadowRoot);
    }
    appendChild(parent, newChild) {
      return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
    }
    insertBefore(parent, newChild, refChild) {
      return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
    }
    removeChild(parent, oldChild) {
      return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);
    }
    parentNode(node) {
      return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var DomEventsPlugin = class extends EventManagerPlugin {
    constructor(doc) {
      super(doc);
    }
    supports(eventName) {
      return true;
    }
    addEventListener(element, eventName, handler) {
      element.addEventListener(eventName, handler, false);
      return () => this.removeEventListener(element, eventName, handler);
    }
    removeEventListener(target, eventName, callback) {
      return target.removeEventListener(eventName, callback);
    }
  };
  DomEventsPlugin.\u0275fac = function DomEventsPlugin_Factory(t) {
    return new (t || DomEventsPlugin)(\u0275\u0275inject(DOCUMENT2));
  };
  DomEventsPlugin.\u0275prov =
      \u0275\u0275defineInjectable({token: DomEventsPlugin, factory: DomEventsPlugin.\u0275fac});
  DomEventsPlugin.ctorParameters =
      () => [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]}];
  (function() {
    setClassMetadata(DomEventsPlugin, [{type: Injectable}], function() {
      return [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]}];
    }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var EVENT_NAMES = {
    pan: true,
    panstart: true,
    panmove: true,
    panend: true,
    pancancel: true,
    panleft: true,
    panright: true,
    panup: true,
    pandown: true,
    pinch: true,
    pinchstart: true,
    pinchmove: true,
    pinchend: true,
    pinchcancel: true,
    pinchin: true,
    pinchout: true,
    press: true,
    pressup: true,
    rotate: true,
    rotatestart: true,
    rotatemove: true,
    rotateend: true,
    rotatecancel: true,
    swipe: true,
    swipeleft: true,
    swiperight: true,
    swipeup: true,
    swipedown: true,
    tap: true
  };
  var HAMMER_GESTURE_CONFIG = new InjectionToken('HammerGestureConfig');
  var HAMMER_LOADER = new InjectionToken('HammerLoader');
  var HammerGestureConfig = class {
    constructor() {
      this.events = [];
      this.overrides = {};
    }
    buildHammer(element) {
      const mc = new Hammer(element, this.options);
      mc.get('pinch').set({enable: true});
      mc.get('rotate').set({enable: true});
      for (const eventName in this.overrides) {
        mc.get(eventName).set(this.overrides[eventName]);
      }
      return mc;
    }
  };
  HammerGestureConfig.\u0275fac = function HammerGestureConfig_Factory(t) {
    return new (t || HammerGestureConfig)();
  };
  HammerGestureConfig.\u0275prov = \u0275\u0275defineInjectable(
      {token: HammerGestureConfig, factory: HammerGestureConfig.\u0275fac});
  (function() {
    setClassMetadata(HammerGestureConfig, [{type: Injectable}], function() {
      return [];
    }, null);
  })();
  var HammerGesturesPlugin = class extends EventManagerPlugin {
    constructor(doc, _config, console2, loader) {
      super(doc);
      this._config = _config;
      this.console = console2;
      this.loader = loader;
    }
    supports(eventName) {
      if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
        return false;
      }
      if (!window.Hammer && !this.loader) {
        this.console.warn(`The "${
            eventName}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`);
        return false;
      }
      return true;
    }
    addEventListener(element, eventName, handler) {
      const zone = this.manager.getZone();
      eventName = eventName.toLowerCase();
      if (!window.Hammer && this.loader) {
        let cancelRegistration = false;
        let deregister = () => {
          cancelRegistration = true;
        };
        this.loader()
            .then(() => {
              if (!window.Hammer) {
                this.console.warn(
                    `The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
                deregister = () => {};
                return;
              }
              if (!cancelRegistration) {
                deregister = this.addEventListener(element, eventName, handler);
              }
            })
            .catch(() => {
              this.console.warn(`The "${
                  eventName}" event cannot be bound because the custom Hammer.JS loader failed.`);
              deregister = () => {};
            });
        return () => {
          deregister();
        };
      }
      return zone.runOutsideAngular(() => {
        const mc = this._config.buildHammer(element);
        const callback = function(eventObj) {
          zone.runGuarded(function() {
            handler(eventObj);
          });
        };
        mc.on(eventName, callback);
        return () => {
          mc.off(eventName, callback);
          if (typeof mc.destroy === 'function') {
            mc.destroy();
          }
        };
      });
    }
    isCustomEvent(eventName) {
      return this._config.events.indexOf(eventName) > -1;
    }
  };
  HammerGesturesPlugin.\u0275fac = function HammerGesturesPlugin_Factory(t) {
    return new (t || HammerGesturesPlugin)(
        \u0275\u0275inject(DOCUMENT2), \u0275\u0275inject(HAMMER_GESTURE_CONFIG),
        \u0275\u0275inject(Console), \u0275\u0275inject(HAMMER_LOADER, 8));
  };
  HammerGesturesPlugin.\u0275prov = \u0275\u0275defineInjectable(
      {token: HammerGesturesPlugin, factory: HammerGesturesPlugin.\u0275fac});
  HammerGesturesPlugin.ctorParameters = () =>
      [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]},
       {type: HammerGestureConfig, decorators: [{type: Inject, args: [HAMMER_GESTURE_CONFIG]}]},
       {type: Console},
       {type: void 0, decorators: [{type: Optional}, {type: Inject, args: [HAMMER_LOADER]}]}];
  (function() {
    setClassMetadata(HammerGesturesPlugin, [{type: Injectable}], function() {
      return [
        {type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]},
        {type: HammerGestureConfig, decorators: [{type: Inject, args: [HAMMER_GESTURE_CONFIG]}]},
        {type: Console},
        {type: void 0, decorators: [{type: Optional}, {type: Inject, args: [HAMMER_LOADER]}]}
      ];
    }, null);
  })();
  var HAMMER_PROVIDERS__POST_R3__ = [];
  var HAMMER_PROVIDERS__PRE_R3__ = [
    {
      provide: EVENT_MANAGER_PLUGINS,
      useClass: HammerGesturesPlugin,
      multi: true,
      deps: [DOCUMENT2, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]
    },
    {provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig, deps: []}
  ];
  var HAMMER_PROVIDERS = HAMMER_PROVIDERS__POST_R3__;
  var HammerModule = class {};
  HammerModule.\u0275mod = \u0275\u0275defineNgModule({type: HammerModule});
  HammerModule.\u0275inj = \u0275\u0275defineInjector({
    factory: function HammerModule_Factory(t) {
      return new (t || HammerModule)();
    },
    providers: HAMMER_PROVIDERS__PRE_R3__
  });
  (function() {
    setClassMetadata(
        HammerModule, [{type: NgModule, args: [{providers: HAMMER_PROVIDERS__PRE_R3__}]}], null,
        null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];
  var DOM_KEY_LOCATION_NUMPAD = 3;
  var _keyMap = {
    '\b': 'Backspace',
    '	': 'Tab',
    '\x7F': 'Delete',
    '': 'Escape',
    Del: 'Delete',
    Esc: 'Escape',
    Left: 'ArrowLeft',
    Right: 'ArrowRight',
    Up: 'ArrowUp',
    Down: 'ArrowDown',
    Menu: 'ContextMenu',
    Scroll: 'ScrollLock',
    Win: 'OS'
  };
  var _chromeNumKeyPadMap = {
    A: '1',
    B: '2',
    C: '3',
    D: '4',
    E: '5',
    F: '6',
    G: '7',
    H: '8',
    I: '9',
    J: '*',
    K: '+',
    M: '-',
    N: '.',
    O: '/',
    '`': '0',
    '\x90': 'NumLock'
  };
  var \u02750$32 = (event) => event.altKey;
  var \u027512 = (event) => event.ctrlKey;
  var \u027522 = (event) => event.metaKey;
  var \u027532 = (event) => event.shiftKey;
  var MODIFIER_KEY_GETTERS = {alt: \u02750$32, control: \u027512, meta: \u027522, shift: \u027532};
  var KeyEventsPlugin = class extends EventManagerPlugin {
    constructor(doc) {
      super(doc);
    }
    supports(eventName) {
      return KeyEventsPlugin.parseEventName(eventName) != null;
    }
    addEventListener(element, eventName, handler) {
      const parsedEvent = KeyEventsPlugin.parseEventName(eventName);
      const outsideHandler =
          KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());
      return this.manager.getZone().runOutsideAngular(() => {
        return getDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);
      });
    }
    static parseEventName(eventName) {
      const parts = eventName.toLowerCase().split('.');
      const domEventName = parts.shift();
      if (parts.length === 0 || !(domEventName === 'keydown' || domEventName === 'keyup')) {
        return null;
      }
      const key = KeyEventsPlugin._normalizeKey(parts.pop());
      let fullKey = '';
      MODIFIER_KEYS.forEach((modifierName) => {
        const index = parts.indexOf(modifierName);
        if (index > -1) {
          parts.splice(index, 1);
          fullKey += modifierName + '.';
        }
      });
      fullKey += key;
      if (parts.length != 0 || key.length === 0) {
        return null;
      }
      const result = {};
      result['domEventName'] = domEventName;
      result['fullKey'] = fullKey;
      return result;
    }
    static getEventFullKey(event) {
      let fullKey = '';
      let key = getEventKey(event);
      key = key.toLowerCase();
      if (key === ' ') {
        key = 'space';
      } else if (key === '.') {
        key = 'dot';
      }
      MODIFIER_KEYS.forEach((modifierName) => {
        if (modifierName != key) {
          const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
          if (modifierGetter(event)) {
            fullKey += modifierName + '.';
          }
        }
      });
      fullKey += key;
      return fullKey;
    }
    static eventCallback(fullKey, handler, zone) {
      return (event) => {
        if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {
          zone.runGuarded(() => handler(event));
        }
      };
    }
    static _normalizeKey(keyName) {
      switch (keyName) {
        case 'esc':
          return 'escape';
        default:
          return keyName;
      }
    }
  };
  KeyEventsPlugin.\u0275fac = function KeyEventsPlugin_Factory(t) {
    return new (t || KeyEventsPlugin)(\u0275\u0275inject(DOCUMENT2));
  };
  KeyEventsPlugin.\u0275prov =
      \u0275\u0275defineInjectable({token: KeyEventsPlugin, factory: KeyEventsPlugin.\u0275fac});
  KeyEventsPlugin.ctorParameters =
      () => [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]}];
  (function() {
    setClassMetadata(KeyEventsPlugin, [{type: Injectable}], function() {
      return [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]}];
    }, null);
  })();
  function getEventKey(event) {
    let key = event.key;
    if (key == null) {
      key = event.keyIdentifier;
      if (key == null) {
        return 'Unidentified';
      }
      if (key.startsWith('U+')) {
        key = String.fromCharCode(parseInt(key.substring(2), 16));
        if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
          key = _chromeNumKeyPadMap[key];
        }
      }
    }
    return _keyMap[key] || key;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var DomSanitizer = class {};
  DomSanitizer.\u0275fac = function DomSanitizer_Factory(t) {
    return new (t || DomSanitizer)();
  };
  DomSanitizer.\u0275prov = \u0275\u0275defineInjectable({
    factory: function DomSanitizer_Factory2() {
      return \u0275\u0275inject(DomSanitizerImpl);
    },
    token: DomSanitizer,
    providedIn: 'root'
  });
  (function() {
    setClassMetadata(
        DomSanitizer, [{
          type: Injectable,
          args: [{providedIn: 'root', useExisting: forwardRef(() => DomSanitizerImpl)}]
        }],
        null, null);
  })();
  function domSanitizerImplFactory(injector) {
    return new DomSanitizerImpl(injector.get(DOCUMENT2));
  }
  var DomSanitizerImpl = class extends DomSanitizer {
    constructor(_doc) {
      super();
      this._doc = _doc;
    }
    sanitize(ctx, value) {
      if (value == null) return null;
      switch (ctx) {
        case SecurityContext.NONE:
          return value;
        case SecurityContext.HTML:
          if (allowSanitizationBypassAndThrow(value, 'HTML')) {
            return unwrapSafeValue(value);
          }
          return _sanitizeHtml(this._doc, String(value));
        case SecurityContext.STYLE:
          if (allowSanitizationBypassAndThrow(value, 'Style')) {
            return unwrapSafeValue(value);
          }
          return value;
        case SecurityContext.SCRIPT:
          if (allowSanitizationBypassAndThrow(value, 'Script')) {
            return unwrapSafeValue(value);
          }
          throw new Error('unsafe value used in a script context');
        case SecurityContext.URL:
          const type = getSanitizationBypassType(value);
          if (allowSanitizationBypassAndThrow(value, 'URL')) {
            return unwrapSafeValue(value);
          }
          return _sanitizeUrl(String(value));
        case SecurityContext.RESOURCE_URL:
          if (allowSanitizationBypassAndThrow(value, 'ResourceURL')) {
            return unwrapSafeValue(value);
          }
          throw new Error(
              'unsafe value used in a resource URL context (see https://g.co/ng/security#xss)');
        default:
          throw new Error(`Unexpected SecurityContext ${ctx} (see https://g.co/ng/security#xss)`);
      }
    }
    bypassSecurityTrustHtml(value) {
      return bypassSanitizationTrustHtml(value);
    }
    bypassSecurityTrustStyle(value) {
      return bypassSanitizationTrustStyle(value);
    }
    bypassSecurityTrustScript(value) {
      return bypassSanitizationTrustScript(value);
    }
    bypassSecurityTrustUrl(value) {
      return bypassSanitizationTrustUrl(value);
    }
    bypassSecurityTrustResourceUrl(value) {
      return bypassSanitizationTrustResourceUrl(value);
    }
  };
  DomSanitizerImpl.\u0275fac = function DomSanitizerImpl_Factory(t) {
    return new (t || DomSanitizerImpl)(\u0275\u0275inject(DOCUMENT2));
  };
  DomSanitizerImpl.\u0275prov = \u0275\u0275defineInjectable({
    factory: function DomSanitizerImpl_Factory2() {
      return domSanitizerImplFactory(\u0275\u0275inject(INJECTOR$1));
    },
    token: DomSanitizerImpl,
    providedIn: 'root'
  });
  DomSanitizerImpl.ctorParameters =
      () => [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]}];
  (function() {
    setClassMetadata(
        DomSanitizerImpl, [{
          type: Injectable,
          args: [{providedIn: 'root', useFactory: domSanitizerImplFactory, deps: [Injector]}]
        }],
        function() {
          return [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]}];
        },
        null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function initDomAdapter() {
    BrowserDomAdapter.makeCurrent();
    BrowserGetTestability.init();
  }
  function errorHandler() {
    return new ErrorHandler();
  }
  function _document() {
    setDocument(document);
    return document;
  }
  var \u02750$42 = PLATFORM_BROWSER_ID;
  var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [
    {provide: PLATFORM_ID, useValue: \u02750$42},
    {provide: PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true},
    {provide: DOCUMENT2, useFactory: _document, deps: []}
  ];
  var BROWSER_SANITIZATION_PROVIDERS__POST_R3__ = [];
  var BROWSER_SANITIZATION_PROVIDERS = BROWSER_SANITIZATION_PROVIDERS__POST_R3__;
  var platformBrowser =
      createPlatformFactory(platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);
  var BROWSER_MODULE_PROVIDERS = [
    BROWSER_SANITIZATION_PROVIDERS, {provide: INJECTOR_SCOPE, useValue: 'root'},
    {provide: ErrorHandler, useFactory: errorHandler, deps: []}, {
      provide: EVENT_MANAGER_PLUGINS,
      useClass: DomEventsPlugin,
      multi: true,
      deps: [DOCUMENT2, NgZone, PLATFORM_ID]
    },
    {provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true, deps: [DOCUMENT2]},
    HAMMER_PROVIDERS, {
      provide: DomRendererFactory2,
      useClass: DomRendererFactory2,
      deps: [EventManager, DomSharedStylesHost, APP_ID]
    },
    {provide: RendererFactory2, useExisting: DomRendererFactory2},
    {provide: SharedStylesHost, useExisting: DomSharedStylesHost},
    {provide: DomSharedStylesHost, useClass: DomSharedStylesHost, deps: [DOCUMENT2]},
    {provide: Testability, useClass: Testability, deps: [NgZone]},
    {provide: EventManager, useClass: EventManager, deps: [EVENT_MANAGER_PLUGINS, NgZone]},
    ELEMENT_PROBE_PROVIDERS
  ];
  var BrowserModule = class {
    constructor(parentModule) {
      if (parentModule) {
        throw new Error(
            `BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.`);
      }
    }
    static withServerTransition(params) {
      return {
        ngModule: BrowserModule,
        providers: [
          {provide: APP_ID, useValue: params.appId}, {provide: TRANSITION_ID, useExisting: APP_ID},
          SERVER_TRANSITION_PROVIDERS
        ]
      };
    }
  };
  BrowserModule.\u0275mod = \u0275\u0275defineNgModule({type: BrowserModule});
  BrowserModule.\u0275inj = \u0275\u0275defineInjector({
    factory: function BrowserModule_Factory(t) {
      return new (t || BrowserModule)(\u0275\u0275inject(BrowserModule, 12));
    },
    providers: BROWSER_MODULE_PROVIDERS,
    imports: [CommonModule, ApplicationModule]
  });
  BrowserModule.ctorParameters = () => [{
    type: BrowserModule,
    decorators: [{type: Optional}, {type: SkipSelf}, {type: Inject, args: [BrowserModule]}]
  }];
  (function() {
    (typeof ngJitMode === 'undefined' || ngJitMode) && \u0275\u0275setNgModuleScope(BrowserModule, {
      exports: function() {
        return [CommonModule, ApplicationModule];
      }
    });
  })();
  (function() {
    setClassMetadata(
        BrowserModule, [{
          type: NgModule,
          args: [{providers: BROWSER_MODULE_PROVIDERS, exports: [CommonModule, ApplicationModule]}]
        }],
        function() {
          return [{
            type: BrowserModule,
            decorators: [{type: Optional}, {type: SkipSelf}, {type: Inject, args: [BrowserModule]}]
          }];
        },
        null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function createMeta() {
    return new Meta(\u0275\u0275inject(DOCUMENT2));
  }
  var Meta = class {
    constructor(_doc) {
      this._doc = _doc;
      this._dom = getDOM();
    }
    addTag(tag, forceCreation = false) {
      if (!tag) return null;
      return this._getOrCreateElement(tag, forceCreation);
    }
    addTags(tags, forceCreation = false) {
      if (!tags) return [];
      return tags.reduce((result, tag) => {
        if (tag) {
          result.push(this._getOrCreateElement(tag, forceCreation));
        }
        return result;
      }, []);
    }
    getTag(attrSelector) {
      if (!attrSelector) return null;
      return this._doc.querySelector(`meta[${attrSelector}]`) || null;
    }
    getTags(attrSelector) {
      if (!attrSelector) return [];
      const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
      return list ? [].slice.call(list) : [];
    }
    updateTag(tag, selector) {
      if (!tag) return null;
      selector = selector || this._parseSelector(tag);
      const meta = this.getTag(selector);
      if (meta) {
        return this._setMetaElementAttributes(tag, meta);
      }
      return this._getOrCreateElement(tag, true);
    }
    removeTag(attrSelector) {
      this.removeTagElement(this.getTag(attrSelector));
    }
    removeTagElement(meta) {
      if (meta) {
        this._dom.remove(meta);
      }
    }
    _getOrCreateElement(meta, forceCreation = false) {
      if (!forceCreation) {
        const selector = this._parseSelector(meta);
        const elem = this.getTag(selector);
        if (elem && this._containsAttributes(meta, elem)) return elem;
      }
      const element = this._dom.createElement('meta');
      this._setMetaElementAttributes(meta, element);
      const head = this._doc.getElementsByTagName('head')[0];
      head.appendChild(element);
      return element;
    }
    _setMetaElementAttributes(tag, el) {
      Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
      return el;
    }
    _parseSelector(tag) {
      const attr = tag.name ? 'name' : 'property';
      return `${attr}="${tag[attr]}"`;
    }
    _containsAttributes(tag, elem) {
      return Object.keys(tag).every(
          (key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
    }
    _getMetaKeyMap(prop) {
      return META_KEYS_MAP[prop] || prop;
    }
  };
  Meta.\u0275fac = function Meta_Factory(t) {
    return new (t || Meta)(\u0275\u0275inject(DOCUMENT2));
  };
  Meta.\u0275prov =
      \u0275\u0275defineInjectable({factory: createMeta, token: Meta, providedIn: 'root'});
  Meta.ctorParameters = () => [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]}];
  (function() {
    setClassMetadata(
        Meta, [{type: Injectable, args: [{providedIn: 'root', useFactory: createMeta, deps: []}]}],
        function() {
          return [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]}];
        },
        null);
  })();
  var META_KEYS_MAP = {httpEquiv: 'http-equiv'};
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function createTitle() {
    return new Title(\u0275\u0275inject(DOCUMENT2));
  }
  var Title = class {
    constructor(_doc) {
      this._doc = _doc;
    }
    getTitle() {
      return this._doc.title;
    }
    setTitle(newTitle) {
      this._doc.title = newTitle || '';
    }
  };
  Title.\u0275fac = function Title_Factory(t) {
    return new (t || Title)(\u0275\u0275inject(DOCUMENT2));
  };
  Title.\u0275prov =
      \u0275\u0275defineInjectable({factory: createTitle, token: Title, providedIn: 'root'});
  Title.ctorParameters = () => [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]}];
  (function() {
    setClassMetadata(
        Title,
        [{type: Injectable, args: [{providedIn: 'root', useFactory: createTitle, deps: []}]}],
        function() {
          return [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]}];
        },
        null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var win = typeof window !== 'undefined' && window || {};
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function unescapeHtml(text) {
    const unescapedText = {'&a;': '&', '&q;': '"', '&s;': '\'', '&l;': '<', '&g;': '>'};
    return text.replace(/&[^;]+;/g, (s) => unescapedText[s]);
  }
  var TransferState = class {
    constructor() {
      this.store = {};
      this.onSerializeCallbacks = {};
    }
    static init(initState) {
      const transferState = new TransferState();
      transferState.store = initState;
      return transferState;
    }
    get(key, defaultValue) {
      return this.store[key] !== void 0 ? this.store[key] : defaultValue;
    }
    set(key, value) {
      this.store[key] = value;
    }
    remove(key) {
      delete this.store[key];
    }
    hasKey(key) {
      return this.store.hasOwnProperty(key);
    }
    onSerialize(key, callback) {
      this.onSerializeCallbacks[key] = callback;
    }
    toJson() {
      for (const key in this.onSerializeCallbacks) {
        if (this.onSerializeCallbacks.hasOwnProperty(key)) {
          try {
            this.store[key] = this.onSerializeCallbacks[key]();
          } catch (e) {
            console.warn('Exception in onSerialize callback: ', e);
          }
        }
      }
      return JSON.stringify(this.store);
    }
  };
  TransferState.\u0275fac = function TransferState_Factory(t) {
    return new (t || TransferState)();
  };
  TransferState.\u0275prov =
      \u0275\u0275defineInjectable({token: TransferState, factory: TransferState.\u0275fac});
  (function() {
    setClassMetadata(TransferState, [{type: Injectable}], function() {
      return [];
    }, null);
  })();
  function initTransferState(doc, appId) {
    const script = doc.getElementById(appId + '-state');
    let initialState = {};
    if (script && script.textContent) {
      try {
        initialState = JSON.parse(unescapeHtml(script.textContent));
      } catch (e) {
        console.warn('Exception while restoring TransferState for app ' + appId, e);
      }
    }
    return TransferState.init(initialState);
  }
  var BrowserTransferStateModule = class {};
  BrowserTransferStateModule.\u0275mod =
      \u0275\u0275defineNgModule({type: BrowserTransferStateModule});
  BrowserTransferStateModule.\u0275inj = \u0275\u0275defineInjector({
    factory: function BrowserTransferStateModule_Factory(t) {
      return new (t || BrowserTransferStateModule)();
    },
    providers: [{provide: TransferState, useFactory: initTransferState, deps: [DOCUMENT2, APP_ID]}]
  });
  (function() {
    setClassMetadata(
        BrowserTransferStateModule, [{
          type: NgModule,
          args: [{
            providers:
                [{provide: TransferState, useFactory: initTransferState, deps: [DOCUMENT2, APP_ID]}]
          }]
        }],
        null, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var VERSION3 = new Version('11.0.9');
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */

  // external/npm/node_modules/@angular/common/fesm2015/http.js
  /**
   * @license Angular v11.0.9
   * (c) 2010-2020 Google LLC. https://angular.io/
   * License: MIT
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var HttpHandler = class {};
  var HttpBackend = class {};
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var HttpHeaders = class {
    constructor(headers) {
      this.normalizedNames = new Map();
      this.lazyUpdate = null;
      if (!headers) {
        this.headers = new Map();
      } else if (typeof headers === 'string') {
        this.lazyInit = () => {
          this.headers = new Map();
          headers.split('\n').forEach((line) => {
            const index = line.indexOf(':');
            if (index > 0) {
              const name = line.slice(0, index);
              const key = name.toLowerCase();
              const value = line.slice(index + 1).trim();
              this.maybeSetNormalizedName(name, key);
              if (this.headers.has(key)) {
                this.headers.get(key).push(value);
              } else {
                this.headers.set(key, [value]);
              }
            }
          });
        };
      } else {
        this.lazyInit = () => {
          this.headers = new Map();
          Object.keys(headers).forEach((name) => {
            let values = headers[name];
            const key = name.toLowerCase();
            if (typeof values === 'string') {
              values = [values];
            }
            if (values.length > 0) {
              this.headers.set(key, values);
              this.maybeSetNormalizedName(name, key);
            }
          });
        };
      }
    }
    has(name) {
      this.init();
      return this.headers.has(name.toLowerCase());
    }
    get(name) {
      this.init();
      const values = this.headers.get(name.toLowerCase());
      return values && values.length > 0 ? values[0] : null;
    }
    keys() {
      this.init();
      return Array.from(this.normalizedNames.values());
    }
    getAll(name) {
      this.init();
      return this.headers.get(name.toLowerCase()) || null;
    }
    append(name, value) {
      return this.clone({name, value, op: 'a'});
    }
    set(name, value) {
      return this.clone({name, value, op: 's'});
    }
    delete(name, value) {
      return this.clone({name, value, op: 'd'});
    }
    maybeSetNormalizedName(name, lcName) {
      if (!this.normalizedNames.has(lcName)) {
        this.normalizedNames.set(lcName, name);
      }
    }
    init() {
      if (!!this.lazyInit) {
        if (this.lazyInit instanceof HttpHeaders) {
          this.copyFrom(this.lazyInit);
        } else {
          this.lazyInit();
        }
        this.lazyInit = null;
        if (!!this.lazyUpdate) {
          this.lazyUpdate.forEach((update) => this.applyUpdate(update));
          this.lazyUpdate = null;
        }
      }
    }
    copyFrom(other) {
      other.init();
      Array.from(other.headers.keys()).forEach((key) => {
        this.headers.set(key, other.headers.get(key));
        this.normalizedNames.set(key, other.normalizedNames.get(key));
      });
    }
    clone(update) {
      const clone = new HttpHeaders();
      clone.lazyInit =
          !!this.lazyInit && this.lazyInit instanceof HttpHeaders ? this.lazyInit : this;
      clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
      return clone;
    }
    applyUpdate(update) {
      const key = update.name.toLowerCase();
      switch (update.op) {
        case 'a':
        case 's':
          let value = update.value;
          if (typeof value === 'string') {
            value = [value];
          }
          if (value.length === 0) {
            return;
          }
          this.maybeSetNormalizedName(update.name, key);
          const base = (update.op === 'a' ? this.headers.get(key) : void 0) || [];
          base.push(...value);
          this.headers.set(key, base);
          break;
        case 'd':
          const toDelete = update.value;
          if (!toDelete) {
            this.headers.delete(key);
            this.normalizedNames.delete(key);
          } else {
            let existing = this.headers.get(key);
            if (!existing) {
              return;
            }
            existing = existing.filter((value2) => toDelete.indexOf(value2) === -1);
            if (existing.length === 0) {
              this.headers.delete(key);
              this.normalizedNames.delete(key);
            } else {
              this.headers.set(key, existing);
            }
          }
          break;
      }
    }
    forEach(fn) {
      this.init();
      Array.from(this.normalizedNames.keys())
          .forEach((key) => fn(this.normalizedNames.get(key), this.headers.get(key)));
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var HttpUrlEncodingCodec = class {
    encodeKey(key) {
      return standardEncoding(key);
    }
    encodeValue(value) {
      return standardEncoding(value);
    }
    decodeKey(key) {
      return decodeURIComponent(key);
    }
    decodeValue(value) {
      return decodeURIComponent(value);
    }
  };
  function paramParser(rawParams, codec) {
    const map2 = new Map();
    if (rawParams.length > 0) {
      const params = rawParams.split('&');
      params.forEach((param) => {
        const eqIdx = param.indexOf('=');
        const [key, val] = eqIdx == -1 ?
            [codec.decodeKey(param), ''] :
            [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];
        const list = map2.get(key) || [];
        list.push(val);
        map2.set(key, list);
      });
    }
    return map2;
  }
  function standardEncoding(v) {
    return encodeURIComponent(v)
        .replace(/%40/gi, '@')
        .replace(/%3A/gi, ':')
        .replace(/%24/gi, '$')
        .replace(/%2C/gi, ',')
        .replace(/%3B/gi, ';')
        .replace(/%2B/gi, '+')
        .replace(/%3D/gi, '=')
        .replace(/%3F/gi, '?')
        .replace(/%2F/gi, '/');
  }
  var HttpParams = class {
    constructor(options = {}) {
      this.updates = null;
      this.cloneFrom = null;
      this.encoder = options.encoder || new HttpUrlEncodingCodec();
      if (!!options.fromString) {
        if (!!options.fromObject) {
          throw new Error(`Cannot specify both fromString and fromObject.`);
        }
        this.map = paramParser(options.fromString, this.encoder);
      } else if (!!options.fromObject) {
        this.map = new Map();
        Object.keys(options.fromObject).forEach((key) => {
          const value = options.fromObject[key];
          this.map.set(key, Array.isArray(value) ? value : [value]);
        });
      } else {
        this.map = null;
      }
    }
    has(param) {
      this.init();
      return this.map.has(param);
    }
    get(param) {
      this.init();
      const res = this.map.get(param);
      return !!res ? res[0] : null;
    }
    getAll(param) {
      this.init();
      return this.map.get(param) || null;
    }
    keys() {
      this.init();
      return Array.from(this.map.keys());
    }
    append(param, value) {
      return this.clone({param, value, op: 'a'});
    }
    set(param, value) {
      return this.clone({param, value, op: 's'});
    }
    delete(param, value) {
      return this.clone({param, value, op: 'd'});
    }
    toString() {
      this.init();
      return this.keys()
          .map((key) => {
            const eKey = this.encoder.encodeKey(key);
            return this.map.get(key)
                .map((value) => eKey + '=' + this.encoder.encodeValue(value))
                .join('&');
          })
          .filter((param) => param !== '')
          .join('&');
    }
    clone(update) {
      const clone = new HttpParams({encoder: this.encoder});
      clone.cloneFrom = this.cloneFrom || this;
      clone.updates = (this.updates || []).concat([update]);
      return clone;
    }
    init() {
      if (this.map === null) {
        this.map = new Map();
      }
      if (this.cloneFrom !== null) {
        this.cloneFrom.init();
        this.cloneFrom.keys().forEach((key) => this.map.set(key, this.cloneFrom.map.get(key)));
        this.updates.forEach((update) => {
          switch (update.op) {
            case 'a':
            case 's':
              const base = (update.op === 'a' ? this.map.get(update.param) : void 0) || [];
              base.push(update.value);
              this.map.set(update.param, base);
              break;
            case 'd':
              if (update.value !== void 0) {
                let base2 = this.map.get(update.param) || [];
                const idx = base2.indexOf(update.value);
                if (idx !== -1) {
                  base2.splice(idx, 1);
                }
                if (base2.length > 0) {
                  this.map.set(update.param, base2);
                } else {
                  this.map.delete(update.param);
                }
              } else {
                this.map.delete(update.param);
                break;
              }
          }
        });
        this.cloneFrom = this.updates = null;
      }
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function mightHaveBody(method) {
    switch (method) {
      case 'DELETE':
      case 'GET':
      case 'HEAD':
      case 'OPTIONS':
      case 'JSONP':
        return false;
      default:
        return true;
    }
  }
  function isArrayBuffer(value) {
    return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;
  }
  function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
  }
  function isFormData(value) {
    return typeof FormData !== 'undefined' && value instanceof FormData;
  }
  var HttpRequest = class {
    constructor(method, url, third, fourth) {
      this.url = url;
      this.body = null;
      this.reportProgress = false;
      this.withCredentials = false;
      this.responseType = 'json';
      this.method = method.toUpperCase();
      let options;
      if (mightHaveBody(this.method) || !!fourth) {
        this.body = third !== void 0 ? third : null;
        options = fourth;
      } else {
        options = third;
      }
      if (options) {
        this.reportProgress = !!options.reportProgress;
        this.withCredentials = !!options.withCredentials;
        if (!!options.responseType) {
          this.responseType = options.responseType;
        }
        if (!!options.headers) {
          this.headers = options.headers;
        }
        if (!!options.params) {
          this.params = options.params;
        }
      }
      if (!this.headers) {
        this.headers = new HttpHeaders();
      }
      if (!this.params) {
        this.params = new HttpParams();
        this.urlWithParams = url;
      } else {
        const params = this.params.toString();
        if (params.length === 0) {
          this.urlWithParams = url;
        } else {
          const qIdx = url.indexOf('?');
          const sep = qIdx === -1 ? '?' : qIdx < url.length - 1 ? '&' : '';
          this.urlWithParams = url + sep + params;
        }
      }
    }
    serializeBody() {
      if (this.body === null) {
        return null;
      }
      if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||
          typeof this.body === 'string') {
        return this.body;
      }
      if (this.body instanceof HttpParams) {
        return this.body.toString();
      }
      if (typeof this.body === 'object' || typeof this.body === 'boolean' ||
          Array.isArray(this.body)) {
        return JSON.stringify(this.body);
      }
      return this.body.toString();
    }
    detectContentTypeHeader() {
      if (this.body === null) {
        return null;
      }
      if (isFormData(this.body)) {
        return null;
      }
      if (isBlob(this.body)) {
        return this.body.type || null;
      }
      if (isArrayBuffer(this.body)) {
        return null;
      }
      if (typeof this.body === 'string') {
        return 'text/plain';
      }
      if (this.body instanceof HttpParams) {
        return 'application/x-www-form-urlencoded;charset=UTF-8';
      }
      if (typeof this.body === 'object' || typeof this.body === 'number' ||
          Array.isArray(this.body)) {
        return 'application/json';
      }
      return null;
    }
    clone(update = {}) {
      const method = update.method || this.method;
      const url = update.url || this.url;
      const responseType = update.responseType || this.responseType;
      const body = update.body !== void 0 ? update.body : this.body;
      const withCredentials =
          update.withCredentials !== void 0 ? update.withCredentials : this.withCredentials;
      const reportProgress =
          update.reportProgress !== void 0 ? update.reportProgress : this.reportProgress;
      let headers = update.headers || this.headers;
      let params = update.params || this.params;
      if (update.setHeaders !== void 0) {
        headers =
            Object.keys(update.setHeaders)
                .reduce((headers2, name) => headers2.set(name, update.setHeaders[name]), headers);
      }
      if (update.setParams) {
        params =
            Object.keys(update.setParams)
                .reduce((params2, param) => params2.set(param, update.setParams[param]), params);
      }
      return new HttpRequest(
          method, url, body, {params, headers, reportProgress, responseType, withCredentials});
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var HttpEventType;
  (function(HttpEventType2) {
    HttpEventType2[HttpEventType2['Sent'] = 0] = 'Sent';
    HttpEventType2[HttpEventType2['UploadProgress'] = 1] = 'UploadProgress';
    HttpEventType2[HttpEventType2['ResponseHeader'] = 2] = 'ResponseHeader';
    HttpEventType2[HttpEventType2['DownloadProgress'] = 3] = 'DownloadProgress';
    HttpEventType2[HttpEventType2['Response'] = 4] = 'Response';
    HttpEventType2[HttpEventType2['User'] = 5] = 'User';
  })(HttpEventType || (HttpEventType = {}));
  var HttpResponseBase = class {
    constructor(init, defaultStatus = 200, defaultStatusText = 'OK') {
      this.headers = init.headers || new HttpHeaders();
      this.status = init.status !== void 0 ? init.status : defaultStatus;
      this.statusText = init.statusText || defaultStatusText;
      this.url = init.url || null;
      this.ok = this.status >= 200 && this.status < 300;
    }
  };
  var HttpHeaderResponse = class extends HttpResponseBase {
    constructor(init = {}) {
      super(init);
      this.type = HttpEventType.ResponseHeader;
    }
    clone(update = {}) {
      return new HttpHeaderResponse({
        headers: update.headers || this.headers,
        status: update.status !== void 0 ? update.status : this.status,
        statusText: update.statusText || this.statusText,
        url: update.url || this.url || void 0
      });
    }
  };
  var HttpResponse = class extends HttpResponseBase {
    constructor(init = {}) {
      super(init);
      this.type = HttpEventType.Response;
      this.body = init.body !== void 0 ? init.body : null;
    }
    clone(update = {}) {
      return new HttpResponse({
        body: update.body !== void 0 ? update.body : this.body,
        headers: update.headers || this.headers,
        status: update.status !== void 0 ? update.status : this.status,
        statusText: update.statusText || this.statusText,
        url: update.url || this.url || void 0
      });
    }
  };
  var HttpErrorResponse = class extends HttpResponseBase {
    constructor(init) {
      super(init, 0, 'Unknown Error');
      this.name = 'HttpErrorResponse';
      this.ok = false;
      if (this.status >= 200 && this.status < 300) {
        this.message = `Http failure during parsing for ${init.url || '(unknown url)'}`;
      } else {
        this.message = `Http failure response for ${init.url || '(unknown url)'}: ${init.status} ${
            init.statusText}`;
      }
      this.error = init.error || null;
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function addBody(options, body) {
    return {
      body,
      headers: options.headers,
      observe: options.observe,
      params: options.params,
      reportProgress: options.reportProgress,
      responseType: options.responseType,
      withCredentials: options.withCredentials
    };
  }
  var HttpClient = class {
    constructor(handler) {
      this.handler = handler;
    }
    request(first2, url, options = {}) {
      let req;
      if (first2 instanceof HttpRequest) {
        req = first2;
      } else {
        let headers = void 0;
        if (options.headers instanceof HttpHeaders) {
          headers = options.headers;
        } else {
          headers = new HttpHeaders(options.headers);
        }
        let params = void 0;
        if (!!options.params) {
          if (options.params instanceof HttpParams) {
            params = options.params;
          } else {
            params = new HttpParams({fromObject: options.params});
          }
        }
        req = new HttpRequest(first2, url, options.body !== void 0 ? options.body : null, {
          headers,
          params,
          reportProgress: options.reportProgress,
          responseType: options.responseType || 'json',
          withCredentials: options.withCredentials
        });
      }
      const events$ = of(req).pipe(concatMap((req2) => this.handler.handle(req2)));
      if (first2 instanceof HttpRequest || options.observe === 'events') {
        return events$;
      }
      const res$ = events$.pipe(filter((event) => event instanceof HttpResponse));
      switch (options.observe || 'body') {
        case 'body':
          switch (req.responseType) {
            case 'arraybuffer':
              return res$.pipe(map((res) => {
                if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                  throw new Error('Response is not an ArrayBuffer.');
                }
                return res.body;
              }));
            case 'blob':
              return res$.pipe(map((res) => {
                if (res.body !== null && !(res.body instanceof Blob)) {
                  throw new Error('Response is not a Blob.');
                }
                return res.body;
              }));
            case 'text':
              return res$.pipe(map((res) => {
                if (res.body !== null && typeof res.body !== 'string') {
                  throw new Error('Response is not a string.');
                }
                return res.body;
              }));
            case 'json':
            default:
              return res$.pipe(map((res) => res.body));
          }
        case 'response':
          return res$;
        default:
          throw new Error(`Unreachable: unhandled observe type ${options.observe}}`);
      }
    }
    delete(url, options = {}) {
      return this.request('DELETE', url, options);
    }
    get(url, options = {}) {
      return this.request('GET', url, options);
    }
    head(url, options = {}) {
      return this.request('HEAD', url, options);
    }
    jsonp(url, callbackParam) {
      return this.request('JSONP', url, {
        params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),
        observe: 'body',
        responseType: 'json'
      });
    }
    options(url, options = {}) {
      return this.request('OPTIONS', url, options);
    }
    patch(url, body, options = {}) {
      return this.request('PATCH', url, addBody(options, body));
    }
    post(url, body, options = {}) {
      return this.request('POST', url, addBody(options, body));
    }
    put(url, body, options = {}) {
      return this.request('PUT', url, addBody(options, body));
    }
  };
  HttpClient.\u0275fac = function HttpClient_Factory(t) {
    return new (t || HttpClient)(\u0275\u0275inject(HttpHandler));
  };
  HttpClient.\u0275prov =
      \u0275\u0275defineInjectable({token: HttpClient, factory: HttpClient.\u0275fac});
  HttpClient.ctorParameters = () => [{type: HttpHandler}];
  (function() {
    setClassMetadata(HttpClient, [{type: Injectable}], function() {
      return [{type: HttpHandler}];
    }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var HttpInterceptorHandler = class {
    constructor(next, interceptor) {
      this.next = next;
      this.interceptor = interceptor;
    }
    handle(req) {
      return this.interceptor.intercept(req, this.next);
    }
  };
  var HTTP_INTERCEPTORS = new InjectionToken('HTTP_INTERCEPTORS');
  var NoopInterceptor = class {
    intercept(req, next) {
      return next.handle(req);
    }
  };
  NoopInterceptor.\u0275fac = function NoopInterceptor_Factory(t) {
    return new (t || NoopInterceptor)();
  };
  NoopInterceptor.\u0275prov =
      \u0275\u0275defineInjectable({token: NoopInterceptor, factory: NoopInterceptor.\u0275fac});
  (function() {
    setClassMetadata(NoopInterceptor, [{type: Injectable}], null, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var nextRequestId = 0;
  var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
  var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';
  var JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';
  var JsonpCallbackContext = class {};
  var JsonpClientBackend = class {
    constructor(callbackMap, document2) {
      this.callbackMap = callbackMap;
      this.document = document2;
      this.resolvedPromise = Promise.resolve();
    }
    nextCallback() {
      return `ng_jsonp_callback_${nextRequestId++}`;
    }
    handle(req) {
      if (req.method !== 'JSONP') {
        throw new Error(JSONP_ERR_WRONG_METHOD);
      } else if (req.responseType !== 'json') {
        throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);
      }
      return new Observable((observer) => {
        const callback = this.nextCallback();
        const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);
        const node = this.document.createElement('script');
        node.src = url;
        let body = null;
        let finished = false;
        let cancelled = false;
        this.callbackMap[callback] = (data) => {
          delete this.callbackMap[callback];
          if (cancelled) {
            return;
          }
          body = data;
          finished = true;
        };
        const cleanup = () => {
          if (node.parentNode) {
            node.parentNode.removeChild(node);
          }
          delete this.callbackMap[callback];
        };
        const onLoad = (event) => {
          if (cancelled) {
            return;
          }
          this.resolvedPromise.then(() => {
            cleanup();
            if (!finished) {
              observer.error(new HttpErrorResponse({
                url,
                status: 0,
                statusText: 'JSONP Error',
                error: new Error(JSONP_ERR_NO_CALLBACK)
              }));
              return;
            }
            observer.next(new HttpResponse({body, status: 200, statusText: 'OK', url}));
            observer.complete();
          });
        };
        const onError = (error) => {
          if (cancelled) {
            return;
          }
          cleanup();
          observer.error(new HttpErrorResponse({error, status: 0, statusText: 'JSONP Error', url}));
        };
        node.addEventListener('load', onLoad);
        node.addEventListener('error', onError);
        this.document.body.appendChild(node);
        observer.next({type: HttpEventType.Sent});
        return () => {
          cancelled = true;
          node.removeEventListener('load', onLoad);
          node.removeEventListener('error', onError);
          cleanup();
        };
      });
    }
  };
  JsonpClientBackend.\u0275fac = function JsonpClientBackend_Factory(t) {
    return new (t || JsonpClientBackend)(
        \u0275\u0275inject(JsonpCallbackContext), \u0275\u0275inject(DOCUMENT2));
  };
  JsonpClientBackend.\u0275prov = \u0275\u0275defineInjectable(
      {token: JsonpClientBackend, factory: JsonpClientBackend.\u0275fac});
  JsonpClientBackend.ctorParameters = () => [{type: JsonpCallbackContext}, {
    type: void 0,
    decorators: [{type: Inject, args: [DOCUMENT2]}]
  }];
  (function() {
    setClassMetadata(JsonpClientBackend, [{type: Injectable}], function() {
      return [
        {type: JsonpCallbackContext},
        {type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]}
      ];
    }, null);
  })();
  var JsonpInterceptor = class {
    constructor(jsonp) {
      this.jsonp = jsonp;
    }
    intercept(req, next) {
      if (req.method === 'JSONP') {
        return this.jsonp.handle(req);
      }
      return next.handle(req);
    }
  };
  JsonpInterceptor.\u0275fac = function JsonpInterceptor_Factory(t) {
    return new (t || JsonpInterceptor)(\u0275\u0275inject(JsonpClientBackend));
  };
  JsonpInterceptor.\u0275prov =
      \u0275\u0275defineInjectable({token: JsonpInterceptor, factory: JsonpInterceptor.\u0275fac});
  JsonpInterceptor.ctorParameters = () => [{type: JsonpClientBackend}];
  (function() {
    setClassMetadata(JsonpInterceptor, [{type: Injectable}], function() {
      return [{type: JsonpClientBackend}];
    }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var XSSI_PREFIX = /^\)\]\}',?\n/;
  function getResponseUrl(xhr) {
    if ('responseURL' in xhr && xhr.responseURL) {
      return xhr.responseURL;
    }
    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
      return xhr.getResponseHeader('X-Request-URL');
    }
    return null;
  }
  var XhrFactory = class {};
  var BrowserXhr = class {
    constructor() {}
    build() {
      return new XMLHttpRequest();
    }
  };
  BrowserXhr.\u0275fac = function BrowserXhr_Factory(t) {
    return new (t || BrowserXhr)();
  };
  BrowserXhr.\u0275prov =
      \u0275\u0275defineInjectable({token: BrowserXhr, factory: BrowserXhr.\u0275fac});
  BrowserXhr.ctorParameters = () => [];
  (function() {
    setClassMetadata(BrowserXhr, [{type: Injectable}], function() {
      return [];
    }, null);
  })();
  var HttpXhrBackend = class {
    constructor(xhrFactory) {
      this.xhrFactory = xhrFactory;
    }
    handle(req) {
      if (req.method === 'JSONP') {
        throw new Error(
            `Attempted to construct Jsonp request without HttpClientJsonpModule installed.`);
      }
      return new Observable((observer) => {
        const xhr = this.xhrFactory.build();
        xhr.open(req.method, req.urlWithParams);
        if (!!req.withCredentials) {
          xhr.withCredentials = true;
        }
        req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(',')));
        if (!req.headers.has('Accept')) {
          xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');
        }
        if (!req.headers.has('Content-Type')) {
          const detectedType = req.detectContentTypeHeader();
          if (detectedType !== null) {
            xhr.setRequestHeader('Content-Type', detectedType);
          }
        }
        if (req.responseType) {
          const responseType = req.responseType.toLowerCase();
          xhr.responseType = responseType !== 'json' ? responseType : 'text';
        }
        const reqBody = req.serializeBody();
        let headerResponse = null;
        const partialFromXhr = () => {
          if (headerResponse !== null) {
            return headerResponse;
          }
          const status = xhr.status === 1223 ? 204 : xhr.status;
          const statusText = xhr.statusText || 'OK';
          const headers = new HttpHeaders(xhr.getAllResponseHeaders());
          const url = getResponseUrl(xhr) || req.url;
          headerResponse = new HttpHeaderResponse({headers, status, statusText, url});
          return headerResponse;
        };
        const onLoad = () => {
          let {headers, status, statusText, url} = partialFromXhr();
          let body = null;
          if (status !== 204) {
            body = typeof xhr.response === 'undefined' ? xhr.responseText : xhr.response;
          }
          if (status === 0) {
            status = !!body ? 200 : 0;
          }
          let ok = status >= 200 && status < 300;
          if (req.responseType === 'json' && typeof body === 'string') {
            const originalBody = body;
            body = body.replace(XSSI_PREFIX, '');
            try {
              body = body !== '' ? JSON.parse(body) : null;
            } catch (error) {
              body = originalBody;
              if (ok) {
                ok = false;
                body = {error, text: body};
              }
            }
          }
          if (ok) {
            observer.next(
                new HttpResponse({body, headers, status, statusText, url: url || void 0}));
            observer.complete();
          } else {
            observer.error(new HttpErrorResponse(
                {error: body, headers, status, statusText, url: url || void 0}));
          }
        };
        const onError = (error) => {
          const {url} = partialFromXhr();
          const res = new HttpErrorResponse({
            error,
            status: xhr.status || 0,
            statusText: xhr.statusText || 'Unknown Error',
            url: url || void 0
          });
          observer.error(res);
        };
        let sentHeaders = false;
        const onDownProgress = (event) => {
          if (!sentHeaders) {
            observer.next(partialFromXhr());
            sentHeaders = true;
          }
          let progressEvent = {type: HttpEventType.DownloadProgress, loaded: event.loaded};
          if (event.lengthComputable) {
            progressEvent.total = event.total;
          }
          if (req.responseType === 'text' && !!xhr.responseText) {
            progressEvent.partialText = xhr.responseText;
          }
          observer.next(progressEvent);
        };
        const onUpProgress = (event) => {
          let progress = {type: HttpEventType.UploadProgress, loaded: event.loaded};
          if (event.lengthComputable) {
            progress.total = event.total;
          }
          observer.next(progress);
        };
        xhr.addEventListener('load', onLoad);
        xhr.addEventListener('error', onError);
        if (req.reportProgress) {
          xhr.addEventListener('progress', onDownProgress);
          if (reqBody !== null && xhr.upload) {
            xhr.upload.addEventListener('progress', onUpProgress);
          }
        }
        xhr.send(reqBody);
        observer.next({type: HttpEventType.Sent});
        return () => {
          xhr.removeEventListener('error', onError);
          xhr.removeEventListener('load', onLoad);
          if (req.reportProgress) {
            xhr.removeEventListener('progress', onDownProgress);
            if (reqBody !== null && xhr.upload) {
              xhr.upload.removeEventListener('progress', onUpProgress);
            }
          }
          if (xhr.readyState !== xhr.DONE) {
            xhr.abort();
          }
        };
      });
    }
  };
  HttpXhrBackend.\u0275fac = function HttpXhrBackend_Factory(t) {
    return new (t || HttpXhrBackend)(\u0275\u0275inject(XhrFactory));
  };
  HttpXhrBackend.\u0275prov =
      \u0275\u0275defineInjectable({token: HttpXhrBackend, factory: HttpXhrBackend.\u0275fac});
  HttpXhrBackend.ctorParameters = () => [{type: XhrFactory}];
  (function() {
    setClassMetadata(HttpXhrBackend, [{type: Injectable}], function() {
      return [{type: XhrFactory}];
    }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var XSRF_COOKIE_NAME = new InjectionToken('XSRF_COOKIE_NAME');
  var XSRF_HEADER_NAME = new InjectionToken('XSRF_HEADER_NAME');
  var HttpXsrfTokenExtractor = class {};
  var HttpXsrfCookieExtractor = class {
    constructor(doc, platform, cookieName) {
      this.doc = doc;
      this.platform = platform;
      this.cookieName = cookieName;
      this.lastCookieString = '';
      this.lastToken = null;
      this.parseCount = 0;
    }
    getToken() {
      if (this.platform === 'server') {
        return null;
      }
      const cookieString = this.doc.cookie || '';
      if (cookieString !== this.lastCookieString) {
        this.parseCount++;
        this.lastToken = parseCookieValue(cookieString, this.cookieName);
        this.lastCookieString = cookieString;
      }
      return this.lastToken;
    }
  };
  HttpXsrfCookieExtractor.\u0275fac = function HttpXsrfCookieExtractor_Factory(t) {
    return new (t || HttpXsrfCookieExtractor)(
        \u0275\u0275inject(DOCUMENT2), \u0275\u0275inject(PLATFORM_ID),
        \u0275\u0275inject(XSRF_COOKIE_NAME));
  };
  HttpXsrfCookieExtractor.\u0275prov = \u0275\u0275defineInjectable(
      {token: HttpXsrfCookieExtractor, factory: HttpXsrfCookieExtractor.\u0275fac});
  HttpXsrfCookieExtractor.ctorParameters = () =>
      [{type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]},
       {type: String, decorators: [{type: Inject, args: [PLATFORM_ID]}]},
       {type: String, decorators: [{type: Inject, args: [XSRF_COOKIE_NAME]}]}];
  (function() {
    setClassMetadata(HttpXsrfCookieExtractor, [{type: Injectable}], function() {
      return [
        {type: void 0, decorators: [{type: Inject, args: [DOCUMENT2]}]},
        {type: String, decorators: [{type: Inject, args: [PLATFORM_ID]}]},
        {type: String, decorators: [{type: Inject, args: [XSRF_COOKIE_NAME]}]}
      ];
    }, null);
  })();
  var HttpXsrfInterceptor = class {
    constructor(tokenService, headerName) {
      this.tokenService = tokenService;
      this.headerName = headerName;
    }
    intercept(req, next) {
      const lcUrl = req.url.toLowerCase();
      if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') ||
          lcUrl.startsWith('https://')) {
        return next.handle(req);
      }
      const token = this.tokenService.getToken();
      if (token !== null && !req.headers.has(this.headerName)) {
        req = req.clone({headers: req.headers.set(this.headerName, token)});
      }
      return next.handle(req);
    }
  };
  HttpXsrfInterceptor.\u0275fac = function HttpXsrfInterceptor_Factory(t) {
    return new (t || HttpXsrfInterceptor)(
        \u0275\u0275inject(HttpXsrfTokenExtractor), \u0275\u0275inject(XSRF_HEADER_NAME));
  };
  HttpXsrfInterceptor.\u0275prov = \u0275\u0275defineInjectable(
      {token: HttpXsrfInterceptor, factory: HttpXsrfInterceptor.\u0275fac});
  HttpXsrfInterceptor.ctorParameters = () => [{type: HttpXsrfTokenExtractor}, {
    type: String,
    decorators: [{type: Inject, args: [XSRF_HEADER_NAME]}]
  }];
  (function() {
    setClassMetadata(HttpXsrfInterceptor, [{type: Injectable}], function() {
      return [
        {type: HttpXsrfTokenExtractor},
        {type: String, decorators: [{type: Inject, args: [XSRF_HEADER_NAME]}]}
      ];
    }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var HttpInterceptingHandler = class {
    constructor(backend, injector) {
      this.backend = backend;
      this.injector = injector;
      this.chain = null;
    }
    handle(req) {
      if (this.chain === null) {
        const interceptors = this.injector.get(HTTP_INTERCEPTORS, []);
        this.chain = interceptors.reduceRight(
            (next, interceptor) => new HttpInterceptorHandler(next, interceptor), this.backend);
      }
      return this.chain.handle(req);
    }
  };
  HttpInterceptingHandler.\u0275fac = function HttpInterceptingHandler_Factory(t) {
    return new (t || HttpInterceptingHandler)(
        \u0275\u0275inject(HttpBackend), \u0275\u0275inject(Injector));
  };
  HttpInterceptingHandler.\u0275prov = \u0275\u0275defineInjectable(
      {token: HttpInterceptingHandler, factory: HttpInterceptingHandler.\u0275fac});
  HttpInterceptingHandler.ctorParameters = () => [{type: HttpBackend}, {type: Injector}];
  (function() {
    setClassMetadata(HttpInterceptingHandler, [{type: Injectable}], function() {
      return [{type: HttpBackend}, {type: Injector}];
    }, null);
  })();
  function jsonpCallbackContext() {
    if (typeof window === 'object') {
      return window;
    }
    return {};
  }
  var HttpClientXsrfModule = class {
    static disable() {
      return {
        ngModule: HttpClientXsrfModule,
        providers: [{provide: HttpXsrfInterceptor, useClass: NoopInterceptor}]
      };
    }
    static withOptions(options = {}) {
      return {
        ngModule: HttpClientXsrfModule,
        providers: [
          options.cookieName ? {provide: XSRF_COOKIE_NAME, useValue: options.cookieName} : [],
          options.headerName ? {provide: XSRF_HEADER_NAME, useValue: options.headerName} : []
        ]
      };
    }
  };
  HttpClientXsrfModule.\u0275mod = \u0275\u0275defineNgModule({type: HttpClientXsrfModule});
  HttpClientXsrfModule.\u0275inj = \u0275\u0275defineInjector({
    factory: function HttpClientXsrfModule_Factory(t) {
      return new (t || HttpClientXsrfModule)();
    },
    providers: [
      HttpXsrfInterceptor,
      {provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true},
      {provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor},
      {provide: XSRF_COOKIE_NAME, useValue: 'XSRF-TOKEN'},
      {provide: XSRF_HEADER_NAME, useValue: 'X-XSRF-TOKEN'}
    ]
  });
  (function() {
    setClassMetadata(
        HttpClientXsrfModule, [{
          type: NgModule,
          args: [{
            providers: [
              HttpXsrfInterceptor,
              {provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true},
              {provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor},
              {provide: XSRF_COOKIE_NAME, useValue: 'XSRF-TOKEN'},
              {provide: XSRF_HEADER_NAME, useValue: 'X-XSRF-TOKEN'}
            ]
          }]
        }],
        null, null);
  })();
  var HttpClientModule = class {};
  HttpClientModule.\u0275mod = \u0275\u0275defineNgModule({type: HttpClientModule});
  HttpClientModule.\u0275inj = \u0275\u0275defineInjector({
    factory: function HttpClientModule_Factory(t) {
      return new (t || HttpClientModule)();
    },
    providers: [
      HttpClient, {provide: HttpHandler, useClass: HttpInterceptingHandler}, HttpXhrBackend,
      {provide: HttpBackend, useExisting: HttpXhrBackend}, BrowserXhr,
      {provide: XhrFactory, useExisting: BrowserXhr}
    ],
    imports:
        [[HttpClientXsrfModule.withOptions({cookieName: 'XSRF-TOKEN', headerName: 'X-XSRF-TOKEN'})]]
  });
  (function() {
    (typeof ngJitMode === 'undefined' || ngJitMode) &&
        \u0275\u0275setNgModuleScope(HttpClientModule, {imports: [HttpClientXsrfModule]});
  })();
  (function() {
    setClassMetadata(
        HttpClientModule, [{
          type: NgModule,
          args: [{
            imports: [HttpClientXsrfModule.withOptions(
                {cookieName: 'XSRF-TOKEN', headerName: 'X-XSRF-TOKEN'})],
            providers: [
              HttpClient, {provide: HttpHandler, useClass: HttpInterceptingHandler}, HttpXhrBackend,
              {provide: HttpBackend, useExisting: HttpXhrBackend}, BrowserXhr,
              {provide: XhrFactory, useExisting: BrowserXhr}
            ]
          }]
        }],
        null, null);
  })();
  var HttpClientJsonpModule = class {};
  HttpClientJsonpModule.\u0275mod = \u0275\u0275defineNgModule({type: HttpClientJsonpModule});
  HttpClientJsonpModule.\u0275inj = \u0275\u0275defineInjector({
    factory: function HttpClientJsonpModule_Factory(t) {
      return new (t || HttpClientJsonpModule)();
    },
    providers: [
      JsonpClientBackend, {provide: JsonpCallbackContext, useFactory: jsonpCallbackContext},
      {provide: HTTP_INTERCEPTORS, useClass: JsonpInterceptor, multi: true}
    ]
  });
  (function() {
    setClassMetadata(
        HttpClientJsonpModule, [{
          type: NgModule,
          args: [{
            providers: [
              JsonpClientBackend, {provide: JsonpCallbackContext, useFactory: jsonpCallbackContext},
              {provide: HTTP_INTERCEPTORS, useClass: JsonpInterceptor, multi: true}
            ]
          }]
        }],
        null, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */

  // external/npm/node_modules/ngx-markdown/fesm2015/ngx-markdown.js
  var import_marked = __toModule(require_marked());
  var import_marked2 = __toModule(require_marked());
  var _c0 = ['*'];
  var LanguagePipe = class {
    transform(value, language) {
      if (typeof value !== 'string') {
        console.error(`LanguagePipe has been invoked with an invalid value type [${value}]`);
        return value;
      }
      if (typeof language !== 'string') {
        console.error(`LanguagePipe has been invoked with an invalid parameter [${language}]`);
        return value;
      }
      return '```' + language + '\n' + value + '\n```';
    }
  };
  LanguagePipe.\u0275fac = function LanguagePipe_Factory(t) {
    return new (t || LanguagePipe)();
  };
  LanguagePipe.\u0275pipe =
      \u0275\u0275definePipe({name: 'language', type: LanguagePipe, pure: true});
  (function() {
    setClassMetadata(LanguagePipe, [{type: Pipe, args: [{name: 'language'}]}], null, null);
  })();
  var MarkedOptions = class {};
  var errorJoyPixelsNotLoaded =
      '[ngx-markdown] When using the `emoji` attribute you *have to* include Emoji-Toolkit files to `angular.json` or use imports. See README for more information';
  var errorKatexNotLoaded =
      '[ngx-markdown] When using the `katex` attribute you *have to* include KaTeX files to `angular.json` or use imports. See README for more information';
  var errorSrcWithoutHttpClient =
      '[ngx-markdown] When using the `src` attribute you *have to* pass the `HttpClient` as a parameter of the `forRoot` method. See README for more information';
  var SECURITY_CONTEXT = new InjectionToken('SECURITY_CONTEXT');
  var MarkdownService = class {
    constructor(platform, securityContext, http, options, sanitizer) {
      this.platform = platform;
      this.securityContext = securityContext;
      this.http = http;
      this.sanitizer = sanitizer;
      this.initialMarkedOptions = {renderer: new import_marked.Renderer()};
      this.options = options;
    }
    get options() {
      return this._options;
    }
    set options(value) {
      this._options = Object.assign(Object.assign({}, this.initialMarkedOptions), value);
    }
    get renderer() {
      return this.options.renderer;
    }
    set renderer(value) {
      this.options.renderer = value;
    }
    compile(markdown, decodeHtml = false, emojify = false, markedOptions = this.options) {
      const trimmed = this.trimIndentation(markdown);
      const decoded = decodeHtml ? this.decodeHtml(trimmed) : trimmed;
      const emojified = emojify ? this.renderEmoji(decoded) : decoded;
      const compiled = import_marked.parse(emojified, markedOptions);
      return this.sanitizer.sanitize(this.securityContext, compiled) || '';
    }
    getSource(src) {
      if (!this.http) {
        throw new Error(errorSrcWithoutHttpClient);
      }
      return this.http.get(src, {responseType: 'text'})
          .pipe(map((markdown) => this.handleExtension(src, markdown)));
    }
    highlight(element) {
      if (!isPlatformBrowser(this.platform)) {
        return;
      }
      if (typeof Prism !== 'undefined') {
        if (!element) {
          element = document;
        }
        const noLanguageElements = element.querySelectorAll('pre code:not([class*="language-"])');
        Array.prototype.forEach.call(noLanguageElements, (x) => x.classList.add('language-none'));
        Prism.highlightAllUnder(element);
      }
    }
    renderKatex(html, options) {
      if (!isPlatformBrowser(this.platform)) {
        return html;
      }
      if (typeof katex === 'undefined' || typeof katex.renderToString === 'undefined') {
        throw new Error(errorKatexNotLoaded);
      }
      return html.replace(
          /\$([^\s][^$]*?[^\s])\$/gm, (_, tex) => katex.renderToString(tex, options));
    }
    decodeHtml(html) {
      if (!isPlatformBrowser(this.platform)) {
        return html;
      }
      const textarea = document.createElement('textarea');
      textarea.innerHTML = html;
      return textarea.value;
    }
    handleExtension(src, markdown) {
      const extension = src ? src.split('?')[0].split('.').splice(-1).join() : null;
      return extension !== 'md' ? '```' + extension + '\n' + markdown + '\n```' : markdown;
    }
    renderEmoji(html) {
      if (!isPlatformBrowser(this.platform)) {
        return html;
      }
      if (typeof joypixels === 'undefined' || typeof joypixels.shortnameToUnicode === 'undefined') {
        throw new Error(errorJoyPixelsNotLoaded);
      }
      return joypixels.shortnameToUnicode(html);
    }
    trimIndentation(markdown) {
      if (!markdown) {
        return '';
      }
      let indentStart;
      return markdown.split('\n')
          .map((line) => {
            let lineIdentStart = indentStart;
            if (line.length > 0) {
              lineIdentStart = isNaN(lineIdentStart) ?
                  line.search(/\S|$/) :
                  Math.min(line.search(/\S|$/), lineIdentStart);
            }
            if (isNaN(indentStart)) {
              indentStart = lineIdentStart;
            }
            return !!lineIdentStart ? line.substring(lineIdentStart) : line;
          })
          .join('\n');
    }
  };
  MarkdownService.\u0275fac = function MarkdownService_Factory(t) {
    return new (t || MarkdownService)(
        \u0275\u0275inject(PLATFORM_ID), \u0275\u0275inject(SECURITY_CONTEXT),
        \u0275\u0275inject(HttpClient, 8), \u0275\u0275inject(MarkedOptions, 8),
        \u0275\u0275inject(DomSanitizer));
  };
  MarkdownService.\u0275prov =
      \u0275\u0275defineInjectable({token: MarkdownService, factory: MarkdownService.\u0275fac});
  MarkdownService.ctorParameters = () =>
      [{type: Object, decorators: [{type: Inject, args: [PLATFORM_ID]}]},
       {type: SecurityContext, decorators: [{type: Inject, args: [SECURITY_CONTEXT]}]},
       {type: HttpClient, decorators: [{type: Optional}]},
       {type: MarkedOptions, decorators: [{type: Optional}]}, {type: DomSanitizer}];
  (function() {
    setClassMetadata(MarkdownService, [{type: Injectable}], function() {
      return [
        {type: Object, decorators: [{type: Inject, args: [PLATFORM_ID]}]},
        {type: SecurityContext, decorators: [{type: Inject, args: [SECURITY_CONTEXT]}]},
        {type: HttpClient, decorators: [{type: Optional}]},
        {type: MarkedOptions, decorators: [{type: Optional}]}, {type: DomSanitizer}
      ];
    }, null);
  })();
  var PrismPlugin;
  (function(PrismPlugin2) {
    PrismPlugin2['LineHighlight'] = 'line-highlight';
    PrismPlugin2['LineNumbers'] = 'line-numbers';
  })(PrismPlugin || (PrismPlugin = {}));
  var MarkdownComponent = class {
    constructor(element, markdownService) {
      this.element = element;
      this.markdownService = markdownService;
      this.error = new EventEmitter();
      this.load = new EventEmitter();
      this.ready = new EventEmitter();
      this._emoji = false;
      this._katex = false;
      this._lineHighlight = false;
      this._lineNumbers = false;
    }
    get emoji() {
      return this._emoji;
    }
    set emoji(value) {
      this._emoji = this.coerceBooleanProperty(value);
    }
    get katex() {
      return this._katex;
    }
    set katex(value) {
      this._katex = this.coerceBooleanProperty(value);
    }
    get lineHighlight() {
      return this._lineHighlight;
    }
    set lineHighlight(value) {
      this._lineHighlight = this.coerceBooleanProperty(value);
    }
    get lineNumbers() {
      return this._lineNumbers;
    }
    set lineNumbers(value) {
      this._lineNumbers = this.coerceBooleanProperty(value);
    }
    ngOnChanges() {
      if (this.data != null) {
        this.handleData();
        return;
      }
      if (this.src != null) {
        this.handleSrc();
        return;
      }
    }
    ngAfterViewInit() {
      if (!this.data && !this.src) {
        this.handleTransclusion();
      }
    }
    render(markdown, decodeHtml = false) {
      let compiled = this.markdownService.compile(markdown, decodeHtml, this.emoji);
      compiled =
          this.katex ? this.markdownService.renderKatex(compiled, this.katexOptions) : compiled;
      this.element.nativeElement.innerHTML = compiled;
      this.handlePlugins();
      this.markdownService.highlight(this.element.nativeElement);
      this.ready.emit();
    }
    coerceBooleanProperty(value) {
      return value != null && `${value}` !== 'false';
    }
    handleData() {
      this.render(this.data);
    }
    handleSrc() {
      this.markdownService.getSource(this.src).subscribe((markdown) => {
        this.render(markdown);
        this.load.emit(markdown);
      }, (error) => this.error.emit(error));
    }
    handleTransclusion() {
      this.render(this.element.nativeElement.innerHTML, true);
    }
    handlePlugins() {
      if (this.lineHighlight) {
        this.setPluginClass(this.element.nativeElement, PrismPlugin.LineHighlight);
        this.setPluginOptions(
            this.element.nativeElement, {dataLine: this.line, dataLineOffset: this.lineOffset});
      }
      if (this.lineNumbers) {
        this.setPluginClass(this.element.nativeElement, PrismPlugin.LineNumbers);
        this.setPluginOptions(this.element.nativeElement, {dataStart: this.start});
      }
    }
    setPluginClass(element, plugin) {
      const preElements = element.querySelectorAll('pre');
      for (let i = 0; i < preElements.length; i++) {
        const classes = plugin instanceof Array ? plugin : [plugin];
        preElements.item(i).classList.add(...classes);
      }
    }
    setPluginOptions(element, options) {
      const preElements = element.querySelectorAll('pre');
      for (let i = 0; i < preElements.length; i++) {
        Object.keys(options).forEach((option) => {
          const attributeValue = options[option];
          if (!!attributeValue) {
            const attributeName = this.toLispCase(option);
            preElements.item(i).setAttribute(attributeName, attributeValue.toString());
          }
        });
      }
    }
    toLispCase(value) {
      const upperChars = value.match(/([A-Z])/g);
      if (!upperChars) {
        return value;
      }
      let str = value.toString();
      for (let i = 0, n = upperChars.length; i < n; i++) {
        str = str.replace(new RegExp(upperChars[i]), '-' + upperChars[i].toLowerCase());
      }
      if (str.slice(0, 1) === '-') {
        str = str.slice(1);
      }
      return str;
    }
  };
  MarkdownComponent.\u0275fac = function MarkdownComponent_Factory(t) {
    return new (t || MarkdownComponent)(
        \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(MarkdownService));
  };
  MarkdownComponent.\u0275cmp = \u0275\u0275defineComponent({
    type: MarkdownComponent,
    selectors: [['markdown'], ['', 'markdown', '']],
    inputs: {
      emoji: 'emoji',
      katex: 'katex',
      lineHighlight: 'lineHighlight',
      lineNumbers: 'lineNumbers',
      data: 'data',
      src: 'src',
      katexOptions: 'katexOptions',
      line: 'line',
      lineOffset: 'lineOffset',
      start: 'start'
    },
    outputs: {error: 'error', load: 'load', ready: 'ready'},
    features: [\u0275\u0275NgOnChangesFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function MarkdownComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275projectionDef();
        \u0275\u0275projection(0);
      }
    },
    encapsulation: 2
  });
  MarkdownComponent.ctorParameters = () => [{type: ElementRef}, {type: MarkdownService}];
  MarkdownComponent.propDecorators = {
    data: [{type: Input}],
    src: [{type: Input}],
    emoji: [{type: Input}],
    katex: [{type: Input}],
    katexOptions: [{type: Input}],
    lineHighlight: [{type: Input}],
    line: [{type: Input}],
    lineOffset: [{type: Input}],
    lineNumbers: [{type: Input}],
    start: [{type: Input}],
    error: [{type: Output}],
    load: [{type: Output}],
    ready: [{type: Output}]
  };
  (function() {
    setClassMetadata(
        MarkdownComponent, [{
          type: Component,
          args: [{selector: 'markdown, [markdown]', template: '<ng-content></ng-content>'}]
        }],
        function() {
          return [{type: ElementRef}, {type: MarkdownService}];
        },
        {
          error: [{type: Output}],
          load: [{type: Output}],
          ready: [{type: Output}],
          emoji: [{type: Input}],
          katex: [{type: Input}],
          lineHighlight: [{type: Input}],
          lineNumbers: [{type: Input}],
          data: [{type: Input}],
          src: [{type: Input}],
          katexOptions: [{type: Input}],
          line: [{type: Input}],
          lineOffset: [{type: Input}],
          start: [{type: Input}]
        });
  })();
  var MarkdownPipe = class {
    constructor(elementRef, markdownService, zone) {
      this.elementRef = elementRef;
      this.markdownService = markdownService;
      this.zone = zone;
    }
    transform(value) {
      if (value == null) {
        return '';
      }
      if (typeof value !== 'string') {
        console.error(`MarkdownPipe has been invoked with an invalid value type [${value}]`);
        return value;
      }
      const markdown = this.markdownService.compile(value);
      this.zone.onStable.pipe(first()).subscribe(
          () => this.markdownService.highlight(this.elementRef.nativeElement));
      return markdown;
    }
  };
  MarkdownPipe.\u0275fac = function MarkdownPipe_Factory(t) {
    return new (t || MarkdownPipe)(
        \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(MarkdownService),
        \u0275\u0275directiveInject(NgZone));
  };
  MarkdownPipe.\u0275pipe =
      \u0275\u0275definePipe({name: 'markdown', type: MarkdownPipe, pure: true});
  MarkdownPipe.ctorParameters = () => [{type: ElementRef}, {type: MarkdownService}, {type: NgZone}];
  (function() {
    setClassMetadata(MarkdownPipe, [{type: Pipe, args: [{name: 'markdown'}]}], function() {
      return [{type: ElementRef}, {type: MarkdownService}, {type: NgZone}];
    }, null);
  })();
  var sharedDeclarations = [LanguagePipe, MarkdownComponent, MarkdownPipe];
  var MarkdownModule = class {
    static forRoot(markdownModuleConfig) {
      return {
        ngModule: MarkdownModule,
        providers: [
          MarkdownService, markdownModuleConfig && markdownModuleConfig.loader || [],
          markdownModuleConfig && markdownModuleConfig.markedOptions || [], {
            provide: SECURITY_CONTEXT,
            useValue: markdownModuleConfig && markdownModuleConfig.sanitize != null ?
                markdownModuleConfig.sanitize :
                SecurityContext.HTML
          }
        ]
      };
    }
    static forChild() {
      return {ngModule: MarkdownModule};
    }
  };
  MarkdownModule.\u0275mod = \u0275\u0275defineNgModule({type: MarkdownModule});
  MarkdownModule.\u0275inj = \u0275\u0275defineInjector({
    factory: function MarkdownModule_Factory(t) {
      return new (t || MarkdownModule)();
    }
  });
  (function() {
    (typeof ngJitMode === 'undefined' || ngJitMode) &&
        \u0275\u0275setNgModuleScope(MarkdownModule, {
          declarations: [LanguagePipe, MarkdownComponent, MarkdownPipe],
          exports: [LanguagePipe, MarkdownComponent, MarkdownPipe]
        });
  })();
  (function() {
    setClassMetadata(
        MarkdownModule,
        [{type: NgModule, args: [{exports: sharedDeclarations, declarations: sharedDeclarations}]}],
        null, null);
  })();

  // external/npm/node_modules/@angular/router/fesm2015/router.js
  /**
   * @license Angular v11.0.9
   * (c) 2010-2020 Google LLC. https://angular.io/
   * License: MIT
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var RouterEvent = class {
    constructor(id, url) {
      this.id = id;
      this.url = url;
    }
  };
  var NavigationStart = class extends RouterEvent {
    constructor(id, url, navigationTrigger = 'imperative', restoredState = null) {
      super(id, url);
      this.navigationTrigger = navigationTrigger;
      this.restoredState = restoredState;
    }
    toString() {
      return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
    }
  };
  var NavigationEnd = class extends RouterEvent {
    constructor(id, url, urlAfterRedirects) {
      super(id, url);
      this.urlAfterRedirects = urlAfterRedirects;
    }
    toString() {
      return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${
          this.urlAfterRedirects}')`;
    }
  };
  var NavigationCancel = class extends RouterEvent {
    constructor(id, url, reason) {
      super(id, url);
      this.reason = reason;
    }
    toString() {
      return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
    }
  };
  var NavigationError = class extends RouterEvent {
    constructor(id, url, error) {
      super(id, url);
      this.error = error;
    }
    toString() {
      return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
    }
  };
  var RoutesRecognized = class extends RouterEvent {
    constructor(id, url, urlAfterRedirects, state) {
      super(id, url);
      this.urlAfterRedirects = urlAfterRedirects;
      this.state = state;
    }
    toString() {
      return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${
          this.urlAfterRedirects}', state: ${this.state})`;
    }
  };
  var GuardsCheckStart = class extends RouterEvent {
    constructor(id, url, urlAfterRedirects, state) {
      super(id, url);
      this.urlAfterRedirects = urlAfterRedirects;
      this.state = state;
    }
    toString() {
      return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${
          this.urlAfterRedirects}', state: ${this.state})`;
    }
  };
  var GuardsCheckEnd = class extends RouterEvent {
    constructor(id, url, urlAfterRedirects, state, shouldActivate) {
      super(id, url);
      this.urlAfterRedirects = urlAfterRedirects;
      this.state = state;
      this.shouldActivate = shouldActivate;
    }
    toString() {
      return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${
          this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
    }
  };
  var ResolveStart = class extends RouterEvent {
    constructor(id, url, urlAfterRedirects, state) {
      super(id, url);
      this.urlAfterRedirects = urlAfterRedirects;
      this.state = state;
    }
    toString() {
      return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${
          this.urlAfterRedirects}', state: ${this.state})`;
    }
  };
  var ResolveEnd = class extends RouterEvent {
    constructor(id, url, urlAfterRedirects, state) {
      super(id, url);
      this.urlAfterRedirects = urlAfterRedirects;
      this.state = state;
    }
    toString() {
      return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${
          this.urlAfterRedirects}', state: ${this.state})`;
    }
  };
  var RouteConfigLoadStart = class {
    constructor(route) {
      this.route = route;
    }
    toString() {
      return `RouteConfigLoadStart(path: ${this.route.path})`;
    }
  };
  var RouteConfigLoadEnd = class {
    constructor(route) {
      this.route = route;
    }
    toString() {
      return `RouteConfigLoadEnd(path: ${this.route.path})`;
    }
  };
  var ChildActivationStart = class {
    constructor(snapshot) {
      this.snapshot = snapshot;
    }
    toString() {
      const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
      return `ChildActivationStart(path: '${path}')`;
    }
  };
  var ChildActivationEnd = class {
    constructor(snapshot) {
      this.snapshot = snapshot;
    }
    toString() {
      const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
      return `ChildActivationEnd(path: '${path}')`;
    }
  };
  var ActivationStart = class {
    constructor(snapshot) {
      this.snapshot = snapshot;
    }
    toString() {
      const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
      return `ActivationStart(path: '${path}')`;
    }
  };
  var ActivationEnd = class {
    constructor(snapshot) {
      this.snapshot = snapshot;
    }
    toString() {
      const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
      return `ActivationEnd(path: '${path}')`;
    }
  };
  var Scroll = class {
    constructor(routerEvent, position, anchor) {
      this.routerEvent = routerEvent;
      this.position = position;
      this.anchor = anchor;
    }
    toString() {
      const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
      return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var PRIMARY_OUTLET = 'primary';
  var ParamsAsMap = class {
    constructor(params) {
      this.params = params || {};
    }
    has(name) {
      return Object.prototype.hasOwnProperty.call(this.params, name);
    }
    get(name) {
      if (this.has(name)) {
        const v = this.params[name];
        return Array.isArray(v) ? v[0] : v;
      }
      return null;
    }
    getAll(name) {
      if (this.has(name)) {
        const v = this.params[name];
        return Array.isArray(v) ? v : [v];
      }
      return [];
    }
    get keys() {
      return Object.keys(this.params);
    }
  };
  function convertToParamMap(params) {
    return new ParamsAsMap(params);
  }
  var NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';
  function navigationCancelingError(message) {
    const error = Error('NavigationCancelingError: ' + message);
    error[NAVIGATION_CANCELING_ERROR] = true;
    return error;
  }
  function isNavigationCancelingError(error) {
    return error && error[NAVIGATION_CANCELING_ERROR];
  }
  function defaultUrlMatcher(segments, segmentGroup, route) {
    const parts = route.path.split('/');
    if (parts.length > segments.length) {
      return null;
    }
    if (route.pathMatch === 'full' &&
        (segmentGroup.hasChildren() || parts.length < segments.length)) {
      return null;
    }
    const posParams = {};
    for (let index = 0; index < parts.length; index++) {
      const part = parts[index];
      const segment = segments[index];
      const isParameter = part.startsWith(':');
      if (isParameter) {
        posParams[part.substring(1)] = segment;
      } else if (part !== segment.path) {
        return null;
      }
    }
    return {consumed: segments.slice(0, parts.length), posParams};
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function shallowEqualArrays(a, b) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; ++i) {
      if (!shallowEqual(a[i], b[i])) return false;
    }
    return true;
  }
  function shallowEqual(a, b) {
    const k1 = Object.keys(a);
    const k2 = Object.keys(b);
    if (!k1 || !k2 || k1.length != k2.length) {
      return false;
    }
    let key;
    for (let i = 0; i < k1.length; i++) {
      key = k1[i];
      if (!equalArraysOrString(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  function equalArraysOrString(a, b) {
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) return false;
      const aSorted = [...a].sort();
      const bSorted = [...b].sort();
      return aSorted.every((val, index) => bSorted[index] === val);
    } else {
      return a === b;
    }
  }
  function flatten2(arr) {
    return Array.prototype.concat.apply([], arr);
  }
  function last2(a) {
    return a.length > 0 ? a[a.length - 1] : null;
  }
  function forEach(map2, callback) {
    for (const prop in map2) {
      if (map2.hasOwnProperty(prop)) {
        callback(map2[prop], prop);
      }
    }
  }
  function wrapIntoObservable(value) {
    if (isObservable2(value)) {
      return value;
    }
    if (isPromise2(value)) {
      return from(Promise.resolve(value));
    }
    return of(value);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function createEmptyUrlTree() {
    return new UrlTree(new UrlSegmentGroup([], {}), {}, null);
  }
  function containsTree(container, containee, exact) {
    if (exact) {
      return equalQueryParams(container.queryParams, containee.queryParams) &&
          equalSegmentGroups(container.root, containee.root);
    }
    return containsQueryParams(container.queryParams, containee.queryParams) &&
        containsSegmentGroup(container.root, containee.root);
  }
  function equalQueryParams(container, containee) {
    return shallowEqual(container, containee);
  }
  function equalSegmentGroups(container, containee) {
    if (!equalPath(container.segments, containee.segments)) return false;
    if (container.numberOfChildren !== containee.numberOfChildren) return false;
    for (const c in containee.children) {
      if (!container.children[c]) return false;
      if (!equalSegmentGroups(container.children[c], containee.children[c])) return false;
    }
    return true;
  }
  function containsQueryParams(container, containee) {
    return Object.keys(containee).length <= Object.keys(container).length &&
        Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key]));
  }
  function containsSegmentGroup(container, containee) {
    return containsSegmentGroupHelper(container, containee, containee.segments);
  }
  function containsSegmentGroupHelper(container, containee, containeePaths) {
    if (container.segments.length > containeePaths.length) {
      const current = container.segments.slice(0, containeePaths.length);
      if (!equalPath(current, containeePaths)) return false;
      if (containee.hasChildren()) return false;
      return true;
    } else if (container.segments.length === containeePaths.length) {
      if (!equalPath(container.segments, containeePaths)) return false;
      for (const c in containee.children) {
        if (!container.children[c]) return false;
        if (!containsSegmentGroup(container.children[c], containee.children[c])) return false;
      }
      return true;
    } else {
      const current = containeePaths.slice(0, container.segments.length);
      const next = containeePaths.slice(container.segments.length);
      if (!equalPath(container.segments, current)) return false;
      if (!container.children[PRIMARY_OUTLET]) return false;
      return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);
    }
  }
  var UrlTree = class {
    constructor(root, queryParams, fragment) {
      this.root = root;
      this.queryParams = queryParams;
      this.fragment = fragment;
    }
    get queryParamMap() {
      if (!this._queryParamMap) {
        this._queryParamMap = convertToParamMap(this.queryParams);
      }
      return this._queryParamMap;
    }
    toString() {
      return DEFAULT_SERIALIZER.serialize(this);
    }
  };
  var UrlSegmentGroup = class {
    constructor(segments, children) {
      this.segments = segments;
      this.children = children;
      this.parent = null;
      forEach(children, (v, k) => v.parent = this);
    }
    hasChildren() {
      return this.numberOfChildren > 0;
    }
    get numberOfChildren() {
      return Object.keys(this.children).length;
    }
    toString() {
      return serializePaths(this);
    }
  };
  var UrlSegment = class {
    constructor(path, parameters) {
      this.path = path;
      this.parameters = parameters;
    }
    get parameterMap() {
      if (!this._parameterMap) {
        this._parameterMap = convertToParamMap(this.parameters);
      }
      return this._parameterMap;
    }
    toString() {
      return serializePath(this);
    }
  };
  function equalSegments(as, bs) {
    return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));
  }
  function equalPath(as, bs) {
    if (as.length !== bs.length) return false;
    return as.every((a, i) => a.path === bs[i].path);
  }
  function mapChildrenIntoArray(segment, fn) {
    let res = [];
    forEach(segment.children, (child, childOutlet) => {
      if (childOutlet === PRIMARY_OUTLET) {
        res = res.concat(fn(child, childOutlet));
      }
    });
    forEach(segment.children, (child, childOutlet) => {
      if (childOutlet !== PRIMARY_OUTLET) {
        res = res.concat(fn(child, childOutlet));
      }
    });
    return res;
  }
  var UrlSerializer = class {};
  var DefaultUrlSerializer = class {
    parse(url) {
      const p = new UrlParser(url);
      return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
    }
    serialize(tree2) {
      const segment = `/${serializeSegment(tree2.root, true)}`;
      const query = serializeQueryParams(tree2.queryParams);
      const fragment =
          typeof tree2.fragment === `string` ? `#${encodeUriFragment(tree2.fragment)}` : '';
      return `${segment}${query}${fragment}`;
    }
  };
  var DEFAULT_SERIALIZER = new DefaultUrlSerializer();
  function serializePaths(segment) {
    return segment.segments.map((p) => serializePath(p)).join('/');
  }
  function serializeSegment(segment, root) {
    if (!segment.hasChildren()) {
      return serializePaths(segment);
    }
    if (root) {
      const primary = segment.children[PRIMARY_OUTLET] ?
          serializeSegment(segment.children[PRIMARY_OUTLET], false) :
          '';
      const children = [];
      forEach(segment.children, (v, k) => {
        if (k !== PRIMARY_OUTLET) {
          children.push(`${k}:${serializeSegment(v, false)}`);
        }
      });
      return children.length > 0 ? `${primary}(${children.join('//')})` : primary;
    } else {
      const children = mapChildrenIntoArray(segment, (v, k) => {
        if (k === PRIMARY_OUTLET) {
          return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
        }
        return [`${k}:${serializeSegment(v, false)}`];
      });
      if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {
        return `${serializePaths(segment)}/${children[0]}`;
      }
      return `${serializePaths(segment)}/(${children.join('//')})`;
    }
  }
  function encodeUriString(s) {
    return encodeURIComponent(s)
        .replace(/%40/g, '@')
        .replace(/%3A/gi, ':')
        .replace(/%24/g, '$')
        .replace(/%2C/gi, ',');
  }
  function encodeUriQuery(s) {
    return encodeUriString(s).replace(/%3B/gi, ';');
  }
  function encodeUriFragment(s) {
    return encodeURI(s);
  }
  function encodeUriSegment(s) {
    return encodeUriString(s).replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/%26/gi, '&');
  }
  function decode(s) {
    return decodeURIComponent(s);
  }
  function decodeQuery(s) {
    return decode(s.replace(/\+/g, '%20'));
  }
  function serializePath(path) {
    return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;
  }
  function serializeMatrixParams(params) {
    return Object.keys(params)
        .map((key) => `;${encodeUriSegment(key)}=${encodeUriSegment(params[key])}`)
        .join('');
  }
  function serializeQueryParams(params) {
    const strParams = Object.keys(params).map((name) => {
      const value = params[name];
      return Array.isArray(value) ?
          value.map((v) => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join('&') :
          `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;
    });
    return strParams.length ? `?${strParams.join('&')}` : '';
  }
  var SEGMENT_RE = /^[^\/()?;=#]+/;
  function matchSegments(str) {
    const match2 = str.match(SEGMENT_RE);
    return match2 ? match2[0] : '';
  }
  var QUERY_PARAM_RE = /^[^=?&#]+/;
  function matchQueryParams(str) {
    const match2 = str.match(QUERY_PARAM_RE);
    return match2 ? match2[0] : '';
  }
  var QUERY_PARAM_VALUE_RE = /^[^?&#]+/;
  function matchUrlQueryParamValue(str) {
    const match2 = str.match(QUERY_PARAM_VALUE_RE);
    return match2 ? match2[0] : '';
  }
  var UrlParser = class {
    constructor(url) {
      this.url = url;
      this.remaining = url;
    }
    parseRootSegment() {
      this.consumeOptional('/');
      if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {
        return new UrlSegmentGroup([], {});
      }
      return new UrlSegmentGroup([], this.parseChildren());
    }
    parseQueryParams() {
      const params = {};
      if (this.consumeOptional('?')) {
        do {
          this.parseQueryParam(params);
        } while (this.consumeOptional('&'));
      }
      return params;
    }
    parseFragment() {
      return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;
    }
    parseChildren() {
      if (this.remaining === '') {
        return {};
      }
      this.consumeOptional('/');
      const segments = [];
      if (!this.peekStartsWith('(')) {
        segments.push(this.parseSegment());
      }
      while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {
        this.capture('/');
        segments.push(this.parseSegment());
      }
      let children = {};
      if (this.peekStartsWith('/(')) {
        this.capture('/');
        children = this.parseParens(true);
      }
      let res = {};
      if (this.peekStartsWith('(')) {
        res = this.parseParens(false);
      }
      if (segments.length > 0 || Object.keys(children).length > 0) {
        res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
      }
      return res;
    }
    parseSegment() {
      const path = matchSegments(this.remaining);
      if (path === '' && this.peekStartsWith(';')) {
        throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);
      }
      this.capture(path);
      return new UrlSegment(decode(path), this.parseMatrixParams());
    }
    parseMatrixParams() {
      const params = {};
      while (this.consumeOptional(';')) {
        this.parseParam(params);
      }
      return params;
    }
    parseParam(params) {
      const key = matchSegments(this.remaining);
      if (!key) {
        return;
      }
      this.capture(key);
      let value = '';
      if (this.consumeOptional('=')) {
        const valueMatch = matchSegments(this.remaining);
        if (valueMatch) {
          value = valueMatch;
          this.capture(value);
        }
      }
      params[decode(key)] = decode(value);
    }
    parseQueryParam(params) {
      const key = matchQueryParams(this.remaining);
      if (!key) {
        return;
      }
      this.capture(key);
      let value = '';
      if (this.consumeOptional('=')) {
        const valueMatch = matchUrlQueryParamValue(this.remaining);
        if (valueMatch) {
          value = valueMatch;
          this.capture(value);
        }
      }
      const decodedKey = decodeQuery(key);
      const decodedVal = decodeQuery(value);
      if (params.hasOwnProperty(decodedKey)) {
        let currentVal = params[decodedKey];
        if (!Array.isArray(currentVal)) {
          currentVal = [currentVal];
          params[decodedKey] = currentVal;
        }
        currentVal.push(decodedVal);
      } else {
        params[decodedKey] = decodedVal;
      }
    }
    parseParens(allowPrimary) {
      const segments = {};
      this.capture('(');
      while (!this.consumeOptional(')') && this.remaining.length > 0) {
        const path = matchSegments(this.remaining);
        const next = this.remaining[path.length];
        if (next !== '/' && next !== ')' && next !== ';') {
          throw new Error(`Cannot parse url '${this.url}'`);
        }
        let outletName = void 0;
        if (path.indexOf(':') > -1) {
          outletName = path.substr(0, path.indexOf(':'));
          this.capture(outletName);
          this.capture(':');
        } else if (allowPrimary) {
          outletName = PRIMARY_OUTLET;
        }
        const children = this.parseChildren();
        segments[outletName] = Object.keys(children).length === 1 ?
            children[PRIMARY_OUTLET] :
            new UrlSegmentGroup([], children);
        this.consumeOptional('//');
      }
      return segments;
    }
    peekStartsWith(str) {
      return this.remaining.startsWith(str);
    }
    consumeOptional(str) {
      if (this.peekStartsWith(str)) {
        this.remaining = this.remaining.substring(str.length);
        return true;
      }
      return false;
    }
    capture(str) {
      if (!this.consumeOptional(str)) {
        throw new Error(`Expected "${str}".`);
      }
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var Tree = class {
    constructor(root) {
      this._root = root;
    }
    get root() {
      return this._root.value;
    }
    parent(t) {
      const p = this.pathFromRoot(t);
      return p.length > 1 ? p[p.length - 2] : null;
    }
    children(t) {
      const n = findNode(t, this._root);
      return n ? n.children.map((t2) => t2.value) : [];
    }
    firstChild(t) {
      const n = findNode(t, this._root);
      return n && n.children.length > 0 ? n.children[0].value : null;
    }
    siblings(t) {
      const p = findPath(t, this._root);
      if (p.length < 2) return [];
      const c = p[p.length - 2].children.map((c2) => c2.value);
      return c.filter((cc) => cc !== t);
    }
    pathFromRoot(t) {
      return findPath(t, this._root).map((s) => s.value);
    }
  };
  function findNode(value, node) {
    if (value === node.value) return node;
    for (const child of node.children) {
      const node2 = findNode(value, child);
      if (node2) return node2;
    }
    return null;
  }
  function findPath(value, node) {
    if (value === node.value) return [node];
    for (const child of node.children) {
      const path = findPath(value, child);
      if (path.length) {
        path.unshift(node);
        return path;
      }
    }
    return [];
  }
  var TreeNode = class {
    constructor(value, children) {
      this.value = value;
      this.children = children;
    }
    toString() {
      return `TreeNode(${this.value})`;
    }
  };
  function nodeChildrenAsMap(node) {
    const map2 = {};
    if (node) {
      node.children.forEach((child) => map2[child.value.outlet] = child);
    }
    return map2;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var RouterState = class extends Tree {
    constructor(root, snapshot) {
      super(root);
      this.snapshot = snapshot;
      setRouterState(this, root);
    }
    toString() {
      return this.snapshot.toString();
    }
  };
  function createEmptyState(urlTree, rootComponent) {
    const snapshot = createEmptyStateSnapshot(urlTree, rootComponent);
    const emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);
    const emptyParams = new BehaviorSubject({});
    const emptyData = new BehaviorSubject({});
    const emptyQueryParams = new BehaviorSubject({});
    const fragment = new BehaviorSubject('');
    const activated = new ActivatedRoute(
        emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent,
        snapshot.root);
    activated.snapshot = snapshot.root;
    return new RouterState(new TreeNode(activated, []), snapshot);
  }
  function createEmptyStateSnapshot(urlTree, rootComponent) {
    const emptyParams = {};
    const emptyData = {};
    const emptyQueryParams = {};
    const fragment = '';
    const activated = new ActivatedRouteSnapshot(
        [], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null,
        urlTree.root, -1, {});
    return new RouterStateSnapshot('', new TreeNode(activated, []));
  }
  var ActivatedRoute = class {
    constructor(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {
      this.url = url;
      this.params = params;
      this.queryParams = queryParams;
      this.fragment = fragment;
      this.data = data;
      this.outlet = outlet;
      this.component = component;
      this._futureSnapshot = futureSnapshot;
    }
    get routeConfig() {
      return this._futureSnapshot.routeConfig;
    }
    get root() {
      return this._routerState.root;
    }
    get parent() {
      return this._routerState.parent(this);
    }
    get firstChild() {
      return this._routerState.firstChild(this);
    }
    get children() {
      return this._routerState.children(this);
    }
    get pathFromRoot() {
      return this._routerState.pathFromRoot(this);
    }
    get paramMap() {
      if (!this._paramMap) {
        this._paramMap = this.params.pipe(map((p) => convertToParamMap(p)));
      }
      return this._paramMap;
    }
    get queryParamMap() {
      if (!this._queryParamMap) {
        this._queryParamMap = this.queryParams.pipe(map((p) => convertToParamMap(p)));
      }
      return this._queryParamMap;
    }
    toString() {
      return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;
    }
  };
  function inheritedParamsDataResolve(route, paramsInheritanceStrategy = 'emptyOnly') {
    const pathFromRoot = route.pathFromRoot;
    let inheritingStartingFrom = 0;
    if (paramsInheritanceStrategy !== 'always') {
      inheritingStartingFrom = pathFromRoot.length - 1;
      while (inheritingStartingFrom >= 1) {
        const current = pathFromRoot[inheritingStartingFrom];
        const parent = pathFromRoot[inheritingStartingFrom - 1];
        if (current.routeConfig && current.routeConfig.path === '') {
          inheritingStartingFrom--;
        } else if (!parent.component) {
          inheritingStartingFrom--;
        } else {
          break;
        }
      }
    }
    return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));
  }
  function flattenInherited(pathFromRoot) {
    return pathFromRoot.reduce((res, curr) => {
      const params = Object.assign(Object.assign({}, res.params), curr.params);
      const data = Object.assign(Object.assign({}, res.data), curr.data);
      const resolve = Object.assign(Object.assign({}, res.resolve), curr._resolvedData);
      return {params, data, resolve};
    }, {params: {}, data: {}, resolve: {}});
  }
  var ActivatedRouteSnapshot = class {
    constructor(
        url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment,
        lastPathIndex, resolve) {
      this.url = url;
      this.params = params;
      this.queryParams = queryParams;
      this.fragment = fragment;
      this.data = data;
      this.outlet = outlet;
      this.component = component;
      this.routeConfig = routeConfig;
      this._urlSegment = urlSegment;
      this._lastPathIndex = lastPathIndex;
      this._resolve = resolve;
    }
    get root() {
      return this._routerState.root;
    }
    get parent() {
      return this._routerState.parent(this);
    }
    get firstChild() {
      return this._routerState.firstChild(this);
    }
    get children() {
      return this._routerState.children(this);
    }
    get pathFromRoot() {
      return this._routerState.pathFromRoot(this);
    }
    get paramMap() {
      if (!this._paramMap) {
        this._paramMap = convertToParamMap(this.params);
      }
      return this._paramMap;
    }
    get queryParamMap() {
      if (!this._queryParamMap) {
        this._queryParamMap = convertToParamMap(this.queryParams);
      }
      return this._queryParamMap;
    }
    toString() {
      const url = this.url.map((segment) => segment.toString()).join('/');
      const matched = this.routeConfig ? this.routeConfig.path : '';
      return `Route(url:'${url}', path:'${matched}')`;
    }
  };
  var RouterStateSnapshot = class extends Tree {
    constructor(url, root) {
      super(root);
      this.url = url;
      setRouterState(this, root);
    }
    toString() {
      return serializeNode(this._root);
    }
  };
  function setRouterState(state, node) {
    node.value._routerState = state;
    node.children.forEach((c) => setRouterState(state, c));
  }
  function serializeNode(node) {
    const c =
        node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(', ')} } ` : '';
    return `${node.value}${c}`;
  }
  function advanceActivatedRoute(route) {
    if (route.snapshot) {
      const currentSnapshot = route.snapshot;
      const nextSnapshot = route._futureSnapshot;
      route.snapshot = nextSnapshot;
      if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
        route.queryParams.next(nextSnapshot.queryParams);
      }
      if (currentSnapshot.fragment !== nextSnapshot.fragment) {
        route.fragment.next(nextSnapshot.fragment);
      }
      if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
        route.params.next(nextSnapshot.params);
      }
      if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
        route.url.next(nextSnapshot.url);
      }
      if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
        route.data.next(nextSnapshot.data);
      }
    } else {
      route.snapshot = route._futureSnapshot;
      route.data.next(route._futureSnapshot.data);
    }
  }
  function equalParamsAndUrlSegments(a, b) {
    const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);
    const parentsMismatch = !a.parent !== !b.parent;
    return equalUrlParams && !parentsMismatch &&
        (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function createRouterState(routeReuseStrategy, curr, prevState) {
    const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : void 0);
    return new RouterState(root, curr);
  }
  function createNode(routeReuseStrategy, curr, prevState) {
    if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
      const value = prevState.value;
      value._futureSnapshot = curr.value;
      const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
      return new TreeNode(value, children);
    } else {
      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);
      if (detachedRouteHandle) {
        const tree2 = detachedRouteHandle.route;
        setFutureSnapshotsOfActivatedRoutes(curr, tree2);
        return tree2;
      } else {
        const value = createActivatedRoute(curr.value);
        const children = curr.children.map((c) => createNode(routeReuseStrategy, c));
        return new TreeNode(value, children);
      }
    }
  }
  function setFutureSnapshotsOfActivatedRoutes(curr, result) {
    if (curr.value.routeConfig !== result.value.routeConfig) {
      throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');
    }
    if (curr.children.length !== result.children.length) {
      throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');
    }
    result.value._futureSnapshot = curr.value;
    for (let i = 0; i < curr.children.length; ++i) {
      setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);
    }
  }
  function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
    return curr.children.map((child) => {
      for (const p of prevState.children) {
        if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {
          return createNode(routeReuseStrategy, child, p);
        }
      }
      return createNode(routeReuseStrategy, child);
    });
  }
  function createActivatedRoute(c) {
    return new ActivatedRoute(
        new BehaviorSubject(c.url), new BehaviorSubject(c.params),
        new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment),
        new BehaviorSubject(c.data), c.outlet, c.component, c);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function createUrlTree(route, urlTree, commands, queryParams, fragment) {
    if (commands.length === 0) {
      return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);
    }
    const nav = computeNavigation(commands);
    if (nav.toRoot()) {
      return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);
    }
    const startingPosition = findStartingPosition(nav, urlTree, route);
    const segmentGroup = startingPosition.processChildren ?
        updateSegmentGroupChildren(
            startingPosition.segmentGroup, startingPosition.index, nav.commands) :
        updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);
    return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);
  }
  function isMatrixParams(command) {
    return typeof command === 'object' && command != null && !command.outlets &&
        !command.segmentPath;
  }
  function isCommandWithOutlets(command) {
    return typeof command === 'object' && command != null && command.outlets;
  }
  function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {
    let qp = {};
    if (queryParams) {
      forEach(queryParams, (value, name) => {
        qp[name] = Array.isArray(value) ? value.map((v) => `${v}`) : `${value}`;
      });
    }
    if (urlTree.root === oldSegmentGroup) {
      return new UrlTree(newSegmentGroup, qp, fragment);
    }
    return new UrlTree(
        replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);
  }
  function replaceSegment(current, oldSegment, newSegment) {
    const children = {};
    forEach(current.children, (c, outletName) => {
      if (c === oldSegment) {
        children[outletName] = newSegment;
      } else {
        children[outletName] = replaceSegment(c, oldSegment, newSegment);
      }
    });
    return new UrlSegmentGroup(current.segments, children);
  }
  var Navigation = class {
    constructor(isAbsolute, numberOfDoubleDots, commands) {
      this.isAbsolute = isAbsolute;
      this.numberOfDoubleDots = numberOfDoubleDots;
      this.commands = commands;
      if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
        throw new Error('Root segment cannot have matrix parameters');
      }
      const cmdWithOutlet = commands.find(isCommandWithOutlets);
      if (cmdWithOutlet && cmdWithOutlet !== last2(commands)) {
        throw new Error('{outlets:{}} has to be the last command');
      }
    }
    toRoot() {
      return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';
    }
  };
  function computeNavigation(commands) {
    if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {
      return new Navigation(true, 0, commands);
    }
    let numberOfDoubleDots = 0;
    let isAbsolute = false;
    const res = commands.reduce((res2, cmd, cmdIdx) => {
      if (typeof cmd === 'object' && cmd != null) {
        if (cmd.outlets) {
          const outlets = {};
          forEach(cmd.outlets, (commands2, name) => {
            outlets[name] = typeof commands2 === 'string' ? commands2.split('/') : commands2;
          });
          return [...res2, {outlets}];
        }
        if (cmd.segmentPath) {
          return [...res2, cmd.segmentPath];
        }
      }
      if (!(typeof cmd === 'string')) {
        return [...res2, cmd];
      }
      if (cmdIdx === 0) {
        cmd.split('/').forEach((urlPart, partIndex) => {
          if (partIndex == 0 && urlPart === '.') {
          } else if (partIndex == 0 && urlPart === '') {
            isAbsolute = true;
          } else if (urlPart === '..') {
            numberOfDoubleDots++;
          } else if (urlPart != '') {
            res2.push(urlPart);
          }
        });
        return res2;
      }
      return [...res2, cmd];
    }, []);
    return new Navigation(isAbsolute, numberOfDoubleDots, res);
  }
  var Position = class {
    constructor(segmentGroup, processChildren, index) {
      this.segmentGroup = segmentGroup;
      this.processChildren = processChildren;
      this.index = index;
    }
  };
  function findStartingPosition(nav, tree2, route) {
    if (nav.isAbsolute) {
      return new Position(tree2.root, true, 0);
    }
    if (route.snapshot._lastPathIndex === -1) {
      const segmentGroup = route.snapshot._urlSegment;
      const processChildren = segmentGroup === tree2.root;
      return new Position(segmentGroup, processChildren, 0);
    }
    const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
    const index = route.snapshot._lastPathIndex + modifier;
    return createPositionApplyingDoubleDots(
        route.snapshot._urlSegment, index, nav.numberOfDoubleDots);
  }
  function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {
    let g = group;
    let ci = index;
    let dd = numberOfDoubleDots;
    while (dd > ci) {
      dd -= ci;
      g = g.parent;
      if (!g) {
        throw new Error('Invalid number of \'../\'');
      }
      ci = g.segments.length;
    }
    return new Position(g, false, ci - dd);
  }
  function getOutlets(commands) {
    if (isCommandWithOutlets(commands[0])) {
      return commands[0].outlets;
    }
    return {[PRIMARY_OUTLET]: commands};
  }
  function updateSegmentGroup(segmentGroup, startIndex, commands) {
    if (!segmentGroup) {
      segmentGroup = new UrlSegmentGroup([], {});
    }
    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
      return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
    }
    const m = prefixedWith(segmentGroup, startIndex, commands);
    const slicedCommands = commands.slice(m.commandIndex);
    if (m.match && m.pathIndex < segmentGroup.segments.length) {
      const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
      g.children[PRIMARY_OUTLET] =
          new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
      return updateSegmentGroupChildren(g, 0, slicedCommands);
    } else if (m.match && slicedCommands.length === 0) {
      return new UrlSegmentGroup(segmentGroup.segments, {});
    } else if (m.match && !segmentGroup.hasChildren()) {
      return createNewSegmentGroup(segmentGroup, startIndex, commands);
    } else if (m.match) {
      return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
    } else {
      return createNewSegmentGroup(segmentGroup, startIndex, commands);
    }
  }
  function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
    if (commands.length === 0) {
      return new UrlSegmentGroup(segmentGroup.segments, {});
    } else {
      const outlets = getOutlets(commands);
      const children = {};
      forEach(outlets, (commands2, outlet) => {
        if (typeof commands2 === 'string') {
          commands2 = [commands2];
        }
        if (commands2 !== null) {
          children[outlet] =
              updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands2);
        }
      });
      forEach(segmentGroup.children, (child, childOutlet) => {
        if (outlets[childOutlet] === void 0) {
          children[childOutlet] = child;
        }
      });
      return new UrlSegmentGroup(segmentGroup.segments, children);
    }
  }
  function prefixedWith(segmentGroup, startIndex, commands) {
    let currentCommandIndex = 0;
    let currentPathIndex = startIndex;
    const noMatch2 = {match: false, pathIndex: 0, commandIndex: 0};
    while (currentPathIndex < segmentGroup.segments.length) {
      if (currentCommandIndex >= commands.length) return noMatch2;
      const path = segmentGroup.segments[currentPathIndex];
      const command = commands[currentCommandIndex];
      if (isCommandWithOutlets(command)) {
        break;
      }
      const curr = `${command}`;
      const next =
          currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
      if (currentPathIndex > 0 && curr === void 0) break;
      if (curr && next && typeof next === 'object' && next.outlets === void 0) {
        if (!compare(curr, next, path)) return noMatch2;
        currentCommandIndex += 2;
      } else {
        if (!compare(curr, {}, path)) return noMatch2;
        currentCommandIndex++;
      }
      currentPathIndex++;
    }
    return {match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex};
  }
  function createNewSegmentGroup(segmentGroup, startIndex, commands) {
    const paths = segmentGroup.segments.slice(0, startIndex);
    let i = 0;
    while (i < commands.length) {
      const command = commands[i];
      if (isCommandWithOutlets(command)) {
        const children = createNewSegmentChildren(command.outlets);
        return new UrlSegmentGroup(paths, children);
      }
      if (i === 0 && isMatrixParams(commands[0])) {
        const p = segmentGroup.segments[startIndex];
        paths.push(new UrlSegment(p.path, commands[0]));
        i++;
        continue;
      }
      const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;
      const next = i < commands.length - 1 ? commands[i + 1] : null;
      if (curr && next && isMatrixParams(next)) {
        paths.push(new UrlSegment(curr, stringify2(next)));
        i += 2;
      } else {
        paths.push(new UrlSegment(curr, {}));
        i++;
      }
    }
    return new UrlSegmentGroup(paths, {});
  }
  function createNewSegmentChildren(outlets) {
    const children = {};
    forEach(outlets, (commands, outlet) => {
      if (typeof commands === 'string') {
        commands = [commands];
      }
      if (commands !== null) {
        children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
      }
    });
    return children;
  }
  function stringify2(params) {
    const res = {};
    forEach(params, (v, k) => res[k] = `${v}`);
    return res;
  }
  function compare(path, params, segment) {
    return path == segment.path && shallowEqual(params, segment.parameters);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent) => map((t) => {
    new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent)
        .activate(rootContexts);
    return t;
  });
  var ActivateRoutes = class {
    constructor(routeReuseStrategy, futureState, currState, forwardEvent) {
      this.routeReuseStrategy = routeReuseStrategy;
      this.futureState = futureState;
      this.currState = currState;
      this.forwardEvent = forwardEvent;
    }
    activate(parentContexts) {
      const futureRoot = this.futureState._root;
      const currRoot = this.currState ? this.currState._root : null;
      this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
      advanceActivatedRoute(this.futureState.root);
      this.activateChildRoutes(futureRoot, currRoot, parentContexts);
    }
    deactivateChildRoutes(futureNode, currNode, contexts) {
      const children = nodeChildrenAsMap(currNode);
      futureNode.children.forEach((futureChild) => {
        const childOutletName = futureChild.value.outlet;
        this.deactivateRoutes(futureChild, children[childOutletName], contexts);
        delete children[childOutletName];
      });
      forEach(children, (v, childName) => {
        this.deactivateRouteAndItsChildren(v, contexts);
      });
    }
    deactivateRoutes(futureNode, currNode, parentContext) {
      const future = futureNode.value;
      const curr = currNode ? currNode.value : null;
      if (future === curr) {
        if (future.component) {
          const context = parentContext.getContext(future.outlet);
          if (context) {
            this.deactivateChildRoutes(futureNode, currNode, context.children);
          }
        } else {
          this.deactivateChildRoutes(futureNode, currNode, parentContext);
        }
      } else {
        if (curr) {
          this.deactivateRouteAndItsChildren(currNode, parentContext);
        }
      }
    }
    deactivateRouteAndItsChildren(route, parentContexts) {
      if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
        this.detachAndStoreRouteSubtree(route, parentContexts);
      } else {
        this.deactivateRouteAndOutlet(route, parentContexts);
      }
    }
    detachAndStoreRouteSubtree(route, parentContexts) {
      const context = parentContexts.getContext(route.value.outlet);
      if (context && context.outlet) {
        const componentRef = context.outlet.detach();
        const contexts = context.children.onOutletDeactivated();
        this.routeReuseStrategy.store(route.value.snapshot, {componentRef, route, contexts});
      }
    }
    deactivateRouteAndOutlet(route, parentContexts) {
      const context = parentContexts.getContext(route.value.outlet);
      const contexts = context && route.value.component ? context.children : parentContexts;
      const children = nodeChildrenAsMap(route);
      for (const childOutlet of Object.keys(children)) {
        this.deactivateRouteAndItsChildren(children[childOutlet], contexts);
      }
      if (context && context.outlet) {
        context.outlet.deactivate();
        context.children.onOutletDeactivated();
      }
    }
    activateChildRoutes(futureNode, currNode, contexts) {
      const children = nodeChildrenAsMap(currNode);
      futureNode.children.forEach((c) => {
        this.activateRoutes(c, children[c.value.outlet], contexts);
        this.forwardEvent(new ActivationEnd(c.value.snapshot));
      });
      if (futureNode.children.length) {
        this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
      }
    }
    activateRoutes(futureNode, currNode, parentContexts) {
      const future = futureNode.value;
      const curr = currNode ? currNode.value : null;
      advanceActivatedRoute(future);
      if (future === curr) {
        if (future.component) {
          const context = parentContexts.getOrCreateContext(future.outlet);
          this.activateChildRoutes(futureNode, currNode, context.children);
        } else {
          this.activateChildRoutes(futureNode, currNode, parentContexts);
        }
      } else {
        if (future.component) {
          const context = parentContexts.getOrCreateContext(future.outlet);
          if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
            const stored = this.routeReuseStrategy.retrieve(future.snapshot);
            this.routeReuseStrategy.store(future.snapshot, null);
            context.children.onOutletReAttached(stored.contexts);
            context.attachRef = stored.componentRef;
            context.route = stored.route.value;
            if (context.outlet) {
              context.outlet.attach(stored.componentRef, stored.route.value);
            }
            advanceActivatedRouteNodeAndItsChildren(stored.route);
          } else {
            const config2 = parentLoadedConfig(future.snapshot);
            const cmpFactoryResolver = config2 ? config2.module.componentFactoryResolver : null;
            context.attachRef = null;
            context.route = future;
            context.resolver = cmpFactoryResolver;
            if (context.outlet) {
              context.outlet.activateWith(future, cmpFactoryResolver);
            }
            this.activateChildRoutes(futureNode, null, context.children);
          }
        } else {
          this.activateChildRoutes(futureNode, null, parentContexts);
        }
      }
    }
  };
  function advanceActivatedRouteNodeAndItsChildren(node) {
    advanceActivatedRoute(node.value);
    node.children.forEach(advanceActivatedRouteNodeAndItsChildren);
  }
  function parentLoadedConfig(snapshot) {
    for (let s = snapshot.parent; s; s = s.parent) {
      const route = s.routeConfig;
      if (route && route._loadedConfig) return route._loadedConfig;
      if (route && route.component) return null;
    }
    return null;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var LoadedRouterConfig = class {
    constructor(routes2, module) {
      this.routes = routes2;
      this.module = module;
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function isFunction2(v) {
    return typeof v === 'function';
  }
  function isBoolean(v) {
    return typeof v === 'boolean';
  }
  function isUrlTree(v) {
    return v instanceof UrlTree;
  }
  function isCanLoad(guard) {
    return guard && isFunction2(guard.canLoad);
  }
  function isCanActivate(guard) {
    return guard && isFunction2(guard.canActivate);
  }
  function isCanActivateChild(guard) {
    return guard && isFunction2(guard.canActivateChild);
  }
  function isCanDeactivate(guard) {
    return guard && isFunction2(guard.canDeactivate);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var INITIAL_VALUE = Symbol('INITIAL_VALUE');
  function prioritizedGuardValue() {
    return switchMap((obs) => {
      return combineLatest(obs.map((o) => o.pipe(take(1), startWith(INITIAL_VALUE))))
          .pipe(
              scan(
                  (acc, list) => {
                    let isPending = false;
                    return list.reduce((innerAcc, val, i) => {
                      if (innerAcc !== INITIAL_VALUE) return innerAcc;
                      if (val === INITIAL_VALUE) isPending = true;
                      if (!isPending) {
                        if (val === false) return val;
                        if (i === list.length - 1 || isUrlTree(val)) {
                          return val;
                        }
                      }
                      return innerAcc;
                    }, acc);
                  },
                  INITIAL_VALUE),
              filter((item) => item !== INITIAL_VALUE),
              map((item) => isUrlTree(item) ? item : item === true), take(1));
    });
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var \u0275EmptyOutletComponent = class {};
  \u0275EmptyOutletComponent.\u0275fac = function \u0275EmptyOutletComponent_Factory(t) {
    return new (t || \u0275EmptyOutletComponent)();
  };
  \u0275EmptyOutletComponent.\u0275cmp = \u0275\u0275defineComponent({
    type: \u0275EmptyOutletComponent,
    selectors: [['ng-component']],
    decls: 1,
    vars: 0,
    template: function \u0275EmptyOutletComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275element(0, 'router-outlet');
      }
    },
    directives: function() {
      return [RouterOutlet];
    },
    encapsulation: 2
  });
  (function() {
    setClassMetadata(
        \u0275EmptyOutletComponent,
        [{type: Component, args: [{template: `<router-outlet></router-outlet>`}]}], null, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function validateConfig(config2, parentPath = '') {
    for (let i = 0; i < config2.length; i++) {
      const route = config2[i];
      const fullPath = getFullPath(parentPath, route);
      validateNode(route, fullPath);
    }
  }
  function validateNode(route, fullPath) {
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      if (!route) {
        throw new Error(`
      Invalid configuration of route '${fullPath}': Encountered undefined route.
      The reason might be an extra comma.

      Example:
      const routes: Routes = [
        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
        { path: 'dashboard',  component: DashboardComponent },, << two commas
        { path: 'detail/:id', component: HeroDetailComponent }
      ];
    `);
      }
      if (Array.isArray(route)) {
        throw new Error(`Invalid configuration of route '${fullPath}': Array cannot be specified`);
      }
      if (!route.component && !route.children && !route.loadChildren &&
          (route.outlet && route.outlet !== PRIMARY_OUTLET)) {
        throw new Error(`Invalid configuration of route '${
            fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);
      }
      if (route.redirectTo && route.children) {
        throw new Error(`Invalid configuration of route '${
            fullPath}': redirectTo and children cannot be used together`);
      }
      if (route.redirectTo && route.loadChildren) {
        throw new Error(`Invalid configuration of route '${
            fullPath}': redirectTo and loadChildren cannot be used together`);
      }
      if (route.children && route.loadChildren) {
        throw new Error(`Invalid configuration of route '${
            fullPath}': children and loadChildren cannot be used together`);
      }
      if (route.redirectTo && route.component) {
        throw new Error(`Invalid configuration of route '${
            fullPath}': redirectTo and component cannot be used together`);
      }
      if (route.path && route.matcher) {
        throw new Error(`Invalid configuration of route '${
            fullPath}': path and matcher cannot be used together`);
      }
      if (route.redirectTo === void 0 && !route.component && !route.children &&
          !route.loadChildren) {
        throw new Error(`Invalid configuration of route '${
            fullPath}'. One of the following must be provided: component, redirectTo, children or loadChildren`);
      }
      if (route.path === void 0 && route.matcher === void 0) {
        throw new Error(`Invalid configuration of route '${
            fullPath}': routes must have either a path or a matcher specified`);
      }
      if (typeof route.path === 'string' && route.path.charAt(0) === '/') {
        throw new Error(
            `Invalid configuration of route '${fullPath}': path cannot start with a slash`);
      }
      if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {
        const exp =
            `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;
        throw new Error(`Invalid configuration of route '{path: "${fullPath}", redirectTo: "${
            route.redirectTo}"}': please provide 'pathMatch'. ${exp}`);
      }
      if (route.pathMatch !== void 0 && route.pathMatch !== 'full' &&
          route.pathMatch !== 'prefix') {
        throw new Error(`Invalid configuration of route '${
            fullPath}': pathMatch can only be set to 'prefix' or 'full'`);
      }
    }
    if (route.children) {
      validateConfig(route.children, fullPath);
    }
  }
  function getFullPath(parentPath, currentRoute) {
    if (!currentRoute) {
      return parentPath;
    }
    if (!parentPath && !currentRoute.path) {
      return '';
    } else if (parentPath && !currentRoute.path) {
      return `${parentPath}/`;
    } else if (!parentPath && currentRoute.path) {
      return currentRoute.path;
    } else {
      return `${parentPath}/${currentRoute.path}`;
    }
  }
  function standardizeConfig(r) {
    const children = r.children && r.children.map(standardizeConfig);
    const c = children ? Object.assign(Object.assign({}, r), {children}) : Object.assign({}, r);
    if (!c.component && (children || c.loadChildren) && (c.outlet && c.outlet !== PRIMARY_OUTLET)) {
      c.component = \u0275EmptyOutletComponent;
    }
    return c;
  }
  function getOutlet(route) {
    return route.outlet || PRIMARY_OUTLET;
  }
  function sortByMatchingOutlets(routes2, outletName) {
    const sortedConfig = routes2.filter((r) => getOutlet(r) === outletName);
    sortedConfig.push(...routes2.filter((r) => getOutlet(r) !== outletName));
    return sortedConfig;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var noMatch = {
    matched: false,
    consumedSegments: [],
    lastChild: 0,
    parameters: {},
    positionalParamSegments: {}
  };
  function match(segmentGroup, route, segments) {
    var _a;
    if (route.path === '') {
      if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {
        return Object.assign({}, noMatch);
      }
      return {
        matched: true,
        consumedSegments: [],
        lastChild: 0,
        parameters: {},
        positionalParamSegments: {}
      };
    }
    const matcher = route.matcher || defaultUrlMatcher;
    const res = matcher(segments, segmentGroup, route);
    if (!res) return Object.assign({}, noMatch);
    const posParams = {};
    forEach(res.posParams, (v, k) => {
      posParams[k] = v.path;
    });
    const parameters = res.consumed.length > 0 ?
        Object.assign(
            Object.assign({}, posParams), res.consumed[res.consumed.length - 1].parameters) :
        posParams;
    return {
      matched: true,
      consumedSegments: res.consumed,
      lastChild: res.consumed.length,
      parameters,
      positionalParamSegments: (_a = res.posParams) !== null && _a !== void 0 ? _a : {}
    };
  }
  function split(
      segmentGroup, consumedSegments, slicedSegments, config2,
      relativeLinkResolution = 'corrected') {
    if (slicedSegments.length > 0 &&
        containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config2)) {
      const s2 = new UrlSegmentGroup(
          consumedSegments,
          createChildrenForEmptyPaths(
              segmentGroup, consumedSegments, config2,
              new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
      s2._sourceSegment = segmentGroup;
      s2._segmentIndexShift = consumedSegments.length;
      return {segmentGroup: s2, slicedSegments: []};
    }
    if (slicedSegments.length === 0 &&
        containsEmptyPathMatches(segmentGroup, slicedSegments, config2)) {
      const s2 = new UrlSegmentGroup(
          segmentGroup.segments,
          addEmptyPathsToChildrenIfNeeded(
              segmentGroup, consumedSegments, slicedSegments, config2, segmentGroup.children,
              relativeLinkResolution));
      s2._sourceSegment = segmentGroup;
      s2._segmentIndexShift = consumedSegments.length;
      return {segmentGroup: s2, slicedSegments};
    }
    const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
    s._sourceSegment = segmentGroup;
    s._segmentIndexShift = consumedSegments.length;
    return {segmentGroup: s, slicedSegments};
  }
  function addEmptyPathsToChildrenIfNeeded(
      segmentGroup, consumedSegments, slicedSegments, routes2, children, relativeLinkResolution) {
    const res = {};
    for (const r of routes2) {
      if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {
        const s = new UrlSegmentGroup([], {});
        s._sourceSegment = segmentGroup;
        if (relativeLinkResolution === 'legacy') {
          s._segmentIndexShift = segmentGroup.segments.length;
        } else {
          s._segmentIndexShift = consumedSegments.length;
        }
        res[getOutlet(r)] = s;
      }
    }
    return Object.assign(Object.assign({}, children), res);
  }
  function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes2, primarySegment) {
    const res = {};
    res[PRIMARY_OUTLET] = primarySegment;
    primarySegment._sourceSegment = segmentGroup;
    primarySegment._segmentIndexShift = consumedSegments.length;
    for (const r of routes2) {
      if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {
        const s = new UrlSegmentGroup([], {});
        s._sourceSegment = segmentGroup;
        s._segmentIndexShift = consumedSegments.length;
        res[getOutlet(r)] = s;
      }
    }
    return res;
  }
  function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes2) {
    return routes2.some(
        (r) => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);
  }
  function containsEmptyPathMatches(segmentGroup, slicedSegments, routes2) {
    return routes2.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r));
  }
  function emptyPathMatch(segmentGroup, slicedSegments, r) {
    if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {
      return false;
    }
    return r.path === '';
  }
  function isImmediateMatch(route, rawSegment, segments, outlet) {
    if (getOutlet(route) !== outlet &&
        (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {
      return false;
    }
    if (route.path === '**') {
      return true;
    }
    return match(rawSegment, route, segments).matched;
  }
  function noLeftoversInUrl(segmentGroup, segments, outlet) {
    return segments.length === 0 && !segmentGroup.children[outlet];
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NoMatch = class {
    constructor(segmentGroup) {
      this.segmentGroup = segmentGroup || null;
    }
  };
  var AbsoluteRedirect = class {
    constructor(urlTree) {
      this.urlTree = urlTree;
    }
  };
  function noMatch$1(segmentGroup) {
    return new Observable((obs) => obs.error(new NoMatch(segmentGroup)));
  }
  function absoluteRedirect(newTree) {
    return new Observable((obs) => obs.error(new AbsoluteRedirect(newTree)));
  }
  function namedOutletsRedirect(redirectTo) {
    return new Observable(
        (obs) => obs.error(new Error(
            `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`)));
  }
  function canLoadFails(route) {
    return new Observable(
        (obs) => obs.error(
            navigationCancelingError(`Cannot load children because the guard of the route "path: '${
                route.path}'" returned false`)));
  }
  function applyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config2) {
    return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config2)
        .apply();
  }
  var ApplyRedirects = class {
    constructor(moduleInjector, configLoader, urlSerializer, urlTree, config2) {
      this.configLoader = configLoader;
      this.urlSerializer = urlSerializer;
      this.urlTree = urlTree;
      this.config = config2;
      this.allowRedirects = true;
      this.ngModule = moduleInjector.get(NgModuleRef);
    }
    apply() {
      const splitGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;
      const rootSegmentGroup = new UrlSegmentGroup(splitGroup.segments, splitGroup.children);
      const expanded$ =
          this.expandSegmentGroup(this.ngModule, this.config, rootSegmentGroup, PRIMARY_OUTLET);
      const urlTrees$ = expanded$.pipe(map((rootSegmentGroup2) => {
        return this.createUrlTree(
            squashSegmentGroup(rootSegmentGroup2), this.urlTree.queryParams, this.urlTree.fragment);
      }));
      return urlTrees$.pipe(catchError((e) => {
        if (e instanceof AbsoluteRedirect) {
          this.allowRedirects = false;
          return this.match(e.urlTree);
        }
        if (e instanceof NoMatch) {
          throw this.noMatchError(e);
        }
        throw e;
      }));
    }
    match(tree2) {
      const expanded$ =
          this.expandSegmentGroup(this.ngModule, this.config, tree2.root, PRIMARY_OUTLET);
      const mapped$ = expanded$.pipe(map((rootSegmentGroup) => {
        return this.createUrlTree(
            squashSegmentGroup(rootSegmentGroup), tree2.queryParams, tree2.fragment);
      }));
      return mapped$.pipe(catchError((e) => {
        if (e instanceof NoMatch) {
          throw this.noMatchError(e);
        }
        throw e;
      }));
    }
    noMatchError(e) {
      return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`);
    }
    createUrlTree(rootCandidate, queryParams, fragment) {
      const root = rootCandidate.segments.length > 0 ?
          new UrlSegmentGroup([], {[PRIMARY_OUTLET]: rootCandidate}) :
          rootCandidate;
      return new UrlTree(root, queryParams, fragment);
    }
    expandSegmentGroup(ngModule, routes2, segmentGroup, outlet) {
      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
        return this.expandChildren(ngModule, routes2, segmentGroup)
            .pipe(map((children) => new UrlSegmentGroup([], children)));
      }
      return this.expandSegment(
          ngModule, segmentGroup, routes2, segmentGroup.segments, outlet, true);
    }
    expandChildren(ngModule, routes2, segmentGroup) {
      const childOutlets = [];
      for (const child of Object.keys(segmentGroup.children)) {
        if (child === 'primary') {
          childOutlets.unshift(child);
        } else {
          childOutlets.push(child);
        }
      }
      return from(childOutlets)
          .pipe(
              concatMap((childOutlet) => {
                const child = segmentGroup.children[childOutlet];
                const sortedRoutes = sortByMatchingOutlets(routes2, childOutlet);
                return this.expandSegmentGroup(ngModule, sortedRoutes, child, childOutlet)
                    .pipe(map((s) => ({segment: s, outlet: childOutlet})));
              }),
              scan((children, expandedChild) => {
                children[expandedChild.outlet] = expandedChild.segment;
                return children;
              }, {}), last());
    }
    expandSegment(ngModule, segmentGroup, routes2, segments, outlet, allowRedirects) {
      return from(routes2).pipe(
          concatMap((r) => {
            const expanded$ = this.expandSegmentAgainstRoute(
                ngModule, segmentGroup, routes2, r, segments, outlet, allowRedirects);
            return expanded$.pipe(catchError((e) => {
              if (e instanceof NoMatch) {
                return of(null);
              }
              throw e;
            }));
          }),
          first((s) => !!s), catchError((e, _) => {
            if (e instanceof EmptyError || e.name === 'EmptyError') {
              if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
                return of(new UrlSegmentGroup([], {}));
              }
              throw new NoMatch(segmentGroup);
            }
            throw e;
          }));
    }
    expandSegmentAgainstRoute(
        ngModule, segmentGroup, routes2, route, paths, outlet, allowRedirects) {
      if (!isImmediateMatch(route, segmentGroup, paths, outlet)) {
        return noMatch$1(segmentGroup);
      }
      if (route.redirectTo === void 0) {
        return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths, outlet);
      }
      if (allowRedirects && this.allowRedirects) {
        return this.expandSegmentAgainstRouteUsingRedirect(
            ngModule, segmentGroup, routes2, route, paths, outlet);
      }
      return noMatch$1(segmentGroup);
    }
    expandSegmentAgainstRouteUsingRedirect(
        ngModule, segmentGroup, routes2, route, segments, outlet) {
      if (route.path === '**') {
        return this.expandWildCardWithParamsAgainstRouteUsingRedirect(
            ngModule, routes2, route, outlet);
      }
      return this.expandRegularSegmentAgainstRouteUsingRedirect(
          ngModule, segmentGroup, routes2, route, segments, outlet);
    }
    expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes2, route, outlet) {
      const newTree = this.applyRedirectCommands([], route.redirectTo, {});
      if (route.redirectTo.startsWith('/')) {
        return absoluteRedirect(newTree);
      }
      return this.lineralizeSegments(route, newTree).pipe(mergeMap((newSegments) => {
        const group = new UrlSegmentGroup(newSegments, {});
        return this.expandSegment(ngModule, group, routes2, newSegments, outlet, false);
      }));
    }
    expandRegularSegmentAgainstRouteUsingRedirect(
        ngModule, segmentGroup, routes2, route, segments, outlet) {
      const {matched, consumedSegments, lastChild, positionalParamSegments} =
          match(segmentGroup, route, segments);
      if (!matched) return noMatch$1(segmentGroup);
      const newTree =
          this.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments);
      if (route.redirectTo.startsWith('/')) {
        return absoluteRedirect(newTree);
      }
      return this.lineralizeSegments(route, newTree).pipe(mergeMap((newSegments) => {
        return this.expandSegment(
            ngModule, segmentGroup, routes2, newSegments.concat(segments.slice(lastChild)), outlet,
            false);
      }));
    }
    matchSegmentAgainstRoute(ngModule, rawSegmentGroup, route, segments, outlet) {
      if (route.path === '**') {
        if (route.loadChildren) {
          return this.configLoader.load(ngModule.injector, route).pipe(map((cfg) => {
            route._loadedConfig = cfg;
            return new UrlSegmentGroup(segments, {});
          }));
        }
        return of(new UrlSegmentGroup(segments, {}));
      }
      const {matched, consumedSegments, lastChild} = match(rawSegmentGroup, route, segments);
      if (!matched) return noMatch$1(rawSegmentGroup);
      const rawSlicedSegments = segments.slice(lastChild);
      const childConfig$ = this.getChildConfig(ngModule, route, segments);
      return childConfig$.pipe(mergeMap((routerConfig) => {
        const childModule = routerConfig.module;
        const childConfig = routerConfig.routes;
        const {segmentGroup: splitSegmentGroup, slicedSegments} =
            split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig);
        const segmentGroup =
            new UrlSegmentGroup(splitSegmentGroup.segments, splitSegmentGroup.children);
        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
          const expanded$2 = this.expandChildren(childModule, childConfig, segmentGroup);
          return expanded$2.pipe(
              map((children) => new UrlSegmentGroup(consumedSegments, children)));
        }
        if (childConfig.length === 0 && slicedSegments.length === 0) {
          return of(new UrlSegmentGroup(consumedSegments, {}));
        }
        const matchedOnOutlet = getOutlet(route) === outlet;
        const expanded$ = this.expandSegment(
            childModule, segmentGroup, childConfig, slicedSegments,
            matchedOnOutlet ? PRIMARY_OUTLET : outlet, true);
        return expanded$.pipe(
            map((cs) => new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children)));
      }));
    }
    getChildConfig(ngModule, route, segments) {
      if (route.children) {
        return of(new LoadedRouterConfig(route.children, ngModule));
      }
      if (route.loadChildren) {
        if (route._loadedConfig !== void 0) {
          return of(route._loadedConfig);
        }
        return this.runCanLoadGuards(ngModule.injector, route, segments)
            .pipe(mergeMap((shouldLoadResult) => {
              if (shouldLoadResult) {
                return this.configLoader.load(ngModule.injector, route).pipe(map((cfg) => {
                  route._loadedConfig = cfg;
                  return cfg;
                }));
              }
              return canLoadFails(route);
            }));
      }
      return of(new LoadedRouterConfig([], ngModule));
    }
    runCanLoadGuards(moduleInjector, route, segments) {
      const canLoad = route.canLoad;
      if (!canLoad || canLoad.length === 0) return of(true);
      const canLoadObservables = canLoad.map((injectionToken) => {
        const guard = moduleInjector.get(injectionToken);
        let guardVal;
        if (isCanLoad(guard)) {
          guardVal = guard.canLoad(route, segments);
        } else if (isFunction2(guard)) {
          guardVal = guard(route, segments);
        } else {
          throw new Error('Invalid CanLoad guard');
        }
        return wrapIntoObservable(guardVal);
      });
      return of(canLoadObservables)
          .pipe(
              prioritizedGuardValue(), tap((result) => {
                if (!isUrlTree(result)) return;
                const error = navigationCancelingError(
                    `Redirecting to "${this.urlSerializer.serialize(result)}"`);
                error.url = result;
                throw error;
              }),
              map((result) => result === true));
    }
    lineralizeSegments(route, urlTree) {
      let res = [];
      let c = urlTree.root;
      while (true) {
        res = res.concat(c.segments);
        if (c.numberOfChildren === 0) {
          return of(res);
        }
        if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
          return namedOutletsRedirect(route.redirectTo);
        }
        c = c.children[PRIMARY_OUTLET];
      }
    }
    applyRedirectCommands(segments, redirectTo, posParams) {
      return this.applyRedirectCreatreUrlTree(
          redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);
    }
    applyRedirectCreatreUrlTree(redirectTo, urlTree, segments, posParams) {
      const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
      return new UrlTree(
          newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams),
          urlTree.fragment);
    }
    createQueryParams(redirectToParams, actualParams) {
      const res = {};
      forEach(redirectToParams, (v, k) => {
        const copySourceValue = typeof v === 'string' && v.startsWith(':');
        if (copySourceValue) {
          const sourceName = v.substring(1);
          res[k] = actualParams[sourceName];
        } else {
          res[k] = v;
        }
      });
      return res;
    }
    createSegmentGroup(redirectTo, group, segments, posParams) {
      const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
      let children = {};
      forEach(group.children, (child, name) => {
        children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);
      });
      return new UrlSegmentGroup(updatedSegments, children);
    }
    createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {
      return redirectToSegments.map(
          (s) => s.path.startsWith(':') ? this.findPosParam(redirectTo, s, posParams) :
                                          this.findOrReturn(s, actualSegments));
    }
    findPosParam(redirectTo, redirectToUrlSegment, posParams) {
      const pos = posParams[redirectToUrlSegment.path.substring(1)];
      if (!pos)
        throw new Error(
            `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);
      return pos;
    }
    findOrReturn(redirectToUrlSegment, actualSegments) {
      let idx = 0;
      for (const s of actualSegments) {
        if (s.path === redirectToUrlSegment.path) {
          actualSegments.splice(idx);
          return s;
        }
        idx++;
      }
      return redirectToUrlSegment;
    }
  };
  function mergeTrivialChildren(s) {
    if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {
      const c = s.children[PRIMARY_OUTLET];
      return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
    }
    return s;
  }
  function squashSegmentGroup(segmentGroup) {
    const newChildren = {};
    for (const childOutlet of Object.keys(segmentGroup.children)) {
      const child = segmentGroup.children[childOutlet];
      const childCandidate = squashSegmentGroup(child);
      if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {
        newChildren[childOutlet] = childCandidate;
      }
    }
    const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);
    return mergeTrivialChildren(s);
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function applyRedirects$1(moduleInjector, configLoader, urlSerializer, config2) {
    return switchMap(
        (t) => applyRedirects(moduleInjector, configLoader, urlSerializer, t.extractedUrl, config2)
                   .pipe(
                       map((urlAfterRedirects) =>
                               Object.assign(Object.assign({}, t), {urlAfterRedirects}))));
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var CanActivate = class {
    constructor(path) {
      this.path = path;
      this.route = this.path[this.path.length - 1];
    }
  };
  var CanDeactivate = class {
    constructor(component, route) {
      this.component = component;
      this.route = route;
    }
  };
  function getAllRouteGuards(future, curr, parentContexts) {
    const futureRoot = future._root;
    const currRoot = curr ? curr._root : null;
    return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);
  }
  function getCanActivateChild(p) {
    const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;
    if (!canActivateChild || canActivateChild.length === 0) return null;
    return {node: p, guards: canActivateChild};
  }
  function getToken(token, snapshot, moduleInjector) {
    const config2 = getClosestLoadedConfig(snapshot);
    const injector = config2 ? config2.module.injector : moduleInjector;
    return injector.get(token);
  }
  function getClosestLoadedConfig(snapshot) {
    if (!snapshot) return null;
    for (let s = snapshot.parent; s; s = s.parent) {
      const route = s.routeConfig;
      if (route && route._loadedConfig) return route._loadedConfig;
    }
    return null;
  }
  function getChildRouteGuards(
      futureNode, currNode, contexts, futurePath,
      checks = {canDeactivateChecks: [], canActivateChecks: []}) {
    const prevChildren = nodeChildrenAsMap(currNode);
    futureNode.children.forEach((c) => {
      getRouteGuards(
          c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);
      delete prevChildren[c.value.outlet];
    });
    forEach(
        prevChildren, (v, k) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));
    return checks;
  }
  function getRouteGuards(
      futureNode, currNode, parentContexts, futurePath,
      checks = {canDeactivateChecks: [], canActivateChecks: []}) {
    const future = futureNode.value;
    const curr = currNode ? currNode.value : null;
    const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
    if (curr && future.routeConfig === curr.routeConfig) {
      const shouldRun =
          shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);
      if (shouldRun) {
        checks.canActivateChecks.push(new CanActivate(futurePath));
      } else {
        future.data = curr.data;
        future._resolvedData = curr._resolvedData;
      }
      if (future.component) {
        getChildRouteGuards(
            futureNode, currNode, context ? context.children : null, futurePath, checks);
      } else {
        getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);
      }
      if (shouldRun && context && context.outlet && context.outlet.isActivated) {
        checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));
      }
    } else {
      if (curr) {
        deactivateRouteAndItsChildren(currNode, context, checks);
      }
      checks.canActivateChecks.push(new CanActivate(futurePath));
      if (future.component) {
        getChildRouteGuards(
            futureNode, null, context ? context.children : null, futurePath, checks);
      } else {
        getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);
      }
    }
    return checks;
  }
  function shouldRunGuardsAndResolvers(curr, future, mode) {
    if (typeof mode === 'function') {
      return mode(curr, future);
    }
    switch (mode) {
      case 'pathParamsChange':
        return !equalPath(curr.url, future.url);
      case 'pathParamsOrQueryParamsChange':
        return !equalPath(curr.url, future.url) ||
            !shallowEqual(curr.queryParams, future.queryParams);
      case 'always':
        return true;
      case 'paramsOrQueryParamsChange':
        return !equalParamsAndUrlSegments(curr, future) ||
            !shallowEqual(curr.queryParams, future.queryParams);
      case 'paramsChange':
      default:
        return !equalParamsAndUrlSegments(curr, future);
    }
  }
  function deactivateRouteAndItsChildren(route, context, checks) {
    const children = nodeChildrenAsMap(route);
    const r = route.value;
    forEach(children, (node, childName) => {
      if (!r.component) {
        deactivateRouteAndItsChildren(node, context, checks);
      } else if (context) {
        deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);
      } else {
        deactivateRouteAndItsChildren(node, null, checks);
      }
    });
    if (!r.component) {
      checks.canDeactivateChecks.push(new CanDeactivate(null, r));
    } else if (context && context.outlet && context.outlet.isActivated) {
      checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));
    } else {
      checks.canDeactivateChecks.push(new CanDeactivate(null, r));
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function checkGuards(moduleInjector, forwardEvent) {
    return mergeMap((t) => {
      const {targetSnapshot, currentSnapshot, guards: {canActivateChecks, canDeactivateChecks}} = t;
      if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {
        return of(Object.assign(Object.assign({}, t), {guardsResult: true}));
      }
      return runCanDeactivateChecks(
                 canDeactivateChecks, targetSnapshot, currentSnapshot, moduleInjector)
          .pipe(
              mergeMap((canDeactivate) => {
                return canDeactivate && isBoolean(canDeactivate) ?
                    runCanActivateChecks(
                        targetSnapshot, canActivateChecks, moduleInjector, forwardEvent) :
                    of(canDeactivate);
              }),
              map((guardsResult) => Object.assign(Object.assign({}, t), {guardsResult})));
    });
  }
  function runCanDeactivateChecks(checks, futureRSS, currRSS, moduleInjector) {
    return from(checks).pipe(
        mergeMap(
            (check) =>
                runCanDeactivate(check.component, check.route, currRSS, futureRSS, moduleInjector)),
        first((result) => {
          return result !== true;
        }, true));
  }
  function runCanActivateChecks(futureSnapshot, checks, moduleInjector, forwardEvent) {
    return from(checks).pipe(
        concatMap((check) => {
          return concat(
              fireChildActivationStart(check.route.parent, forwardEvent),
              fireActivationStart(check.route, forwardEvent),
              runCanActivateChild(futureSnapshot, check.path, moduleInjector),
              runCanActivate(futureSnapshot, check.route, moduleInjector));
        }),
        first((result) => {
          return result !== true;
        }, true));
  }
  function fireActivationStart(snapshot, forwardEvent) {
    if (snapshot !== null && forwardEvent) {
      forwardEvent(new ActivationStart(snapshot));
    }
    return of(true);
  }
  function fireChildActivationStart(snapshot, forwardEvent) {
    if (snapshot !== null && forwardEvent) {
      forwardEvent(new ChildActivationStart(snapshot));
    }
    return of(true);
  }
  function runCanActivate(futureRSS, futureARS, moduleInjector) {
    const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;
    if (!canActivate || canActivate.length === 0) return of(true);
    const canActivateObservables = canActivate.map((c) => {
      return defer(() => {
        const guard = getToken(c, futureARS, moduleInjector);
        let observable2;
        if (isCanActivate(guard)) {
          observable2 = wrapIntoObservable(guard.canActivate(futureARS, futureRSS));
        } else if (isFunction2(guard)) {
          observable2 = wrapIntoObservable(guard(futureARS, futureRSS));
        } else {
          throw new Error('Invalid CanActivate guard');
        }
        return observable2.pipe(first());
      });
    });
    return of(canActivateObservables).pipe(prioritizedGuardValue());
  }
  function runCanActivateChild(futureRSS, path, moduleInjector) {
    const futureARS = path[path.length - 1];
    const canActivateChildGuards = path.slice(0, path.length - 1)
                                       .reverse()
                                       .map((p) => getCanActivateChild(p))
                                       .filter((_) => _ !== null);
    const canActivateChildGuardsMapped = canActivateChildGuards.map((d) => {
      return defer(() => {
        const guardsMapped = d.guards.map((c) => {
          const guard = getToken(c, d.node, moduleInjector);
          let observable2;
          if (isCanActivateChild(guard)) {
            observable2 = wrapIntoObservable(guard.canActivateChild(futureARS, futureRSS));
          } else if (isFunction2(guard)) {
            observable2 = wrapIntoObservable(guard(futureARS, futureRSS));
          } else {
            throw new Error('Invalid CanActivateChild guard');
          }
          return observable2.pipe(first());
        });
        return of(guardsMapped).pipe(prioritizedGuardValue());
      });
    });
    return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());
  }
  function runCanDeactivate(component, currARS, currRSS, futureRSS, moduleInjector) {
    const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;
    if (!canDeactivate || canDeactivate.length === 0) return of(true);
    const canDeactivateObservables = canDeactivate.map((c) => {
      const guard = getToken(c, currARS, moduleInjector);
      let observable2;
      if (isCanDeactivate(guard)) {
        observable2 =
            wrapIntoObservable(guard.canDeactivate(component, currARS, currRSS, futureRSS));
      } else if (isFunction2(guard)) {
        observable2 = wrapIntoObservable(guard(component, currARS, currRSS, futureRSS));
      } else {
        throw new Error('Invalid CanDeactivate guard');
      }
      return observable2.pipe(first());
    });
    return of(canDeactivateObservables).pipe(prioritizedGuardValue());
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var NoMatch$1 = class {};
  function newObservableError(e) {
    return new Observable((obs) => obs.error(e));
  }
  function recognize(
      rootComponentType, config2, urlTree, url, paramsInheritanceStrategy = 'emptyOnly',
      relativeLinkResolution = 'legacy') {
    try {
      const result = new Recognizer(
                         rootComponentType, config2, urlTree, url, paramsInheritanceStrategy,
                         relativeLinkResolution)
                         .recognize();
      if (result === null) {
        return newObservableError(new NoMatch$1());
      } else {
        return of(result);
      }
    } catch (e) {
      return newObservableError(e);
    }
  }
  var Recognizer = class {
    constructor(
        rootComponentType, config2, urlTree, url, paramsInheritanceStrategy,
        relativeLinkResolution) {
      this.rootComponentType = rootComponentType;
      this.config = config2;
      this.urlTree = urlTree;
      this.url = url;
      this.paramsInheritanceStrategy = paramsInheritanceStrategy;
      this.relativeLinkResolution = relativeLinkResolution;
    }
    recognize() {
      const rootSegmentGroup =
          split(
              this.urlTree.root, [], [], this.config.filter((c) => c.redirectTo === void 0),
              this.relativeLinkResolution)
              .segmentGroup;
      const children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);
      if (children === null) {
        return null;
      }
      const root = new ActivatedRouteSnapshot(
          [], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)),
          this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null,
          this.urlTree.root, -1, {});
      const rootNode = new TreeNode(root, children);
      const routeState = new RouterStateSnapshot(this.url, rootNode);
      this.inheritParamsAndData(routeState._root);
      return routeState;
    }
    inheritParamsAndData(routeNode) {
      const route = routeNode.value;
      const i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);
      route.params = Object.freeze(i.params);
      route.data = Object.freeze(i.data);
      routeNode.children.forEach((n) => this.inheritParamsAndData(n));
    }
    processSegmentGroup(config2, segmentGroup, outlet) {
      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
        return this.processChildren(config2, segmentGroup);
      }
      return this.processSegment(config2, segmentGroup, segmentGroup.segments, outlet);
    }
    processChildren(config2, segmentGroup) {
      const children = [];
      for (const childOutlet of Object.keys(segmentGroup.children)) {
        const child = segmentGroup.children[childOutlet];
        const sortedConfig = sortByMatchingOutlets(config2, childOutlet);
        const outletChildren = this.processSegmentGroup(sortedConfig, child, childOutlet);
        if (outletChildren === null) {
          return null;
        }
        children.push(...outletChildren);
      }
      const mergedChildren = mergeEmptyPathMatches(children);
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        checkOutletNameUniqueness(mergedChildren);
      }
      sortActivatedRouteSnapshots(mergedChildren);
      return mergedChildren;
    }
    processSegment(config2, segmentGroup, segments, outlet) {
      for (const r of config2) {
        const children = this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);
        if (children !== null) {
          return children;
        }
      }
      if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
        return [];
      }
      return null;
    }
    processSegmentAgainstRoute(route, rawSegment, segments, outlet) {
      if (route.redirectTo || !isImmediateMatch(route, rawSegment, segments, outlet)) return null;
      let snapshot;
      let consumedSegments = [];
      let rawSlicedSegments = [];
      if (route.path === '**') {
        const params = segments.length > 0 ? last2(segments).parameters : {};
        snapshot = new ActivatedRouteSnapshot(
            segments, params, Object.freeze(Object.assign({}, this.urlTree.queryParams)),
            this.urlTree.fragment, getData(route), getOutlet(route), route.component, route,
            getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length,
            getResolve(route));
      } else {
        const result = match(rawSegment, route, segments);
        if (!result.matched) {
          return null;
        }
        consumedSegments = result.consumedSegments;
        rawSlicedSegments = segments.slice(result.lastChild);
        snapshot = new ActivatedRouteSnapshot(
            consumedSegments, result.parameters,
            Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment,
            getData(route), getOutlet(route), route.component, route,
            getSourceSegmentGroup(rawSegment),
            getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));
      }
      const childConfig = getChildConfig(route);
      const {segmentGroup, slicedSegments} = split(
          rawSegment, consumedSegments, rawSlicedSegments,
          childConfig.filter((c) => c.redirectTo === void 0), this.relativeLinkResolution);
      if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
        const children2 = this.processChildren(childConfig, segmentGroup);
        if (children2 === null) {
          return null;
        }
        return [new TreeNode(snapshot, children2)];
      }
      if (childConfig.length === 0 && slicedSegments.length === 0) {
        return [new TreeNode(snapshot, [])];
      }
      const matchedOnOutlet = getOutlet(route) === outlet;
      const children = this.processSegment(
          childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet);
      if (children === null) {
        return null;
      }
      return [new TreeNode(snapshot, children)];
    }
  };
  function sortActivatedRouteSnapshots(nodes) {
    nodes.sort((a, b) => {
      if (a.value.outlet === PRIMARY_OUTLET) return -1;
      if (b.value.outlet === PRIMARY_OUTLET) return 1;
      return a.value.outlet.localeCompare(b.value.outlet);
    });
  }
  function getChildConfig(route) {
    if (route.children) {
      return route.children;
    }
    if (route.loadChildren) {
      return route._loadedConfig.routes;
    }
    return [];
  }
  function hasEmptyPathConfig(node) {
    const config2 = node.value.routeConfig;
    return config2 && config2.path === '' && config2.redirectTo === void 0;
  }
  function mergeEmptyPathMatches(nodes) {
    const result = [];
    for (const node of nodes) {
      if (!hasEmptyPathConfig(node)) {
        result.push(node);
        continue;
      }
      const duplicateEmptyPathNode =
          result.find((resultNode) => node.value.routeConfig === resultNode.value.routeConfig);
      if (duplicateEmptyPathNode !== void 0) {
        duplicateEmptyPathNode.children.push(...node.children);
      } else {
        result.push(node);
      }
    }
    return result;
  }
  function checkOutletNameUniqueness(nodes) {
    const names = {};
    nodes.forEach((n) => {
      const routeWithSameOutletName = names[n.value.outlet];
      if (routeWithSameOutletName) {
        const p = routeWithSameOutletName.url.map((s) => s.toString()).join('/');
        const c = n.value.url.map((s) => s.toString()).join('/');
        throw new Error(`Two segments cannot have the same outlet name: '${p}' and '${c}'.`);
      }
      names[n.value.outlet] = n.value;
    });
  }
  function getSourceSegmentGroup(segmentGroup) {
    let s = segmentGroup;
    while (s._sourceSegment) {
      s = s._sourceSegment;
    }
    return s;
  }
  function getPathIndexShift(segmentGroup) {
    let s = segmentGroup;
    let res = s._segmentIndexShift ? s._segmentIndexShift : 0;
    while (s._sourceSegment) {
      s = s._sourceSegment;
      res += s._segmentIndexShift ? s._segmentIndexShift : 0;
    }
    return res - 1;
  }
  function getData(route) {
    return route.data || {};
  }
  function getResolve(route) {
    return route.resolve || {};
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function recognize$1(
      rootComponentType, config2, serializer, paramsInheritanceStrategy, relativeLinkResolution) {
    return mergeMap(
        (t) => recognize(
                   rootComponentType, config2, t.urlAfterRedirects, serializer(t.urlAfterRedirects),
                   paramsInheritanceStrategy, relativeLinkResolution)
                   .pipe(map(
                       (targetSnapshot) => Object.assign(Object.assign({}, t), {targetSnapshot}))));
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function resolveData(paramsInheritanceStrategy, moduleInjector) {
    return mergeMap((t) => {
      const {targetSnapshot, guards: {canActivateChecks}} = t;
      if (!canActivateChecks.length) {
        return of(t);
      }
      let canActivateChecksResolved = 0;
      return from(canActivateChecks)
          .pipe(
              concatMap(
                  (check) => runResolve(
                      check.route, targetSnapshot, paramsInheritanceStrategy, moduleInjector)),
              tap(() => canActivateChecksResolved++), takeLast(1),
              mergeMap(
                  (_) => canActivateChecksResolved === canActivateChecks.length ? of(t) : EMPTY));
    });
  }
  function runResolve(futureARS, futureRSS, paramsInheritanceStrategy, moduleInjector) {
    const resolve = futureARS._resolve;
    return resolveNode(resolve, futureARS, futureRSS, moduleInjector).pipe(map((resolvedData) => {
      futureARS._resolvedData = resolvedData;
      futureARS.data = Object.assign(
          Object.assign({}, futureARS.data),
          inheritedParamsDataResolve(futureARS, paramsInheritanceStrategy).resolve);
      return null;
    }));
  }
  function resolveNode(resolve, futureARS, futureRSS, moduleInjector) {
    const keys = Object.keys(resolve);
    if (keys.length === 0) {
      return of({});
    }
    const data = {};
    return from(keys).pipe(
        mergeMap(
            (key) => getResolver(resolve[key], futureARS, futureRSS, moduleInjector)
                         .pipe(tap((value) => {
                           data[key] = value;
                         }))),
        takeLast(1), mergeMap(() => {
          if (Object.keys(data).length === keys.length) {
            return of(data);
          }
          return EMPTY;
        }));
  }
  function getResolver(injectionToken, futureARS, futureRSS, moduleInjector) {
    const resolver = getToken(injectionToken, futureARS, moduleInjector);
    return resolver.resolve ? wrapIntoObservable(resolver.resolve(futureARS, futureRSS)) :
                              wrapIntoObservable(resolver(futureARS, futureRSS));
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function switchTap(next) {
    return switchMap((v) => {
      const nextResult = next(v);
      if (nextResult) {
        return from(nextResult).pipe(map(() => v));
      }
      return of(v);
    });
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var RouteReuseStrategy = class {};
  var BaseRouteReuseStrategy = class {
    shouldDetach(route) {
      return false;
    }
    store(route, detachedTree) {}
    shouldAttach(route) {
      return false;
    }
    retrieve(route) {
      return null;
    }
    shouldReuseRoute(future, curr) {
      return future.routeConfig === curr.routeConfig;
    }
  };
  var DefaultRouteReuseStrategy = class extends BaseRouteReuseStrategy {};
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ROUTES = new InjectionToken('ROUTES');
  var RouterConfigLoader = class {
    constructor(loader, compiler, onLoadStartListener, onLoadEndListener) {
      this.loader = loader;
      this.compiler = compiler;
      this.onLoadStartListener = onLoadStartListener;
      this.onLoadEndListener = onLoadEndListener;
    }
    load(parentInjector, route) {
      if (this.onLoadStartListener) {
        this.onLoadStartListener(route);
      }
      const moduleFactory$ = this.loadModuleFactory(route.loadChildren);
      return moduleFactory$.pipe(map((factory) => {
        if (this.onLoadEndListener) {
          this.onLoadEndListener(route);
        }
        const module = factory.create(parentInjector);
        return new LoadedRouterConfig(
            flatten2(module.injector.get(ROUTES)).map(standardizeConfig), module);
      }));
    }
    loadModuleFactory(loadChildren) {
      if (typeof loadChildren === 'string') {
        return from(this.loader.load(loadChildren));
      } else {
        return wrapIntoObservable(loadChildren()).pipe(mergeMap((t) => {
          if (t instanceof NgModuleFactory) {
            return of(t);
          } else {
            return from(this.compiler.compileModuleAsync(t));
          }
        }));
      }
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var OutletContext = class {
    constructor() {
      this.outlet = null;
      this.route = null;
      this.resolver = null;
      this.children = new ChildrenOutletContexts();
      this.attachRef = null;
    }
  };
  var ChildrenOutletContexts = class {
    constructor() {
      this.contexts = new Map();
    }
    onChildOutletCreated(childName, outlet) {
      const context = this.getOrCreateContext(childName);
      context.outlet = outlet;
      this.contexts.set(childName, context);
    }
    onChildOutletDestroyed(childName) {
      const context = this.getContext(childName);
      if (context) {
        context.outlet = null;
      }
    }
    onOutletDeactivated() {
      const contexts = this.contexts;
      this.contexts = new Map();
      return contexts;
    }
    onOutletReAttached(contexts) {
      this.contexts = contexts;
    }
    getOrCreateContext(childName) {
      let context = this.getContext(childName);
      if (!context) {
        context = new OutletContext();
        this.contexts.set(childName, context);
      }
      return context;
    }
    getContext(childName) {
      return this.contexts.get(childName) || null;
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var UrlHandlingStrategy = class {};
  var DefaultUrlHandlingStrategy = class {
    shouldProcessUrl(url) {
      return true;
    }
    extract(url) {
      return url;
    }
    merge(newUrlPart, wholeUrl) {
      return newUrlPart;
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function defaultErrorHandler(error) {
    throw error;
  }
  function defaultMalformedUriErrorHandler(error, urlSerializer, url) {
    return urlSerializer.parse('/');
  }
  function defaultRouterHook(snapshot, runExtras) {
    return of(null);
  }
  var Router = class {
    constructor(
        rootComponentType, urlSerializer, rootContexts, location2, injector, loader, compiler,
        config2) {
      this.rootComponentType = rootComponentType;
      this.urlSerializer = urlSerializer;
      this.rootContexts = rootContexts;
      this.location = location2;
      this.config = config2;
      this.lastSuccessfulNavigation = null;
      this.currentNavigation = null;
      this.lastLocationChangeInfo = null;
      this.navigationId = 0;
      this.isNgZoneEnabled = false;
      this.events = new Subject();
      this.errorHandler = defaultErrorHandler;
      this.malformedUriErrorHandler = defaultMalformedUriErrorHandler;
      this.navigated = false;
      this.lastSuccessfulId = -1;
      this.hooks = {beforePreactivation: defaultRouterHook, afterPreactivation: defaultRouterHook};
      this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();
      this.routeReuseStrategy = new DefaultRouteReuseStrategy();
      this.onSameUrlNavigation = 'ignore';
      this.paramsInheritanceStrategy = 'emptyOnly';
      this.urlUpdateStrategy = 'deferred';
      this.relativeLinkResolution = 'corrected';
      const onLoadStart = (r) => this.triggerEvent(new RouteConfigLoadStart(r));
      const onLoadEnd = (r) => this.triggerEvent(new RouteConfigLoadEnd(r));
      this.ngModule = injector.get(NgModuleRef);
      this.console = injector.get(Console);
      const ngZone = injector.get(NgZone);
      this.isNgZoneEnabled = ngZone instanceof NgZone && NgZone.isInAngularZone();
      this.resetConfig(config2);
      this.currentUrlTree = createEmptyUrlTree();
      this.rawUrlTree = this.currentUrlTree;
      this.browserUrlTree = this.currentUrlTree;
      this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);
      this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);
      this.transitions = new BehaviorSubject({
        id: 0,
        currentUrlTree: this.currentUrlTree,
        currentRawUrl: this.currentUrlTree,
        extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree),
        urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree),
        rawUrl: this.currentUrlTree,
        extras: {},
        resolve: null,
        reject: null,
        promise: Promise.resolve(true),
        source: 'imperative',
        restoredState: null,
        currentSnapshot: this.routerState.snapshot,
        targetSnapshot: null,
        currentRouterState: this.routerState,
        targetRouterState: null,
        guards: {canActivateChecks: [], canDeactivateChecks: []},
        guardsResult: null
      });
      this.navigations = this.setupNavigations(this.transitions);
      this.processNavigations();
    }
    setupNavigations(transitions) {
      const eventsSubject = this.events;
      return transitions.pipe(
          filter((t) => t.id !== 0), map((t) => Object.assign(Object.assign({}, t), {
            extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl)
          })),
          switchMap((t) => {
            let completed = false;
            let errored = false;
            return of(t).pipe(
                tap((t2) => {
                  this.currentNavigation = {
                    id: t2.id,
                    initialUrl: t2.currentRawUrl,
                    extractedUrl: t2.extractedUrl,
                    trigger: t2.source,
                    extras: t2.extras,
                    previousNavigation: this.lastSuccessfulNavigation ?
                        Object.assign(
                            Object.assign({}, this.lastSuccessfulNavigation),
                            {previousNavigation: null}) :
                        null
                  };
                }),
                switchMap((t2) => {
                  const urlTransition = !this.navigated ||
                      t2.extractedUrl.toString() !== this.browserUrlTree.toString();
                  const processCurrentUrl =
                      (this.onSameUrlNavigation === 'reload' ? true : urlTransition) &&
                      this.urlHandlingStrategy.shouldProcessUrl(t2.rawUrl);
                  if (processCurrentUrl) {
                    return of(t2).pipe(
                        switchMap((t3) => {
                          const transition = this.transitions.getValue();
                          eventsSubject.next(new NavigationStart(
                              t3.id, this.serializeUrl(t3.extractedUrl), t3.source,
                              t3.restoredState));
                          if (transition !== this.transitions.getValue()) {
                            return EMPTY;
                          }
                          return Promise.resolve(t3);
                        }),
                        applyRedirects$1(
                            this.ngModule.injector, this.configLoader, this.urlSerializer,
                            this.config),
                        tap((t3) => {
                          this.currentNavigation = Object.assign(
                              Object.assign({}, this.currentNavigation),
                              {finalUrl: t3.urlAfterRedirects});
                        }),
                        recognize$1(
                            this.rootComponentType, this.config, (url) => this.serializeUrl(url),
                            this.paramsInheritanceStrategy, this.relativeLinkResolution),
                        tap((t3) => {
                          if (this.urlUpdateStrategy === 'eager') {
                            if (!t3.extras.skipLocationChange) {
                              this.setBrowserUrl(
                                  t3.urlAfterRedirects, !!t3.extras.replaceUrl, t3.id,
                                  t3.extras.state);
                            }
                            this.browserUrlTree = t3.urlAfterRedirects;
                          }
                          const routesRecognized = new RoutesRecognized(
                              t3.id, this.serializeUrl(t3.extractedUrl),
                              this.serializeUrl(t3.urlAfterRedirects), t3.targetSnapshot);
                          eventsSubject.next(routesRecognized);
                        }));
                  } else {
                    const processPreviousUrl = urlTransition && this.rawUrlTree &&
                        this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree);
                    if (processPreviousUrl) {
                      const {id, extractedUrl, source, restoredState, extras} = t2;
                      const navStart = new NavigationStart(
                          id, this.serializeUrl(extractedUrl), source, restoredState);
                      eventsSubject.next(navStart);
                      const targetSnapshot =
                          createEmptyState(extractedUrl, this.rootComponentType).snapshot;
                      return of(Object.assign(Object.assign({}, t2), {
                        targetSnapshot,
                        urlAfterRedirects: extractedUrl,
                        extras: Object.assign(
                            Object.assign({}, extras),
                            {skipLocationChange: false, replaceUrl: false})
                      }));
                    } else {
                      this.rawUrlTree = t2.rawUrl;
                      this.browserUrlTree = t2.urlAfterRedirects;
                      t2.resolve(null);
                      return EMPTY;
                    }
                  }
                }),
                switchTap((t2) => {
                  const {
                    targetSnapshot,
                    id: navigationId,
                    extractedUrl: appliedUrlTree,
                    rawUrl: rawUrlTree,
                    extras: {skipLocationChange, replaceUrl}
                  } = t2;
                  return this.hooks.beforePreactivation(targetSnapshot, {
                    navigationId,
                    appliedUrlTree,
                    rawUrlTree,
                    skipLocationChange: !!skipLocationChange,
                    replaceUrl: !!replaceUrl
                  });
                }),
                tap((t2) => {
                  const guardsStart = new GuardsCheckStart(
                      t2.id, this.serializeUrl(t2.extractedUrl),
                      this.serializeUrl(t2.urlAfterRedirects), t2.targetSnapshot);
                  this.triggerEvent(guardsStart);
                }),
                map((t2) => Object.assign(Object.assign({}, t2), {
                  guards:
                      getAllRouteGuards(t2.targetSnapshot, t2.currentSnapshot, this.rootContexts)
                })),
                checkGuards(this.ngModule.injector, (evt) => this.triggerEvent(evt)), tap((t2) => {
                  if (isUrlTree(t2.guardsResult)) {
                    const error = navigationCancelingError(
                        `Redirecting to "${this.serializeUrl(t2.guardsResult)}"`);
                    error.url = t2.guardsResult;
                    throw error;
                  }
                  const guardsEnd = new GuardsCheckEnd(
                      t2.id, this.serializeUrl(t2.extractedUrl),
                      this.serializeUrl(t2.urlAfterRedirects), t2.targetSnapshot,
                      !!t2.guardsResult);
                  this.triggerEvent(guardsEnd);
                }),
                filter((t2) => {
                  if (!t2.guardsResult) {
                    this.resetUrlToCurrentUrlTree();
                    const navCancel =
                        new NavigationCancel(t2.id, this.serializeUrl(t2.extractedUrl), '');
                    eventsSubject.next(navCancel);
                    t2.resolve(false);
                    return false;
                  }
                  return true;
                }),
                switchTap((t2) => {
                  if (t2.guards.canActivateChecks.length) {
                    return of(t2).pipe(
                        tap((t3) => {
                          const resolveStart = new ResolveStart(
                              t3.id, this.serializeUrl(t3.extractedUrl),
                              this.serializeUrl(t3.urlAfterRedirects), t3.targetSnapshot);
                          this.triggerEvent(resolveStart);
                        }),
                        switchMap((t3) => {
                          let dataResolved = false;
                          return of(t3).pipe(
                              resolveData(this.paramsInheritanceStrategy, this.ngModule.injector),
                              tap({
                                next: () => dataResolved = true,
                                complete: () => {
                                  if (!dataResolved) {
                                    const navCancel = new NavigationCancel(
                                        t3.id, this.serializeUrl(t3.extractedUrl),
                                        `At least one route resolver didn't emit any value.`);
                                    eventsSubject.next(navCancel);
                                    t3.resolve(false);
                                  }
                                }
                              }));
                        }),
                        tap((t3) => {
                          const resolveEnd = new ResolveEnd(
                              t3.id, this.serializeUrl(t3.extractedUrl),
                              this.serializeUrl(t3.urlAfterRedirects), t3.targetSnapshot);
                          this.triggerEvent(resolveEnd);
                        }));
                  }
                  return void 0;
                }),
                switchTap((t2) => {
                  const {
                    targetSnapshot,
                    id: navigationId,
                    extractedUrl: appliedUrlTree,
                    rawUrl: rawUrlTree,
                    extras: {skipLocationChange, replaceUrl}
                  } = t2;
                  return this.hooks.afterPreactivation(targetSnapshot, {
                    navigationId,
                    appliedUrlTree,
                    rawUrlTree,
                    skipLocationChange: !!skipLocationChange,
                    replaceUrl: !!replaceUrl
                  });
                }),
                map((t2) => {
                  const targetRouterState = createRouterState(
                      this.routeReuseStrategy, t2.targetSnapshot, t2.currentRouterState);
                  return Object.assign(Object.assign({}, t2), {targetRouterState});
                }),
                tap((t2) => {
                  this.currentUrlTree = t2.urlAfterRedirects;
                  this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t2.rawUrl);
                  this.routerState = t2.targetRouterState;
                  if (this.urlUpdateStrategy === 'deferred') {
                    if (!t2.extras.skipLocationChange) {
                      this.setBrowserUrl(
                          this.rawUrlTree, !!t2.extras.replaceUrl, t2.id, t2.extras.state);
                    }
                    this.browserUrlTree = t2.urlAfterRedirects;
                  }
                }),
                activateRoutes(
                    this.rootContexts, this.routeReuseStrategy, (evt) => this.triggerEvent(evt)),
                tap({
                  next() {
                    completed = true;
                  },
                  complete() {
                    completed = true;
                  }
                }),
                finalize(() => {
                  if (!completed && !errored) {
                    this.resetUrlToCurrentUrlTree();
                    const navCancel = new NavigationCancel(
                        t.id, this.serializeUrl(t.extractedUrl),
                        `Navigation ID ${t.id} is not equal to the current navigation id ${
                            this.navigationId}`);
                    eventsSubject.next(navCancel);
                    t.resolve(false);
                  }
                  this.currentNavigation = null;
                }),
                catchError((e) => {
                  errored = true;
                  if (isNavigationCancelingError(e)) {
                    const redirecting = isUrlTree(e.url);
                    if (!redirecting) {
                      this.navigated = true;
                      this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);
                    }
                    const navCancel =
                        new NavigationCancel(t.id, this.serializeUrl(t.extractedUrl), e.message);
                    eventsSubject.next(navCancel);
                    if (!redirecting) {
                      t.resolve(false);
                    } else {
                      setTimeout(() => {
                        const mergedTree = this.urlHandlingStrategy.merge(e.url, this.rawUrlTree);
                        const extras = {
                          skipLocationChange: t.extras.skipLocationChange,
                          replaceUrl: this.urlUpdateStrategy === 'eager'
                        };
                        this.scheduleNavigation(
                            mergedTree, 'imperative', null, extras,
                            {resolve: t.resolve, reject: t.reject, promise: t.promise});
                      }, 0);
                    }
                  } else {
                    this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);
                    const navError =
                        new NavigationError(t.id, this.serializeUrl(t.extractedUrl), e);
                    eventsSubject.next(navError);
                    try {
                      t.resolve(this.errorHandler(e));
                    } catch (ee) {
                      t.reject(ee);
                    }
                  }
                  return EMPTY;
                }));
          }));
    }
    resetRootComponentType(rootComponentType) {
      this.rootComponentType = rootComponentType;
      this.routerState.root.component = this.rootComponentType;
    }
    getTransition() {
      const transition = this.transitions.value;
      transition.urlAfterRedirects = this.browserUrlTree;
      return transition;
    }
    setTransition(t) {
      this.transitions.next(Object.assign(Object.assign({}, this.getTransition()), t));
    }
    initialNavigation() {
      this.setUpLocationChangeListener();
      if (this.navigationId === 0) {
        this.navigateByUrl(this.location.path(true), {replaceUrl: true});
      }
    }
    setUpLocationChangeListener() {
      if (!this.locationSubscription) {
        this.locationSubscription = this.location.subscribe((event) => {
          const currentChange = this.extractLocationChangeInfoFromEvent(event);
          if (this.shouldScheduleNavigation(this.lastLocationChangeInfo, currentChange)) {
            setTimeout(() => {
              const {source, state, urlTree} = currentChange;
              const extras = {replaceUrl: true};
              if (state) {
                const stateCopy = Object.assign({}, state);
                delete stateCopy.navigationId;
                if (Object.keys(stateCopy).length !== 0) {
                  extras.state = stateCopy;
                }
              }
              this.scheduleNavigation(urlTree, source, state, extras);
            }, 0);
          }
          this.lastLocationChangeInfo = currentChange;
        });
      }
    }
    extractLocationChangeInfoFromEvent(change) {
      var _a;
      return {
        source: change['type'] === 'popstate' ? 'popstate' : 'hashchange',
        urlTree: this.parseUrl(change['url']),
        state: ((_a = change.state) === null || _a === void 0 ? void 0 : _a.navigationId) ?
            change.state :
            null,
        transitionId: this.getTransition().id
      };
    }
    shouldScheduleNavigation(previous, current) {
      if (!previous) return true;
      const sameDestination = current.urlTree.toString() === previous.urlTree.toString();
      const eventsOccurredAtSameTime = current.transitionId === previous.transitionId;
      if (!eventsOccurredAtSameTime || !sameDestination) {
        return true;
      }
      if (current.source === 'hashchange' && previous.source === 'popstate' ||
          current.source === 'popstate' && previous.source === 'hashchange') {
        return false;
      }
      return true;
    }
    get url() {
      return this.serializeUrl(this.currentUrlTree);
    }
    getCurrentNavigation() {
      return this.currentNavigation;
    }
    triggerEvent(event) {
      this.events.next(event);
    }
    resetConfig(config2) {
      validateConfig(config2);
      this.config = config2.map(standardizeConfig);
      this.navigated = false;
      this.lastSuccessfulId = -1;
    }
    ngOnDestroy() {
      this.dispose();
    }
    dispose() {
      if (this.locationSubscription) {
        this.locationSubscription.unsubscribe();
        this.locationSubscription = void 0;
      }
    }
    createUrlTree(commands, navigationExtras = {}) {
      const {relativeTo, queryParams, fragment, queryParamsHandling, preserveFragment} =
          navigationExtras;
      const a = relativeTo || this.routerState.root;
      const f = preserveFragment ? this.currentUrlTree.fragment : fragment;
      let q = null;
      switch (queryParamsHandling) {
        case 'merge':
          q = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), queryParams);
          break;
        case 'preserve':
          q = this.currentUrlTree.queryParams;
          break;
        default:
          q = queryParams || null;
      }
      if (q !== null) {
        q = this.removeEmptyProps(q);
      }
      return createUrlTree(a, this.currentUrlTree, commands, q, f);
    }
    navigateByUrl(url, extras = {skipLocationChange: false}) {
      if (typeof ngDevMode === 'undefined' ||
          ngDevMode && this.isNgZoneEnabled && !NgZone.isInAngularZone()) {
        this.console.warn(
            `Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?`);
      }
      const urlTree = isUrlTree(url) ? url : this.parseUrl(url);
      const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
      return this.scheduleNavigation(mergedTree, 'imperative', null, extras);
    }
    navigate(commands, extras = {skipLocationChange: false}) {
      validateCommands(commands);
      return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
    }
    serializeUrl(url) {
      return this.urlSerializer.serialize(url);
    }
    parseUrl(url) {
      let urlTree;
      try {
        urlTree = this.urlSerializer.parse(url);
      } catch (e) {
        urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);
      }
      return urlTree;
    }
    isActive(url, exact) {
      if (isUrlTree(url)) {
        return containsTree(this.currentUrlTree, url, exact);
      }
      const urlTree = this.parseUrl(url);
      return containsTree(this.currentUrlTree, urlTree, exact);
    }
    removeEmptyProps(params) {
      return Object.keys(params).reduce((result, key) => {
        const value = params[key];
        if (value !== null && value !== void 0) {
          result[key] = value;
        }
        return result;
      }, {});
    }
    processNavigations() {
      this.navigations.subscribe(
          (t) => {
            this.navigated = true;
            this.lastSuccessfulId = t.id;
            this.events.next(new NavigationEnd(
                t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree)));
            this.lastSuccessfulNavigation = this.currentNavigation;
            this.currentNavigation = null;
            t.resolve(true);
          },
          (e) => {
            this.console.warn(`Unhandled Navigation Error: `);
          });
    }
    scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {
      const lastNavigation = this.getTransition();
      const browserNavPrecededByRouterNav = source !== 'imperative' &&
          (lastNavigation === null || lastNavigation === void 0 ?
               void 0 :
               lastNavigation.source) === 'imperative';
      const lastNavigationSucceeded = this.lastSuccessfulId === lastNavigation.id;
      const lastNavigationUrl = lastNavigationSucceeded || this.currentNavigation ?
          lastNavigation.rawUrl :
          lastNavigation.urlAfterRedirects;
      const duplicateNav = lastNavigationUrl.toString() === rawUrl.toString();
      if (browserNavPrecededByRouterNav && duplicateNav) {
        return Promise.resolve(true);
      }
      let resolve;
      let reject;
      let promise2;
      if (priorPromise) {
        resolve = priorPromise.resolve;
        reject = priorPromise.reject;
        promise2 = priorPromise.promise;
      } else {
        promise2 = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
      }
      const id = ++this.navigationId;
      this.setTransition({
        id,
        source,
        restoredState,
        currentUrlTree: this.currentUrlTree,
        currentRawUrl: this.rawUrlTree,
        rawUrl,
        extras,
        resolve,
        reject,
        promise: promise2,
        currentSnapshot: this.routerState.snapshot,
        currentRouterState: this.routerState
      });
      return promise2.catch((e) => {
        return Promise.reject(e);
      });
    }
    setBrowserUrl(url, replaceUrl, id, state) {
      const path = this.urlSerializer.serialize(url);
      state = state || {};
      if (this.location.isCurrentPathEqualTo(path) || replaceUrl) {
        this.location.replaceState(
            path, '', Object.assign(Object.assign({}, state), {navigationId: id}));
      } else {
        this.location.go(path, '', Object.assign(Object.assign({}, state), {navigationId: id}));
      }
    }
    resetStateAndUrl(storedState, storedUrl, rawUrl) {
      this.routerState = storedState;
      this.currentUrlTree = storedUrl;
      this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, rawUrl);
      this.resetUrlToCurrentUrlTree();
    }
    resetUrlToCurrentUrlTree() {
      this.location.replaceState(
          this.urlSerializer.serialize(this.rawUrlTree), '', {navigationId: this.lastSuccessfulId});
    }
  };
  Router.\u0275fac = function Router_Factory(t) {
    return new (t || Router)(
        \u0275\u0275inject(Type), \u0275\u0275inject(UrlSerializer),
        \u0275\u0275inject(ChildrenOutletContexts), \u0275\u0275inject(Location),
        \u0275\u0275inject(Injector), \u0275\u0275inject(NgModuleFactoryLoader),
        \u0275\u0275inject(Compiler), \u0275\u0275inject(void 0));
  };
  Router.\u0275prov = \u0275\u0275defineInjectable({token: Router, factory: Router.\u0275fac});
  Router.ctorParameters = () =>
      [{type: Type}, {type: UrlSerializer}, {type: ChildrenOutletContexts}, {type: Location},
       {type: Injector}, {type: NgModuleFactoryLoader}, {type: Compiler}, {type: void 0}];
  (function() {
    setClassMetadata(Router, [{type: Injectable}], function() {
      return [
        {type: Type}, {type: UrlSerializer}, {type: ChildrenOutletContexts}, {type: Location},
        {type: Injector}, {type: NgModuleFactoryLoader}, {type: Compiler}, {type: void 0}
      ];
    }, null);
  })();
  function validateCommands(commands) {
    for (let i = 0; i < commands.length; i++) {
      const cmd = commands[i];
      if (cmd == null) {
        throw new Error(`The requested path contains ${cmd} segment at index ${i}`);
      }
    }
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var RouterLink = class {
    constructor(router, route, tabIndex, renderer, el) {
      this.router = router;
      this.route = route;
      this.commands = [];
      this.onChanges = new Subject();
      if (tabIndex == null) {
        renderer.setAttribute(el.nativeElement, 'tabindex', '0');
      }
    }
    ngOnChanges(changes) {
      this.onChanges.next(this);
    }
    set routerLink(commands) {
      if (commands != null) {
        this.commands = Array.isArray(commands) ? commands : [commands];
      } else {
        this.commands = [];
      }
    }
    onClick() {
      const extras = {
        skipLocationChange: attrBoolValue(this.skipLocationChange),
        replaceUrl: attrBoolValue(this.replaceUrl),
        state: this.state
      };
      this.router.navigateByUrl(this.urlTree, extras);
      return true;
    }
    get urlTree() {
      return this.router.createUrlTree(this.commands, {
        relativeTo: this.route,
        queryParams: this.queryParams,
        fragment: this.fragment,
        queryParamsHandling: this.queryParamsHandling,
        preserveFragment: attrBoolValue(this.preserveFragment)
      });
    }
  };
  RouterLink.\u0275fac = function RouterLink_Factory(t) {
    return new (t || RouterLink)(
        \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute),
        \u0275\u0275injectAttribute('tabindex'), \u0275\u0275directiveInject(Renderer2),
        \u0275\u0275directiveInject(ElementRef));
  };
  RouterLink.\u0275dir = \u0275\u0275defineDirective({
    type: RouterLink,
    selectors: [['', 'routerLink', '', 5, 'a', 5, 'area']],
    hostBindings: function RouterLink_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener('click', function RouterLink_click_HostBindingHandler() {
          return ctx.onClick();
        });
      }
    },
    inputs: {
      routerLink: 'routerLink',
      queryParams: 'queryParams',
      fragment: 'fragment',
      queryParamsHandling: 'queryParamsHandling',
      preserveFragment: 'preserveFragment',
      skipLocationChange: 'skipLocationChange',
      replaceUrl: 'replaceUrl',
      state: 'state'
    },
    features: [\u0275\u0275NgOnChangesFeature]
  });
  RouterLink.ctorParameters = () =>
      [{type: Router}, {type: ActivatedRoute},
       {type: String, decorators: [{type: Attribute, args: ['tabindex']}]}, {type: Renderer2},
       {type: ElementRef}];
  RouterLink.propDecorators = {
    queryParams: [{type: Input}],
    fragment: [{type: Input}],
    queryParamsHandling: [{type: Input}],
    preserveFragment: [{type: Input}],
    skipLocationChange: [{type: Input}],
    replaceUrl: [{type: Input}],
    state: [{type: Input}],
    routerLink: [{type: Input}],
    onClick: [{type: HostListener, args: ['click']}]
  };
  (function() {
    setClassMetadata(
        RouterLink,
        [{type: Directive, args: [{selector: ':not(a):not(area)[routerLink]'}]}], function() {
          return [
            {type: Router}, {type: ActivatedRoute},
            {type: String, decorators: [{type: Attribute, args: ['tabindex']}]}, {type: Renderer2},
            {type: ElementRef}
          ];
        }, {
          routerLink: [{type: Input}],
          onClick: [{type: HostListener, args: ['click']}],
          queryParams: [{type: Input}],
          fragment: [{type: Input}],
          queryParamsHandling: [{type: Input}],
          preserveFragment: [{type: Input}],
          skipLocationChange: [{type: Input}],
          replaceUrl: [{type: Input}],
          state: [{type: Input}]
        });
  })();
  var RouterLinkWithHref = class {
    constructor(router, route, locationStrategy) {
      this.router = router;
      this.route = route;
      this.locationStrategy = locationStrategy;
      this.commands = [];
      this.onChanges = new Subject();
      this.subscription = router.events.subscribe((s) => {
        if (s instanceof NavigationEnd) {
          this.updateTargetUrlAndHref();
        }
      });
    }
    set routerLink(commands) {
      if (commands != null) {
        this.commands = Array.isArray(commands) ? commands : [commands];
      } else {
        this.commands = [];
      }
    }
    ngOnChanges(changes) {
      this.updateTargetUrlAndHref();
      this.onChanges.next(this);
    }
    ngOnDestroy() {
      this.subscription.unsubscribe();
    }
    onClick(button, ctrlKey, shiftKey, altKey, metaKey) {
      if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {
        return true;
      }
      if (typeof this.target === 'string' && this.target != '_self') {
        return true;
      }
      const extras = {
        skipLocationChange: attrBoolValue(this.skipLocationChange),
        replaceUrl: attrBoolValue(this.replaceUrl),
        state: this.state
      };
      this.router.navigateByUrl(this.urlTree, extras);
      return false;
    }
    updateTargetUrlAndHref() {
      this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));
    }
    get urlTree() {
      return this.router.createUrlTree(this.commands, {
        relativeTo: this.route,
        queryParams: this.queryParams,
        fragment: this.fragment,
        queryParamsHandling: this.queryParamsHandling,
        preserveFragment: attrBoolValue(this.preserveFragment)
      });
    }
  };
  RouterLinkWithHref.\u0275fac = function RouterLinkWithHref_Factory(t) {
    return new (t || RouterLinkWithHref)(
        \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute),
        \u0275\u0275directiveInject(LocationStrategy));
  };
  RouterLinkWithHref.\u0275dir = \u0275\u0275defineDirective({
    type: RouterLinkWithHref,
    selectors: [['a', 'routerLink', ''], ['area', 'routerLink', '']],
    hostVars: 2,
    hostBindings: function RouterLinkWithHref_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener('click', function RouterLinkWithHref_click_HostBindingHandler($event) {
          return ctx.onClick(
              $event.button, $event.ctrlKey, $event.shiftKey, $event.altKey, $event.metaKey);
        });
      }
      if (rf & 2) {
        \u0275\u0275hostProperty('href', ctx.href, \u0275\u0275sanitizeUrl);
        \u0275\u0275attribute('target', ctx.target);
      }
    },
    inputs: {
      routerLink: 'routerLink',
      target: 'target',
      queryParams: 'queryParams',
      fragment: 'fragment',
      queryParamsHandling: 'queryParamsHandling',
      preserveFragment: 'preserveFragment',
      skipLocationChange: 'skipLocationChange',
      replaceUrl: 'replaceUrl',
      state: 'state'
    },
    features: [\u0275\u0275NgOnChangesFeature]
  });
  RouterLinkWithHref.ctorParameters =
      () => [{type: Router}, {type: ActivatedRoute}, {type: LocationStrategy}];
  RouterLinkWithHref.propDecorators = {
    target: [{type: HostBinding, args: ['attr.target']}, {type: Input}],
    queryParams: [{type: Input}],
    fragment: [{type: Input}],
    queryParamsHandling: [{type: Input}],
    preserveFragment: [{type: Input}],
    skipLocationChange: [{type: Input}],
    replaceUrl: [{type: Input}],
    state: [{type: Input}],
    href: [{type: HostBinding}],
    routerLink: [{type: Input}],
    onClick: [{
      type: HostListener,
      args: [
        'click',
        ['$event.button', '$event.ctrlKey', '$event.shiftKey', '$event.altKey', '$event.metaKey']
      ]
    }]
  };
  (function() {
    setClassMetadata(
        RouterLinkWithHref,
        [{type: Directive, args: [{selector: 'a[routerLink],area[routerLink]'}]}], function() {
          return [{type: Router}, {type: ActivatedRoute}, {type: LocationStrategy}];
        }, {
          routerLink: [{type: Input}],
          onClick: [{
            type: HostListener,
            args: [
              'click',
              [
                '$event.button', '$event.ctrlKey', '$event.shiftKey', '$event.altKey',
                '$event.metaKey'
              ]
            ]
          }],
          href: [{type: HostBinding}],
          target: [{type: HostBinding, args: ['attr.target']}, {type: Input}],
          queryParams: [{type: Input}],
          fragment: [{type: Input}],
          queryParamsHandling: [{type: Input}],
          preserveFragment: [{type: Input}],
          skipLocationChange: [{type: Input}],
          replaceUrl: [{type: Input}],
          state: [{type: Input}]
        });
  })();
  function attrBoolValue(s) {
    return s === '' || !!s;
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var RouterLinkActive = class {
    constructor(router, element, renderer, cdr, link, linkWithHref) {
      this.router = router;
      this.element = element;
      this.renderer = renderer;
      this.cdr = cdr;
      this.link = link;
      this.linkWithHref = linkWithHref;
      this.classes = [];
      this.isActive = false;
      this.routerLinkActiveOptions = {exact: false};
      this.routerEventsSubscription = router.events.subscribe((s) => {
        if (s instanceof NavigationEnd) {
          this.update();
        }
      });
    }
    ngAfterContentInit() {
      of(this.links.changes, this.linksWithHrefs.changes, of(null))
          .pipe(mergeAll())
          .subscribe((_) => {
            this.update();
            this.subscribeToEachLinkOnChanges();
          });
    }
    subscribeToEachLinkOnChanges() {
      var _a;
      (_a = this.linkInputChangesSubscription) === null || _a === void 0 ? void 0 :
                                                                           _a.unsubscribe();
      const allLinkChanges = [
        ...this.links.toArray(), ...this.linksWithHrefs.toArray(), this.link, this.linkWithHref
      ].filter((link) => !!link).map((link) => link.onChanges);
      this.linkInputChangesSubscription =
          from(allLinkChanges).pipe(mergeAll()).subscribe((link) => {
            if (this.isActive !== this.isLinkActive(this.router)(link)) {
              this.update();
            }
          });
    }
    set routerLinkActive(data) {
      const classes = Array.isArray(data) ? data : data.split(' ');
      this.classes = classes.filter((c) => !!c);
    }
    ngOnChanges(changes) {
      this.update();
    }
    ngOnDestroy() {
      var _a;
      this.routerEventsSubscription.unsubscribe();
      (_a = this.linkInputChangesSubscription) === null || _a === void 0 ? void 0 :
                                                                           _a.unsubscribe();
    }
    update() {
      if (!this.links || !this.linksWithHrefs || !this.router.navigated) return;
      Promise.resolve().then(() => {
        const hasActiveLinks = this.hasActiveLinks();
        if (this.isActive !== hasActiveLinks) {
          this.isActive = hasActiveLinks;
          this.cdr.markForCheck();
          this.classes.forEach((c) => {
            if (hasActiveLinks) {
              this.renderer.addClass(this.element.nativeElement, c);
            } else {
              this.renderer.removeClass(this.element.nativeElement, c);
            }
          });
        }
      });
    }
    isLinkActive(router) {
      return (link) => router.isActive(link.urlTree, this.routerLinkActiveOptions.exact);
    }
    hasActiveLinks() {
      const isActiveCheckFn = this.isLinkActive(this.router);
      return this.link && isActiveCheckFn(this.link) ||
          this.linkWithHref && isActiveCheckFn(this.linkWithHref) ||
          this.links.some(isActiveCheckFn) || this.linksWithHrefs.some(isActiveCheckFn);
    }
  };
  RouterLinkActive.\u0275fac = function RouterLinkActive_Factory(t) {
    return new (t || RouterLinkActive)(
        \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ElementRef),
        \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ChangeDetectorRef),
        \u0275\u0275directiveInject(RouterLink, 8),
        \u0275\u0275directiveInject(RouterLinkWithHref, 8));
  };
  RouterLinkActive.\u0275dir = \u0275\u0275defineDirective({
    type: RouterLinkActive,
    selectors: [['', 'routerLinkActive', '']],
    contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, RouterLink, true);
        \u0275\u0275contentQuery(dirIndex, RouterLinkWithHref, true);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.links = _t);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.linksWithHrefs = _t);
      }
    },
    inputs:
        {routerLinkActiveOptions: 'routerLinkActiveOptions', routerLinkActive: 'routerLinkActive'},
    exportAs: ['routerLinkActive'],
    features: [\u0275\u0275NgOnChangesFeature]
  });
  RouterLinkActive.ctorParameters = () =>
      [{type: Router}, {type: ElementRef}, {type: Renderer2}, {type: ChangeDetectorRef},
       {type: RouterLink, decorators: [{type: Optional}]},
       {type: RouterLinkWithHref, decorators: [{type: Optional}]}];
  RouterLinkActive.propDecorators = {
    links: [{type: ContentChildren, args: [RouterLink, {descendants: true}]}],
    linksWithHrefs: [{type: ContentChildren, args: [RouterLinkWithHref, {descendants: true}]}],
    routerLinkActiveOptions: [{type: Input}],
    routerLinkActive: [{type: Input}]
  };
  (function() {
    setClassMetadata(
        RouterLinkActive,
        [{type: Directive, args: [{selector: '[routerLinkActive]', exportAs: 'routerLinkActive'}]}],
        function() {
          return [
            {type: Router}, {type: ElementRef}, {type: Renderer2}, {type: ChangeDetectorRef},
            {type: RouterLink, decorators: [{type: Optional}]},
            {type: RouterLinkWithHref, decorators: [{type: Optional}]}
          ];
        },
        {
          routerLinkActiveOptions: [{type: Input}],
          routerLinkActive: [{type: Input}],
          links: [{type: ContentChildren, args: [RouterLink, {descendants: true}]}],
          linksWithHrefs: [{type: ContentChildren, args: [RouterLinkWithHref, {descendants: true}]}]
        });
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var RouterOutlet = class {
    constructor(parentContexts, location2, resolver, name, changeDetector) {
      this.parentContexts = parentContexts;
      this.location = location2;
      this.resolver = resolver;
      this.changeDetector = changeDetector;
      this.activated = null;
      this._activatedRoute = null;
      this.activateEvents = new EventEmitter();
      this.deactivateEvents = new EventEmitter();
      this.name = name || PRIMARY_OUTLET;
      parentContexts.onChildOutletCreated(this.name, this);
    }
    ngOnDestroy() {
      this.parentContexts.onChildOutletDestroyed(this.name);
    }
    ngOnInit() {
      if (!this.activated) {
        const context = this.parentContexts.getContext(this.name);
        if (context && context.route) {
          if (context.attachRef) {
            this.attach(context.attachRef, context.route);
          } else {
            this.activateWith(context.route, context.resolver || null);
          }
        }
      }
    }
    get isActivated() {
      return !!this.activated;
    }
    get component() {
      if (!this.activated) throw new Error('Outlet is not activated');
      return this.activated.instance;
    }
    get activatedRoute() {
      if (!this.activated) throw new Error('Outlet is not activated');
      return this._activatedRoute;
    }
    get activatedRouteData() {
      if (this._activatedRoute) {
        return this._activatedRoute.snapshot.data;
      }
      return {};
    }
    detach() {
      if (!this.activated) throw new Error('Outlet is not activated');
      this.location.detach();
      const cmp = this.activated;
      this.activated = null;
      this._activatedRoute = null;
      return cmp;
    }
    attach(ref, activatedRoute) {
      this.activated = ref;
      this._activatedRoute = activatedRoute;
      this.location.insert(ref.hostView);
    }
    deactivate() {
      if (this.activated) {
        const c = this.component;
        this.activated.destroy();
        this.activated = null;
        this._activatedRoute = null;
        this.deactivateEvents.emit(c);
      }
    }
    activateWith(activatedRoute, resolver) {
      if (this.isActivated) {
        throw new Error('Cannot activate an already activated outlet');
      }
      this._activatedRoute = activatedRoute;
      const snapshot = activatedRoute._futureSnapshot;
      const component = snapshot.routeConfig.component;
      resolver = resolver || this.resolver;
      const factory = resolver.resolveComponentFactory(component);
      const childContexts = this.parentContexts.getOrCreateContext(this.name).children;
      const injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);
      this.activated = this.location.createComponent(factory, this.location.length, injector);
      this.changeDetector.markForCheck();
      this.activateEvents.emit(this.activated.instance);
    }
  };
  RouterOutlet.\u0275fac = function RouterOutlet_Factory(t) {
    return new (t || RouterOutlet)(
        \u0275\u0275directiveInject(ChildrenOutletContexts),
        \u0275\u0275directiveInject(ViewContainerRef),
        \u0275\u0275directiveInject(ComponentFactoryResolver), \u0275\u0275injectAttribute('name'),
        \u0275\u0275directiveInject(ChangeDetectorRef));
  };
  RouterOutlet.\u0275dir = \u0275\u0275defineDirective({
    type: RouterOutlet,
    selectors: [['router-outlet']],
    outputs: {activateEvents: 'activate', deactivateEvents: 'deactivate'},
    exportAs: ['outlet']
  });
  RouterOutlet.ctorParameters = () =>
      [{type: ChildrenOutletContexts}, {type: ViewContainerRef}, {type: ComponentFactoryResolver},
       {type: String, decorators: [{type: Attribute, args: ['name']}]}, {type: ChangeDetectorRef}];
  RouterOutlet.propDecorators = {
    activateEvents: [{type: Output, args: ['activate']}],
    deactivateEvents: [{type: Output, args: ['deactivate']}]
  };
  (function() {
    setClassMetadata(
        RouterOutlet,
        [{type: Directive, args: [{selector: 'router-outlet', exportAs: 'outlet'}]}], function() {
          return [
            {type: ChildrenOutletContexts}, {type: ViewContainerRef},
            {type: ComponentFactoryResolver},
            {type: String, decorators: [{type: Attribute, args: ['name']}]},
            {type: ChangeDetectorRef}
          ];
        }, {
          activateEvents: [{type: Output, args: ['activate']}],
          deactivateEvents: [{type: Output, args: ['deactivate']}]
        });
  })();
  var OutletInjector = class {
    constructor(route, childContexts, parent) {
      this.route = route;
      this.childContexts = childContexts;
      this.parent = parent;
    }
    get(token, notFoundValue) {
      if (token === ActivatedRoute) {
        return this.route;
      }
      if (token === ChildrenOutletContexts) {
        return this.childContexts;
      }
      return this.parent.get(token, notFoundValue);
    }
  };
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var PreloadingStrategy = class {};
  var PreloadAllModules = class {
    preload(route, fn) {
      return fn().pipe(catchError(() => of(null)));
    }
  };
  var NoPreloading = class {
    preload(route, fn) {
      return of(null);
    }
  };
  var RouterPreloader = class {
    constructor(router, moduleLoader, compiler, injector, preloadingStrategy) {
      this.router = router;
      this.injector = injector;
      this.preloadingStrategy = preloadingStrategy;
      const onStartLoad = (r) => router.triggerEvent(new RouteConfigLoadStart(r));
      const onEndLoad = (r) => router.triggerEvent(new RouteConfigLoadEnd(r));
      this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);
    }
    setUpPreloading() {
      this.subscription =
          this.router.events
              .pipe(filter((e) => e instanceof NavigationEnd), concatMap(() => this.preload()))
              .subscribe(() => {});
    }
    preload() {
      const ngModule = this.injector.get(NgModuleRef);
      return this.processRoutes(ngModule, this.router.config);
    }
    ngOnDestroy() {
      if (this.subscription) {
        this.subscription.unsubscribe();
      }
    }
    processRoutes(ngModule, routes2) {
      const res = [];
      for (const route of routes2) {
        if (route.loadChildren && !route.canLoad && route._loadedConfig) {
          const childConfig = route._loadedConfig;
          res.push(this.processRoutes(childConfig.module, childConfig.routes));
        } else if (route.loadChildren && !route.canLoad) {
          res.push(this.preloadConfig(ngModule, route));
        } else if (route.children) {
          res.push(this.processRoutes(ngModule, route.children));
        }
      }
      return from(res).pipe(mergeAll(), map((_) => void 0));
    }
    preloadConfig(ngModule, route) {
      return this.preloadingStrategy.preload(route, () => {
        const loaded$ = this.loader.load(ngModule.injector, route);
        return loaded$.pipe(mergeMap((config2) => {
          route._loadedConfig = config2;
          return this.processRoutes(config2.module, config2.routes);
        }));
      });
    }
  };
  RouterPreloader.\u0275fac = function RouterPreloader_Factory(t) {
    return new (t || RouterPreloader)(
        \u0275\u0275inject(Router), \u0275\u0275inject(NgModuleFactoryLoader),
        \u0275\u0275inject(Compiler), \u0275\u0275inject(Injector),
        \u0275\u0275inject(PreloadingStrategy));
  };
  RouterPreloader.\u0275prov =
      \u0275\u0275defineInjectable({token: RouterPreloader, factory: RouterPreloader.\u0275fac});
  RouterPreloader.ctorParameters =
      () => [{type: Router}, {type: NgModuleFactoryLoader}, {type: Compiler}, {type: Injector}, {
        type: PreloadingStrategy
      }];
  (function() {
    setClassMetadata(RouterPreloader, [{type: Injectable}], function() {
      return [
        {type: Router}, {type: NgModuleFactoryLoader}, {type: Compiler}, {type: Injector},
        {type: PreloadingStrategy}
      ];
    }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var RouterScroller = class {
    constructor(router, viewportScroller, options = {}) {
      this.router = router;
      this.viewportScroller = viewportScroller;
      this.options = options;
      this.lastId = 0;
      this.lastSource = 'imperative';
      this.restoredId = 0;
      this.store = {};
      options.scrollPositionRestoration = options.scrollPositionRestoration || 'disabled';
      options.anchorScrolling = options.anchorScrolling || 'disabled';
    }
    init() {
      if (this.options.scrollPositionRestoration !== 'disabled') {
        this.viewportScroller.setHistoryScrollRestoration('manual');
      }
      this.routerEventsSubscription = this.createScrollEvents();
      this.scrollEventsSubscription = this.consumeScrollEvents();
    }
    createScrollEvents() {
      return this.router.events.subscribe((e) => {
        if (e instanceof NavigationStart) {
          this.store[this.lastId] = this.viewportScroller.getScrollPosition();
          this.lastSource = e.navigationTrigger;
          this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;
        } else if (e instanceof NavigationEnd) {
          this.lastId = e.id;
          this.scheduleScrollEvent(e, this.router.parseUrl(e.urlAfterRedirects).fragment);
        }
      });
    }
    consumeScrollEvents() {
      return this.router.events.subscribe((e) => {
        if (!(e instanceof Scroll)) return;
        if (e.position) {
          if (this.options.scrollPositionRestoration === 'top') {
            this.viewportScroller.scrollToPosition([0, 0]);
          } else if (this.options.scrollPositionRestoration === 'enabled') {
            this.viewportScroller.scrollToPosition(e.position);
          }
        } else {
          if (e.anchor && this.options.anchorScrolling === 'enabled') {
            this.viewportScroller.scrollToAnchor(e.anchor);
          } else if (this.options.scrollPositionRestoration !== 'disabled') {
            this.viewportScroller.scrollToPosition([0, 0]);
          }
        }
      });
    }
    scheduleScrollEvent(routerEvent, anchor) {
      this.router.triggerEvent(new Scroll(
          routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null,
          anchor));
    }
    ngOnDestroy() {
      if (this.routerEventsSubscription) {
        this.routerEventsSubscription.unsubscribe();
      }
      if (this.scrollEventsSubscription) {
        this.scrollEventsSubscription.unsubscribe();
      }
    }
  };
  RouterScroller.\u0275fac = function RouterScroller_Factory(t) {
    return new (t || RouterScroller)(
        \u0275\u0275inject(Router), \u0275\u0275inject(ViewportScroller),
        \u0275\u0275inject(void 0));
  };
  RouterScroller.\u0275prov =
      \u0275\u0275defineInjectable({token: RouterScroller, factory: RouterScroller.\u0275fac});
  RouterScroller.ctorParameters = () => [{type: Router}, {type: ViewportScroller}, {type: void 0}];
  (function() {
    setClassMetadata(RouterScroller, [{type: Injectable}], function() {
      return [{type: Router}, {type: ViewportScroller}, {type: void 0}];
    }, null);
  })();
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ROUTER_DIRECTIVES =
      [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, \u0275EmptyOutletComponent];
  var ROUTER_CONFIGURATION = new InjectionToken('ROUTER_CONFIGURATION');
  var ROUTER_FORROOT_GUARD = new InjectionToken('ROUTER_FORROOT_GUARD');
  var \u027503 = {enableTracing: false};
  var ROUTER_PROVIDERS = [
    Location, {provide: UrlSerializer, useClass: DefaultUrlSerializer}, {
      provide: Router,
      useFactory: setupRouter,
      deps: [
        UrlSerializer, ChildrenOutletContexts, Location, Injector, NgModuleFactoryLoader, Compiler,
        ROUTES, ROUTER_CONFIGURATION, [UrlHandlingStrategy, new Optional()],
        [RouteReuseStrategy, new Optional()]
      ]
    },
    ChildrenOutletContexts, {provide: ActivatedRoute, useFactory: rootRoute, deps: [Router]},
    {provide: NgModuleFactoryLoader, useClass: SystemJsNgModuleLoader}, RouterPreloader,
    NoPreloading, PreloadAllModules, {provide: ROUTER_CONFIGURATION, useValue: \u027503}
  ];
  function routerNgProbeToken() {
    return new NgProbeToken('Router', Router);
  }
  var RouterModule = class {
    constructor(guard, router) {}
    static forRoot(routes2, config2) {
      return {
        ngModule: RouterModule,
        providers: [
          ROUTER_PROVIDERS, provideRoutes(routes2), {
            provide: ROUTER_FORROOT_GUARD,
            useFactory: provideForRootGuard,
            deps: [[Router, new Optional(), new SkipSelf()]]
          },
          {provide: ROUTER_CONFIGURATION, useValue: config2 ? config2 : {}}, {
            provide: LocationStrategy,
            useFactory: provideLocationStrategy2,
            deps: [
              PlatformLocation, [new Inject(APP_BASE_HREF), new Optional()], ROUTER_CONFIGURATION
            ]
          },
          {
            provide: RouterScroller,
            useFactory: createRouterScroller,
            deps: [Router, ViewportScroller, ROUTER_CONFIGURATION]
          },
          {
            provide: PreloadingStrategy,
            useExisting: config2 && config2.preloadingStrategy ? config2.preloadingStrategy :
                                                                 NoPreloading
          },
          {provide: NgProbeToken, multi: true, useFactory: routerNgProbeToken},
          provideRouterInitializer()
        ]
      };
    }
    static forChild(routes2) {
      return {ngModule: RouterModule, providers: [provideRoutes(routes2)]};
    }
  };
  RouterModule.\u0275mod = \u0275\u0275defineNgModule({type: RouterModule});
  RouterModule.\u0275inj = \u0275\u0275defineInjector({
    factory: function RouterModule_Factory(t) {
      return new (t || RouterModule)(
          \u0275\u0275inject(ROUTER_FORROOT_GUARD, 8), \u0275\u0275inject(Router, 8));
    }
  });
  RouterModule.ctorParameters = () =>
      [{type: void 0, decorators: [{type: Optional}, {type: Inject, args: [ROUTER_FORROOT_GUARD]}]},
       {type: Router, decorators: [{type: Optional}]}];
  (function() {
    (typeof ngJitMode === 'undefined' || ngJitMode) && \u0275\u0275setNgModuleScope(RouterModule, {
      declarations: [
        RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, \u0275EmptyOutletComponent
      ],
      exports: [
        RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, \u0275EmptyOutletComponent
      ]
    });
  })();
  (function() {
    setClassMetadata(
        RouterModule, [{
          type: NgModule,
          args: [{
            declarations: ROUTER_DIRECTIVES,
            exports: ROUTER_DIRECTIVES,
            entryComponents: [\u0275EmptyOutletComponent]
          }]
        }],
        function() {
          return [
            {
              type: void 0,
              decorators: [{type: Optional}, {type: Inject, args: [ROUTER_FORROOT_GUARD]}]
            },
            {type: Router, decorators: [{type: Optional}]}
          ];
        },
        null);
  })();
  function createRouterScroller(router, viewportScroller, config2) {
    if (config2.scrollOffset) {
      viewportScroller.setOffset(config2.scrollOffset);
    }
    return new RouterScroller(router, viewportScroller, config2);
  }
  function provideLocationStrategy2(platformLocationStrategy, baseHref, options = {}) {
    return options.useHash ? new HashLocationStrategy(platformLocationStrategy, baseHref) :
                             new PathLocationStrategy(platformLocationStrategy, baseHref);
  }
  function provideForRootGuard(router) {
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && router) {
      throw new Error(
          `RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.`);
    }
    return 'guarded';
  }
  function provideRoutes(routes2) {
    return [
      {provide: ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes2},
      {provide: ROUTES, multi: true, useValue: routes2}
    ];
  }
  function setupRouter(
      urlSerializer, contexts, location2, injector, loader, compiler, config2, opts = {},
      urlHandlingStrategy, routeReuseStrategy) {
    const router = new Router(
        null, urlSerializer, contexts, location2, injector, loader, compiler, flatten2(config2));
    if (urlHandlingStrategy) {
      router.urlHandlingStrategy = urlHandlingStrategy;
    }
    if (routeReuseStrategy) {
      router.routeReuseStrategy = routeReuseStrategy;
    }
    assignExtraOptionsToRouter(opts, router);
    if (opts.enableTracing) {
      const dom = getDOM();
      router.events.subscribe((e) => {
        dom.logGroup(`Router Event: ${e.constructor.name}`);
        dom.log(e.toString());
        dom.log(e);
        dom.logGroupEnd();
      });
    }
    return router;
  }
  function assignExtraOptionsToRouter(opts, router) {
    if (opts.errorHandler) {
      router.errorHandler = opts.errorHandler;
    }
    if (opts.malformedUriErrorHandler) {
      router.malformedUriErrorHandler = opts.malformedUriErrorHandler;
    }
    if (opts.onSameUrlNavigation) {
      router.onSameUrlNavigation = opts.onSameUrlNavigation;
    }
    if (opts.paramsInheritanceStrategy) {
      router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;
    }
    if (opts.relativeLinkResolution) {
      router.relativeLinkResolution = opts.relativeLinkResolution;
    }
    if (opts.urlUpdateStrategy) {
      router.urlUpdateStrategy = opts.urlUpdateStrategy;
    }
  }
  function rootRoute(router) {
    return router.routerState.root;
  }
  var RouterInitializer = class {
    constructor(injector) {
      this.injector = injector;
      this.initNavigation = false;
      this.resultOfPreactivationDone = new Subject();
    }
    appInitializer() {
      const p = this.injector.get(LOCATION_INITIALIZED, Promise.resolve(null));
      return p.then(() => {
        let resolve = null;
        const res = new Promise((r) => resolve = r);
        const router = this.injector.get(Router);
        const opts = this.injector.get(ROUTER_CONFIGURATION);
        if (opts.initialNavigation === 'disabled') {
          router.setUpLocationChangeListener();
          resolve(true);
        } else if (
            opts.initialNavigation === 'enabled' || opts.initialNavigation === 'enabledBlocking') {
          router.hooks.afterPreactivation = () => {
            if (!this.initNavigation) {
              this.initNavigation = true;
              resolve(true);
              return this.resultOfPreactivationDone;
            } else {
              return of(null);
            }
          };
          router.initialNavigation();
        } else {
          resolve(true);
        }
        return res;
      });
    }
    bootstrapListener(bootstrappedComponentRef) {
      const opts = this.injector.get(ROUTER_CONFIGURATION);
      const preloader = this.injector.get(RouterPreloader);
      const routerScroller = this.injector.get(RouterScroller);
      const router = this.injector.get(Router);
      const ref = this.injector.get(ApplicationRef);
      if (bootstrappedComponentRef !== ref.components[0]) {
        return;
      }
      if (opts.initialNavigation === 'enabledNonBlocking' || opts.initialNavigation === void 0) {
        router.initialNavigation();
      }
      preloader.setUpPreloading();
      routerScroller.init();
      router.resetRootComponentType(ref.componentTypes[0]);
      this.resultOfPreactivationDone.next(null);
      this.resultOfPreactivationDone.complete();
    }
  };
  RouterInitializer.\u0275fac = function RouterInitializer_Factory(t) {
    return new (t || RouterInitializer)(\u0275\u0275inject(Injector));
  };
  RouterInitializer.\u0275prov = \u0275\u0275defineInjectable(
      {token: RouterInitializer, factory: RouterInitializer.\u0275fac});
  RouterInitializer.ctorParameters = () => [{type: Injector}];
  (function() {
    setClassMetadata(RouterInitializer, [{type: Injectable}], function() {
      return [{type: Injector}];
    }, null);
  })();
  function getAppInitializer(r) {
    return r.appInitializer.bind(r);
  }
  function getBootstrapListener(r) {
    return r.bootstrapListener.bind(r);
  }
  var ROUTER_INITIALIZER = new InjectionToken('Router Initializer');
  function provideRouterInitializer() {
    return [
      RouterInitializer, {
        provide: APP_INITIALIZER,
        multi: true,
        useFactory: getAppInitializer,
        deps: [RouterInitializer]
      },
      {provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [RouterInitializer]},
      {provide: APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER}
    ];
  }
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var VERSION4 = new Version('11.0.9');
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */

  // bazel-out/darwin-fastbuild/bin/docs-site/src/app/versions.mjs
  var DOCSINFO = {
    HEAD: {
      version: 'HEAD',
      navs: {
        page: [
          {md: 'install', ordinality: 0, title: 'Installation', toc: true, nav: 'page'},
          {md: 'repositories', ordinality: 1, title: 'Repositories', toc: true, nav: 'page'},
          {md: 'dependencies', ordinality: 2, title: 'Dependencies', toc: true, nav: 'page'},
          {md: 'debugging', ordinality: 3, title: 'Debugging', toc: true, nav: 'page'}, {
            md: 'changing-rules',
            ordinality: 4,
            title: 'Making changes to rules_nodejs',
            toc: true,
            nav: 'page'
          },
          {md: 'stamping', ordinality: 5, title: 'Stamping', toc: true, nav: 'page'},
          {md: 'examples', ordinality: 6, title: 'Examples', toc: true, nav: 'page'}
        ],
        rule: [
          {md: 'Built-ins', ordinality: -1, title: 'Built-ins', toc: true, nav: 'rule'},
          {md: 'Concatjs', ordinality: -1, title: 'Concatjs', toc: true, nav: 'rule'},
          {md: 'Cypress', ordinality: -1, title: 'Cypress', toc: true, nav: 'rule'},
          {md: 'esbuild', ordinality: -1, title: 'esbuild', toc: true, nav: 'rule'},
          {md: 'Jasmine', ordinality: -1, title: 'Jasmine', toc: true, nav: 'rule'},
          {md: 'Labs', ordinality: -1, title: 'Labs', toc: true, nav: 'rule'},
          {md: 'Protractor', ordinality: -1, title: 'Protractor', toc: true, nav: 'rule'},
          {md: 'Rollup', ordinality: -1, title: 'Rollup', toc: true, nav: 'rule'},
          {md: 'Terser', ordinality: -1, title: 'Terser', toc: true, nav: 'rule'},
          {md: 'TypeScript', ordinality: -1, title: 'Typescript', toc: true, nav: 'rule'}
        ]
      }
    },
    '3.1.0': {
      version: '3.1.0',
      navs: {
        page: [
          {md: 'install', ordinality: 0, title: 'Installation', toc: true, nav: 'page'},
          {md: 'repositories', ordinality: 1, title: 'Repositories', toc: true, nav: 'page'},
          {md: 'dependencies', ordinality: 2, title: 'Dependencies', toc: true, nav: 'page'},
          {md: 'debugging', ordinality: 3, title: 'Debugging', toc: true, nav: 'page'}, {
            md: 'changing-rules',
            ordinality: 4,
            title: 'Making changes to rules_nodejs',
            toc: true,
            nav: 'page'
          },
          {md: 'stamping', ordinality: 5, title: 'Stamping', toc: true, nav: 'page'},
          {md: 'examples', ordinality: 6, title: 'Examples', toc: true, nav: 'page'}
        ],
        rule: [
          {md: 'Built-ins', ordinality: 0, title: 'Built-ins', toc: true, nav: 'rule'},
          {md: 'Concatjs', ordinality: -1, title: 'Concatjs', toc: true, nav: 'rule'},
          {md: 'Cypress', ordinality: -1, title: 'Cypress', toc: true, nav: 'rule'},
          {md: 'Jasmine', ordinality: -1, title: 'Jasmine', toc: true, nav: 'rule'},
          {md: 'Karma', ordinality: -1, title: 'Karma', toc: true, nav: 'rule'},
          {md: 'Labs', ordinality: -1, title: 'Labs', toc: true, nav: 'rule'},
          {md: 'Protractor', ordinality: -1, title: 'Protractor', toc: true, nav: 'rule'},
          {md: 'Rollup', ordinality: -1, title: 'Rollup', toc: true, nav: 'rule'},
          {md: 'Terser', ordinality: -1, title: 'Terser', toc: true, nav: 'rule'},
          {md: 'TypeScript', ordinality: -1, title: 'Typescript', toc: true, nav: 'rule'}
        ]
      }
    },
    '3.2.0': {
      version: '3.2.0',
      navs: {
        page: [
          {md: 'install', ordinality: 0, title: 'Installation', toc: true, nav: 'page'},
          {md: 'repositories', ordinality: 1, title: 'Repositories', toc: true, nav: 'page'},
          {md: 'dependencies', ordinality: 2, title: 'Dependencies', toc: true, nav: 'page'},
          {md: 'debugging', ordinality: 3, title: 'Debugging', toc: true, nav: 'page'}, {
            md: 'changing-rules',
            ordinality: 4,
            title: 'Making changes to rules_nodejs',
            toc: true,
            nav: 'page'
          },
          {md: 'stamping', ordinality: 5, title: 'Stamping', toc: true, nav: 'page'},
          {md: 'examples', ordinality: 6, title: 'Examples', toc: true, nav: 'page'}
        ],
        rule: [
          {md: 'Built-ins', ordinality: -1, title: 'Built-ins', toc: true, nav: 'rule'},
          {md: 'Concatjs', ordinality: -1, title: 'Concatjs', toc: true, nav: 'rule'},
          {md: 'Cypress', ordinality: -1, title: 'Cypress', toc: true, nav: 'rule'},
          {md: 'esbuild', ordinality: -1, title: 'esbuild', toc: true, nav: 'rule'},
          {md: 'Jasmine', ordinality: -1, title: 'Jasmine', toc: true, nav: 'rule'},
          {md: 'Karma', ordinality: -1, title: 'Karma', toc: true, nav: 'rule'},
          {md: 'Labs', ordinality: -1, title: 'Labs', toc: true, nav: 'rule'},
          {md: 'Protractor', ordinality: -1, title: 'Protractor', toc: true, nav: 'rule'},
          {md: 'Rollup', ordinality: -1, title: 'Rollup', toc: true, nav: 'rule'},
          {md: 'Terser', ordinality: -1, title: 'Terser', toc: true, nav: 'rule'},
          {md: 'TypeScript', ordinality: -1, title: 'Typescript', toc: true, nav: 'rule'}
        ]
      }
    }
  };
  var VERSIONS = ['HEAD', '3.2.0', '3.1.0'];

  // bazel-out/darwin-fastbuild/bin/docs-site/src/app/docs.service.mjs
  var DocsService = class {
    constructor(router) {
      this.router = router;
      this.versionChnage$ = new ReplaySubject(1);
      this.pageChange$ = new ReplaySubject(1);
    }
    init() {
      const info = Object.entries(DOCSINFO).map((version) => [version[0], version[1]]);
      this.info = new Map(info);
      this.versions = VERSIONS;
      setTimeout(() => {
        const parsed = this.parseUrl(this.router.url);
        if (parsed.version && this.info.has(parsed.version)) {
          this.emitChangeEvent(parsed.version);
        } else {
          this.emitChangeEvent(this.latest);
        }
      });
    }
    get versions$() {
      return of(this.versions);
    }
    get latest() {
      return this.versions[1];
    }
    getPageMetadata(md, version = this.latest) {
      if (!this.info.has(version)) {
        return;
      }
      const info = this.info.get(version);
      let meta = info.navs.page.find((page) => page.md === md);
      if (meta) {
        return meta;
      }
      return info.navs.rule.find((page) => page.md === md);
    }
    onVersionSelect() {
      return this.versionChnage$.asObservable();
    }
    onPageChange() {
      return this.pageChange$.asObservable();
    }
    selectVersion(version) {
      if (!this.info.has(version)) {
        return Promise.resolve(false);
      }
      const next = ['/', 'docs', version];
      const parsed = this.parseUrl(this.router.url);
      if (parsed.doc) {
        next.push(parsed.doc);
      }
      this.router.navigate(next).then((hasNavigated) => {
        if (!hasNavigated) {
          return;
        }
        this.emitChangeEvent(version);
        return true;
      });
    }
    changePage(page, version, toc) {
      const meta = this.getPageMetadata(page, version);
      this.pageChange$.next({page, toc, meta});
    }
    parseUrl(url) {
      const parsed = {version: null, doc: null};
      if (url.startsWith('/docs/')) {
        const segments = url.split('/');
        parsed.version = segments[2];
        parsed.doc = segments[3];
      }
      return parsed;
    }
    emitChangeEvent(version) {
      this.versionChnage$.next({version, info: this.info.get(version)});
    }
  };
  DocsService.VERSION_SCHEMA = 'pages/versions.json';
  DocsService.\u0275fac = function DocsService_Factory(t) {
    return new (t || DocsService)(\u0275\u0275inject(Router));
  };
  DocsService.\u0275prov = \u0275\u0275defineInjectable(
      {token: DocsService, factory: DocsService.\u0275fac, providedIn: 'root'});
  (function() {
    setClassMetadata(DocsService, [{type: Injectable, args: [{providedIn: 'root'}]}], function() {
      return [{type: Router}];
    }, null);
  })();

  // bazel-out/darwin-fastbuild/bin/docs-site/src/app/doc-renderer/doc-renderer.component.mjs
  var DocRendererComponent = class {
    constructor(route, router, viewportScroller, doc, markdownService) {
      this.route = route;
      this.router = router;
      this.viewportScroller = viewportScroller;
      this.doc = doc;
      this.markdownService = markdownService;
      this.toc = [];
    }
    ngOnInit() {
      this.markdownService.renderer.heading = (text, level) => {
        let h = `h${level} `;
        if (text.startsWith('.')) {
          const endOfCss = text.indexOf(' ');
          const css = text.substring(1, endOfCss).split('.').join(' ');
          h += `class="${css}"`;
          text = text.substring(endOfCss + 1);
        }
        if (level === 1 || level > 3) {
          return `<${h}>${text}</h${level}>`;
        }
        const htmlStrippedText = text.replace(/(<([^>]+)>)/g, '');
        const escapedText = htmlStrippedText.toLowerCase().replace(/[^\w]+/g, '_');
        const href = `${window.location.pathname}#${escapedText}`;
        this.toc.push({text: htmlStrippedText, escapedText, level, href});
        return `<${h} id="${escapedText}"><a name="${escapedText}" class="anchor" href="${
                   href}"></a>` +
            text + `</h${level}>`;
      };
      this.url$ = this.route.paramMap.pipe(
          map((params) => {
            var _a;
            let version =
                (_a = params.get('version'), _a !== null && _a !== void 0 ? _a : this.doc.latest);
            if (version === 'latest') {
              version = this.doc.latest;
            }
            if (!params.has('doc')) {
              return `${DocRendererComponent.URL_PREFIX}/${version}/index.md`;
            }
            const page = params.get('doc');
            const meta = this.doc.getPageMetadata(page, version);
            if (!meta) {
              this.router.navigate(['/', '404.html'], {skipLocationChange: true});
            }
            return `${DocRendererComponent.URL_PREFIX}/${version}/${page}.md`;
          }),
          tap((_) => this.toc = []));
    }
    onReady() {
      var _a, _b;
      this.doc.changePage(
          (_a = this.route.snapshot.paramMap.get('doc'),
           _a !== null && _a !== void 0 ? _a : 'index'),
          (_b = this.route.snapshot.paramMap.get('version'),
           _b !== null && _b !== void 0 ? _b : this.doc.latest),
          this.toc);
      const anchor = window.location.hash;
      if (anchor) {
        setTimeout(() => this.viewportScroller.scrollToAnchor(anchor.substr(1)), 100);
      }
    }
  };
  DocRendererComponent.URL_PREFIX = 'pages';
  DocRendererComponent.\u0275fac = function DocRendererComponent_Factory(t) {
    return new (t || DocRendererComponent)(
        \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(Router),
        \u0275\u0275directiveInject(ViewportScroller), \u0275\u0275directiveInject(DocsService),
        \u0275\u0275directiveInject(MarkdownService));
  };
  DocRendererComponent.\u0275cmp = \u0275\u0275defineComponent({
    type: DocRendererComponent,
    selectors: [['app-doc-renderer']],
    decls: 2,
    vars: 3,
    consts: [[3, 'src', 'ready']],
    template: function DocRendererComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, 'markdown', 0);
        \u0275\u0275listener(
            'ready', function DocRendererComponent_Template_markdown_ready_0_listener() {
              return ctx.onReady();
            });
        \u0275\u0275pipe(1, 'async');
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        \u0275\u0275property('src', \u0275\u0275pipeBind1(1, 1, ctx.url$));
      }
    },
    directives: [MarkdownComponent],
    pipes: [AsyncPipe],
    styles: [
      '[_nghost-%COMP%]     :hover>.anchor{opacity:1}[_nghost-%COMP%]     .anchor{opacity:0;position:absolute;margin-left:-1em;margin-top:-0.1em}[_nghost-%COMP%]     .anchor::after{font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-family:"Font Awesome 5 Free";font-weight:900;content:"\uF0C1";font-size:16px}[_nghost-%COMP%]     h5.attribute{margin-bottom:6px;margin-top:24px;font-weight:600}[_nghost-%COMP%]     h6.attribute-type{margin-top:0;margin-bottom:6px;font-size:12px}\n/*# sourceMappingURL=doc-renderer.component.css.map */'
    ],
    changeDetection: 0
  });
  (function() {
    setClassMetadata(
        DocRendererComponent, [{
          type: Component,
          args: [{
            selector: 'app-doc-renderer',
            templateUrl: './doc-renderer.component.html',
            styleUrls: ['./doc-renderer.component.scss'],
            changeDetection: ChangeDetectionStrategy.OnPush
          }]
        }],
        function() {
          return [
            {type: ActivatedRoute}, {type: Router}, {type: ViewportScroller}, {type: DocsService},
            {type: MarkdownService}
          ];
        },
        null);
  })();

  // bazel-out/darwin-fastbuild/bin/docs-site/src/app/not-found/not-found.component.mjs
  var NotFoundComponent = class {
    ngOnInit() {
      const segments = window.location.pathname.split('/');
      const last3 = segments.pop();
      this.target = `/${segments.join('/')}:${last3}`;
    }
  };
  NotFoundComponent.\u0275fac = function NotFoundComponent_Factory(t) {
    return new (t || NotFoundComponent)();
  };
  NotFoundComponent.\u0275cmp = \u0275\u0275defineComponent({
    type: NotFoundComponent,
    selectors: [['app-not-found']],
    decls: 13,
    vars: 2,
    consts: [[1, 'language-none'], [1, 'err'], [1, 'info']],
    template: function NotFoundComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, 'h3');
        \u0275\u0275text(1, '404 page not found');
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(2, 'pre', 0);
        \u0275\u0275text(3, '    ');
        \u0275\u0275elementStart(4, 'code', 0);
        \u0275\u0275text(5);
        \u0275\u0275elementStart(6, 'span', 1);
        \u0275\u0275text(7, 'ERROR');
        \u0275\u0275elementEnd();
        \u0275\u0275text(8);
        \u0275\u0275elementStart(9, 'span', 2);
        \u0275\u0275text(10, 'INFO');
        \u0275\u0275elementEnd();
        \u0275\u0275text(11, ': Elapsed time: 0.404s\n    ');
        \u0275\u0275elementEnd();
        \u0275\u0275text(12, '\n');
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        \u0275\u0275advance(5);
        \u0275\u0275textInterpolate1('\n        $ bazel build ', ctx.target, '\n        ');
        \u0275\u0275advance(3);
        \u0275\u0275textInterpolate1(': no such page \'', ctx.target, '\'\n        ');
      }
    },
    styles: [
      '.err[_ngcontent-%COMP%]{color:red;font-weight:bold}.info[_ngcontent-%COMP%]{color:green;font-weight:bold}\n/*# sourceMappingURL=not-found.component.css.map */'
    ],
    changeDetection: 0
  });
  (function() {
    setClassMetadata(
        NotFoundComponent, [{
          type: Component,
          args: [{
            selector: 'app-not-found',
            templateUrl: './not-found.component.html',
            styleUrls: ['./not-found.component.scss'],
            changeDetection: ChangeDetectionStrategy.OnPush
          }]
        }],
        null, null);
  })();

  // bazel-out/darwin-fastbuild/bin/docs-site/src/app/app-routing.module.mjs
  var EmptyComponent = class {};
  EmptyComponent.\u0275fac = function EmptyComponent_Factory(t) {
    return new (t || EmptyComponent)();
  };
  EmptyComponent.\u0275cmp = \u0275\u0275defineComponent({
    type: EmptyComponent,
    selectors: [['ng-component']],
    decls: 0,
    vars: 0,
    template: function EmptyComponent_Template(rf, ctx) {},
    encapsulation: 2
  });
  (function() {
    setClassMetadata(EmptyComponent, [{type: Component, args: [{template: ''}]}], null, null);
  })();
  function HtmlPageUrlMatcher(segments, group, route) {
    return segments.length === 1 && segments[0].path.endsWith('.html') ? {consumed: segments} :
                                                                         null;
  }
  var HtmlRouteRedirectGuard = class {
    constructor(router) {
      this.router = router;
    }
    canActivate(route, state) {
      if (route.url.length !== 1) {
        return false;
      }
      const file = route.url[0].path;
      const parts = file.split('.');
      parts.pop();
      this.router.navigate(['/', 'docs', 'latest', parts.join('.')]);
      return false;
    }
  };
  HtmlRouteRedirectGuard.\u0275fac = function HtmlRouteRedirectGuard_Factory(t) {
    return new (t || HtmlRouteRedirectGuard)(\u0275\u0275inject(Router));
  };
  HtmlRouteRedirectGuard.\u0275prov = \u0275\u0275defineInjectable(
      {token: HtmlRouteRedirectGuard, factory: HtmlRouteRedirectGuard.\u0275fac});
  (function() {
    setClassMetadata(HtmlRouteRedirectGuard, [{type: Injectable}], function() {
      return [{type: Router}];
    }, null);
  })();
  var routes = [
    {path: '404.html', component: NotFoundComponent},
    {component: EmptyComponent, canActivate: [HtmlRouteRedirectGuard], matcher: HtmlPageUrlMatcher},
    {path: '', pathMatch: 'full', redirectTo: 'docs/latest'},
    {path: 'docs/:version', component: DocRendererComponent},
    {path: 'docs/:version/:doc', component: DocRendererComponent},
    {path: '**', component: NotFoundComponent}
  ];
  var AppRoutingModule = class {};
  AppRoutingModule.\u0275mod = \u0275\u0275defineNgModule({type: AppRoutingModule});
  AppRoutingModule.\u0275inj = \u0275\u0275defineInjector({
    factory: function AppRoutingModule_Factory(t) {
      return new (t || AppRoutingModule)();
    },
    providers: [HtmlRouteRedirectGuard],
    imports: [
      [RouterModule.forRoot(routes, {anchorScrolling: 'enabled', scrollOffset: [0, 50]})],
      RouterModule
    ]
  });
  (function() {
    (typeof ngJitMode === 'undefined' || ngJitMode) &&
        \u0275\u0275setNgModuleScope(
            AppRoutingModule,
            {declarations: [EmptyComponent], imports: [RouterModule], exports: [RouterModule]});
  })();
  (function() {
    setClassMetadata(
        AppRoutingModule, [{
          type: NgModule,
          args: [{
            declarations: [EmptyComponent],
            providers: [HtmlRouteRedirectGuard],
            imports:
                [RouterModule.forRoot(routes, {anchorScrolling: 'enabled', scrollOffset: [0, 50]})],
            exports: [RouterModule]
          }]
        }],
        null, null);
  })();

  // bazel-out/darwin-fastbuild/bin/docs-site/src/app/title-bar/title-bar.component.mjs
  var TitleBarComponent = class {
    constructor() {
      this.isNavbarCollapsed = true;
    }
    ngOnInit() {}
  };
  TitleBarComponent.\u0275fac = function TitleBarComponent_Factory(t) {
    return new (t || TitleBarComponent)();
  };
  TitleBarComponent.\u0275cmp = \u0275\u0275defineComponent({
    type: TitleBarComponent,
    selectors: [['app-title-bar']],
    decls: 16,
    vars: 2,
    consts: [
      [1, 'navbar', 'navbar-inverse', 'navbar-fixed-top'], [1, 'container'], [1, 'navbar-header'],
      ['type', 'button', 1, 'navbar-toggle', 'collapsed', 3, 'click'], [1, 'sr-only'],
      [1, 'icon-bar'], ['routerLink', '/', 1, 'navbar-brand'],
      ['src', 'assets/bazel-navbar.svg', 1, 'navbar-logo'], [1, 'navbar-collapse'],
      [1, 'nav', 'navbar-nav', 'navbar-right'],
      ['href', 'https://github.com/bazelbuild/rules_nodejs']
    ],
    template: function TitleBarComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, 'nav', 0);
        \u0275\u0275elementStart(1, 'div', 1);
        \u0275\u0275elementStart(2, 'div', 2);
        \u0275\u0275elementStart(3, 'button', 3);
        \u0275\u0275listener(
            'click', function TitleBarComponent_Template_button_click_3_listener() {
              return ctx.isNavbarCollapsed = !ctx.isNavbarCollapsed;
            });
        \u0275\u0275elementStart(4, 'span', 4);
        \u0275\u0275text(5, 'Toggle navigation');
        \u0275\u0275elementEnd();
        \u0275\u0275element(6, 'span', 5);
        \u0275\u0275element(7, 'span', 5);
        \u0275\u0275element(8, 'span', 5);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(9, 'a', 6);
        \u0275\u0275element(10, 'img', 7);
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(11, 'div', 8);
        \u0275\u0275elementStart(12, 'ul', 9);
        \u0275\u0275elementStart(13, 'li');
        \u0275\u0275elementStart(14, 'a', 10);
        \u0275\u0275text(15, 'GitHub');
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        \u0275\u0275advance(11);
        \u0275\u0275classProp('collapse', ctx.isNavbarCollapsed);
      }
    },
    directives: [RouterLinkWithHref],
    styles: ['\n/*# sourceMappingURL=title-bar.component.css.map */'],
    changeDetection: 0
  });
  (function() {
    setClassMetadata(
        TitleBarComponent, [{
          type: Component,
          args: [{
            selector: 'app-title-bar',
            templateUrl: './title-bar.component.html',
            styleUrls: ['./title-bar.component.scss'],
            changeDetection: ChangeDetectionStrategy.OnPush
          }]
        }],
        function() {
          return [];
        },
        null);
  })();

  // bazel-out/darwin-fastbuild/bin/docs-site/src/app/sidenav/sidenav.component.mjs
  function SidenavComponent_ng_container_5_option_2_span_2_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, 'span');
      \u0275\u0275text(1, '(latest)');
      \u0275\u0275elementEnd();
    }
  }
  function SidenavComponent_ng_container_5_option_2_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, 'option', 12);
      \u0275\u0275text(1);
      \u0275\u0275template(
          2, SidenavComponent_ng_container_5_option_2_span_2_Template, 2, 0, 'span', 4);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      const version_r4 = ctx.$implicit;
      const selectedVesion_r1 = \u0275\u0275nextContext().ngIf;
      const ctx_r2 = \u0275\u0275nextContext();
      \u0275\u0275property('value', version_r4)('selected', version_r4 === selectedVesion_r1);
      \u0275\u0275advance(1);
      \u0275\u0275textInterpolate1(' ', version_r4, ' ');
      \u0275\u0275advance(1);
      \u0275\u0275property('ngIf', version_r4 === ctx_r2.latest);
    }
  }
  var _c02 = function() {
    return {exact: true};
  };
  function SidenavComponent_ng_container_5_ng_container_6_li_5_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, 'li', 13);
      \u0275\u0275elementStart(1, 'a', 14);
      \u0275\u0275text(2);
      \u0275\u0275elementEnd();
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      const page_r10 = ctx.$implicit;
      const selectedVesion_r1 = \u0275\u0275nextContext(2).ngIf;
      \u0275\u0275property('routerLinkActiveOptions', \u0275\u0275pureFunction0(4, _c02));
      \u0275\u0275advance(1);
      \u0275\u0275propertyInterpolate2(
          'routerLink', '/docs/', selectedVesion_r1, '/', page_r10.md, '');
      \u0275\u0275advance(1);
      \u0275\u0275textInterpolate(page_r10.title);
    }
  }
  function SidenavComponent_ng_container_5_ng_container_6_li_9_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, 'li', 13);
      \u0275\u0275elementStart(1, 'a', 14);
      \u0275\u0275text(2);
      \u0275\u0275elementEnd();
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      const page_r12 = ctx.$implicit;
      const selectedVesion_r1 = \u0275\u0275nextContext(2).ngIf;
      \u0275\u0275property('routerLinkActiveOptions', \u0275\u0275pureFunction0(4, _c02));
      \u0275\u0275advance(1);
      \u0275\u0275propertyInterpolate2(
          'routerLink', '/docs/', selectedVesion_r1, '/', page_r12.md, '');
      \u0275\u0275advance(1);
      \u0275\u0275textInterpolate(page_r12.title);
    }
  }
  function SidenavComponent_ng_container_5_ng_container_6_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementContainerStart(0);
      \u0275\u0275elementStart(1, 'ul', 5);
      \u0275\u0275elementStart(2, 'li', 13);
      \u0275\u0275elementStart(3, 'a', 14);
      \u0275\u0275text(4, 'Introduction');
      \u0275\u0275elementEnd();
      \u0275\u0275elementEnd();
      \u0275\u0275template(
          5, SidenavComponent_ng_container_5_ng_container_6_li_5_Template, 3, 5, 'li', 15);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, 'h3');
      \u0275\u0275text(7, 'Rules');
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(8, 'ul', 5);
      \u0275\u0275template(
          9, SidenavComponent_ng_container_5_ng_container_6_li_9_Template, 3, 5, 'li', 15);
      \u0275\u0275elementEnd();
      \u0275\u0275elementContainerEnd();
    }
    if (rf & 2) {
      const info_r7 = ctx.ngIf;
      const selectedVesion_r1 = \u0275\u0275nextContext().ngIf;
      \u0275\u0275advance(2);
      \u0275\u0275property('routerLinkActiveOptions', \u0275\u0275pureFunction0(4, _c02));
      \u0275\u0275advance(1);
      \u0275\u0275propertyInterpolate1('routerLink', '/docs/', selectedVesion_r1, '');
      \u0275\u0275advance(2);
      \u0275\u0275property('ngForOf', info_r7.page);
      \u0275\u0275advance(4);
      \u0275\u0275property('ngForOf', info_r7.rule);
    }
  }
  function SidenavComponent_ng_container_5_Template(rf, ctx) {
    if (rf & 1) {
      const _r16 = \u0275\u0275getCurrentView();
      \u0275\u0275elementContainerStart(0);
      \u0275\u0275elementStart(1, 'select', 10);
      \u0275\u0275listener(
          'change',
          function SidenavComponent_ng_container_5_Template_select_change_1_listener($event) {
            \u0275\u0275restoreView(_r16);
            const ctx_r15 = \u0275\u0275nextContext();
            return ctx_r15.onVersionSelect($event.target.value);
          });
      \u0275\u0275template(
          2, SidenavComponent_ng_container_5_option_2_Template, 3, 4, 'option', 11);
      \u0275\u0275pipe(3, 'async');
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, 'h3');
      \u0275\u0275text(5, 'rules_nodejs');
      \u0275\u0275elementEnd();
      \u0275\u0275template(
          6, SidenavComponent_ng_container_5_ng_container_6_Template, 10, 5, 'ng-container', 4);
      \u0275\u0275pipe(7, 'async');
      \u0275\u0275elementContainerEnd();
    }
    if (rf & 2) {
      const ctx_r0 = \u0275\u0275nextContext();
      \u0275\u0275advance(2);
      \u0275\u0275property('ngForOf', \u0275\u0275pipeBind1(3, 2, ctx_r0.versions$));
      \u0275\u0275advance(4);
      \u0275\u0275property('ngIf', \u0275\u0275pipeBind1(7, 4, ctx_r0.info$));
    }
  }
  var SidenavComponent = class {
    constructor(docs) {
      this.docs = docs;
      this.isSidebarClosed = true;
    }
    ngOnInit() {
      this.versions$ = this.docs.versions$;
      this.latest = this.docs.latest;
      this.info$ = this.docs.onVersionSelect().pipe(map((event) => event.info.navs));
      this.selectedVesion$ =
          this.docs.onVersionSelect().pipe(map((event) => event.version), startWith(this.latest));
    }
    onVersionSelect(selectedVersion) {
      this.docs.selectVersion(selectedVersion);
    }
  };
  SidenavComponent.\u0275fac = function SidenavComponent_Factory(t) {
    return new (t || SidenavComponent)(\u0275\u0275directiveInject(DocsService));
  };
  SidenavComponent.\u0275cmp = \u0275\u0275defineComponent({
    type: SidenavComponent,
    selectors: [['app-sidenav']],
    decls: 22,
    vars: 5,
    consts: [
      [1, 'col-md-2'],
      [1, 'btn', 'btn-default', 'btn-lg', 'btn-block', 'sidebar-toggle', 3, 'click'],
      [1, 'glyphicon', 'glyphicon-menu-hamburger'], [1, 'sidebar'], [4, 'ngIf'], [1, 'sidebar-nav'],
      ['href', 'https://github.com/bazelbuild/rules_nodejs/blob/master/CONTRIBUTING.md'],
      ['href', 'https://slack.bazel.build'],
      ['href', 'https://github.com/bazelbuild/rules_nodejs/issues'],
      ['href', 'https://github.com/bazelbuild/rules_nodejs'], [3, 'change'],
      [3, 'value', 'selected', 4, 'ngFor', 'ngForOf'], [3, 'value', 'selected'],
      ['routerLinkActive', 'active', 3, 'routerLinkActiveOptions'], [3, 'routerLink'],
      ['routerLinkActive', 'active', 3, 'routerLinkActiveOptions', 4, 'ngFor', 'ngForOf']
    ],
    template: function SidenavComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, 'div', 0);
        \u0275\u0275elementStart(1, 'a', 1);
        \u0275\u0275listener('click', function SidenavComponent_Template_a_click_1_listener() {
          return ctx.isSidebarClosed = !ctx.isSidebarClosed;
        });
        \u0275\u0275element(2, 'i', 2);
        \u0275\u0275text(3, ' Navigation ');
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(4, 'nav', 3);
        \u0275\u0275template(5, SidenavComponent_ng_container_5_Template, 8, 6, 'ng-container', 4);
        \u0275\u0275pipe(6, 'async');
        \u0275\u0275elementStart(7, 'h3');
        \u0275\u0275text(8, 'Community');
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(9, 'ul', 5);
        \u0275\u0275elementStart(10, 'li');
        \u0275\u0275elementStart(11, 'a', 6);
        \u0275\u0275text(12, 'Contribute to rules_nodejs');
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(13, 'li');
        \u0275\u0275elementStart(14, 'a', 7);
        \u0275\u0275text(15, 'Join #javascript on Slack');
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(16, 'li');
        \u0275\u0275elementStart(17, 'a', 8);
        \u0275\u0275text(18, 'Issue Tracker');
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(19, 'li');
        \u0275\u0275elementStart(20, 'a', 9);
        \u0275\u0275text(21, 'Github');
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        \u0275\u0275advance(4);
        \u0275\u0275classProp('collapse', ctx.isSidebarClosed);
        \u0275\u0275advance(1);
        \u0275\u0275property('ngIf', \u0275\u0275pipeBind1(6, 3, ctx.selectedVesion$));
      }
    },
    directives: [NgIf, NgForOf, RouterLinkActive, RouterLinkWithHref],
    pipes: [AsyncPipe],
    styles: ['\n/*# sourceMappingURL=sidenav.component.css.map */'],
    changeDetection: 0
  });
  (function() {
    setClassMetadata(
        SidenavComponent, [{
          type: Component,
          args: [{
            selector: 'app-sidenav',
            templateUrl: './sidenav.component.html',
            styleUrls: ['./sidenav.component.scss'],
            changeDetection: ChangeDetectionStrategy.OnPush
          }]
        }],
        function() {
          return [{type: DocsService}];
        },
        null);
  })();

  // bazel-out/darwin-fastbuild/bin/docs-site/src/app/toc/toc.component.mjs
  function TocComponent_ul_0_li_1_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, 'li');
      \u0275\u0275elementStart(1, 'a', 3);
      \u0275\u0275text(2);
      \u0275\u0275elementEnd();
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      const item_r3 = ctx.$implicit;
      \u0275\u0275classMapInterpolate1('toc-entry toc-h', item_r3.level, '');
      \u0275\u0275advance(1);
      \u0275\u0275property('href', item_r3.href, \u0275\u0275sanitizeUrl);
      \u0275\u0275advance(1);
      \u0275\u0275textInterpolate(item_r3.text);
    }
  }
  function TocComponent_ul_0_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, 'ul', 1);
      \u0275\u0275template(1, TocComponent_ul_0_li_1_Template, 3, 5, 'li', 2);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      const toc_r1 = ctx.ngIf;
      \u0275\u0275advance(1);
      \u0275\u0275property('ngForOf', toc_r1);
    }
  }
  var TocComponent = class {
    constructor(doc) {
      this.doc = doc;
    }
    ngOnInit() {
      this.toc$ = this.doc.onPageChange().pipe(map((event) => event.toc), startWith([]));
    }
  };
  TocComponent.\u0275fac = function TocComponent_Factory(t) {
    return new (t || TocComponent)(\u0275\u0275directiveInject(DocsService));
  };
  TocComponent.\u0275cmp = \u0275\u0275defineComponent({
    type: TocComponent,
    selectors: [['app-toc']],
    decls: 2,
    vars: 3,
    consts: [
      ['class', 'section-nav', 4, 'ngIf'], [1, 'section-nav'], [3, 'class', 4, 'ngFor', 'ngForOf'],
      [3, 'href']
    ],
    template: function TocComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275template(0, TocComponent_ul_0_Template, 2, 1, 'ul', 0);
        \u0275\u0275pipe(1, 'async');
      }
      if (rf & 2) {
        \u0275\u0275property('ngIf', \u0275\u0275pipeBind1(1, 1, ctx.toc$));
      }
    },
    directives: [NgIf, NgForOf],
    pipes: [AsyncPipe],
    styles: ['\n/*# sourceMappingURL=toc.component.css.map */'],
    changeDetection: 0
  });
  (function() {
    setClassMetadata(
        TocComponent, [{
          type: Component,
          args: [{
            selector: 'app-toc',
            templateUrl: './toc.component.html',
            styleUrls: ['./toc.component.scss'],
            changeDetection: ChangeDetectionStrategy.OnPush
          }]
        }],
        function() {
          return [{type: DocsService}];
        },
        null);
  })();

  // bazel-out/darwin-fastbuild/bin/docs-site/src/app/app.component.mjs
  function AppComponent_ng_container_10_li_5_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, 'li');
      \u0275\u0275element(1, 'i', 14);
      \u0275\u0275elementStart(2, 'a', 15);
      \u0275\u0275pipe(3, 'async');
      \u0275\u0275text(4, ' Edit this page ');
      \u0275\u0275elementEnd();
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      const meta_r1 = \u0275\u0275nextContext().ngIf;
      const ctx_r2 = \u0275\u0275nextContext();
      \u0275\u0275advance(2);
      \u0275\u0275propertyInterpolate2(
          'href', 'https://github.com/bazelbuild/rules_nodejs/tree/stable/docs-site/src/pages/',
          \u0275\u0275pipeBind1(3, 2, ctx_r2.version$), '/', meta_r1.md, '.md',
          \u0275\u0275sanitizeUrl);
    }
  }
  function AppComponent_ng_container_10_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementContainerStart(0);
      \u0275\u0275elementStart(1, 'li');
      \u0275\u0275element(2, 'i', 12);
      \u0275\u0275elementStart(3, 'a', 13);
      \u0275\u0275text(4, 'Create issue');
      \u0275\u0275elementEnd();
      \u0275\u0275elementEnd();
      \u0275\u0275template(5, AppComponent_ng_container_10_li_5_Template, 5, 4, 'li', 7);
      \u0275\u0275elementContainerEnd();
    }
    if (rf & 2) {
      const meta_r1 = ctx.ngIf;
      \u0275\u0275advance(3);
      \u0275\u0275propertyInterpolate1(
          'href',
          'https://github.com/bazelbuild/rules_nodejs/issues/new?title=Documentation issue: ',
          meta_r1.md, '&labels=question/docs', \u0275\u0275sanitizeUrl);
      \u0275\u0275advance(2);
      \u0275\u0275property('ngIf', meta_r1.nav === 'rule');
    }
  }
  var AppComponent = class {
    constructor(docs) {
      this.docs = docs;
      this.now = new Date();
    }
    ngOnInit() {
      this.meta$ = this.docs.onPageChange().pipe(map((event) => event.meta));
      this.version$ = this.docs.onVersionSelect().pipe(map((event) => event.version));
    }
  };
  AppComponent.\u0275fac = function AppComponent_Factory(t) {
    return new (t || AppComponent)(\u0275\u0275directiveInject(DocsService));
  };
  AppComponent.\u0275cmp = \u0275\u0275defineComponent({
    type: AppComponent,
    selectors: [['app-root']],
    decls: 20,
    vars: 7,
    consts: [
      [1, 'container', 'vpad'], [1, 'row'], [1, 'col-md-8'], [1, 'content'],
      [1, 'col-md-2', 'sticky-sidebar'], [1, 'right-sidebar'], [1, 'gh-links'], [4, 'ngIf'],
      [1, 'footer'], [1, 'container'], [1, 'col-lg-8'], [1, 'text-muted'], [1, 'fab', 'fa-github'],
      [3, 'href'], [1, 'far', 'fa-edit'], [1, 'gh-edit', 3, 'href']
    ],
    template: function AppComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275element(0, 'app-title-bar');
        \u0275\u0275elementStart(1, 'div', 0);
        \u0275\u0275elementStart(2, 'div', 1);
        \u0275\u0275element(3, 'app-sidenav');
        \u0275\u0275elementStart(4, 'div', 2);
        \u0275\u0275elementStart(5, 'div', 3);
        \u0275\u0275element(6, 'router-outlet');
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(7, 'div', 4);
        \u0275\u0275elementStart(8, 'div', 5);
        \u0275\u0275elementStart(9, 'ul', 6);
        \u0275\u0275template(10, AppComponent_ng_container_10_Template, 6, 2, 'ng-container', 7);
        \u0275\u0275pipe(11, 'async');
        \u0275\u0275elementEnd();
        \u0275\u0275element(12, 'app-toc');
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(13, 'footer', 8);
        \u0275\u0275elementStart(14, 'div', 9);
        \u0275\u0275elementStart(15, 'div', 1);
        \u0275\u0275elementStart(16, 'div', 10);
        \u0275\u0275elementStart(17, 'p', 11);
        \u0275\u0275text(18);
        \u0275\u0275pipe(19, 'date');
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        \u0275\u0275advance(10);
        \u0275\u0275property('ngIf', \u0275\u0275pipeBind1(11, 2, ctx.meta$));
        \u0275\u0275advance(8);
        \u0275\u0275textInterpolate1(
            '\xA9 ', \u0275\u0275pipeBind2(19, 4, ctx.now, 'Y'), ' The rules_nodejs authors');
      }
    },
    directives: [TitleBarComponent, SidenavComponent, RouterOutlet, NgIf, TocComponent],
    pipes: [AsyncPipe, DatePipe],
    styles: ['\n/*# sourceMappingURL=app.component.css.map */'],
    changeDetection: 0
  });
  (function() {
    setClassMetadata(
        AppComponent, [{
          type: Component,
          args: [{
            selector: 'app-root',
            templateUrl: './app.component.html',
            styleUrls: ['./app.component.scss'],
            changeDetection: ChangeDetectionStrategy.OnPush
          }]
        }],
        function() {
          return [{type: DocsService}];
        },
        null);
  })();

  // bazel-out/darwin-fastbuild/bin/docs-site/src/app/search/search.component.mjs
  var SearchComponent = class {
    constructor() {}
    ngOnInit() {}
  };
  SearchComponent.\u0275fac = function SearchComponent_Factory(t) {
    return new (t || SearchComponent)();
  };
  SearchComponent.\u0275cmp = \u0275\u0275defineComponent({
    type: SearchComponent,
    selectors: [['app-search']],
    decls: 2,
    vars: 0,
    template: function SearchComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, 'p');
        \u0275\u0275text(1, 'search doesn\'t work yet');
        \u0275\u0275elementEnd();
      }
    },
    styles: ['\n/*# sourceMappingURL=search.component.css.map */'],
    changeDetection: 0
  });
  (function() {
    setClassMetadata(
        SearchComponent, [{
          type: Component,
          args: [{
            selector: 'app-search',
            templateUrl: './search.component.html',
            styleUrls: ['./search.component.scss'],
            changeDetection: ChangeDetectionStrategy.OnPush
          }]
        }],
        function() {
          return [];
        },
        null);
  })();

  // bazel-out/darwin-fastbuild/bin/docs-site/src/app/app.module.mjs
  var DocsServiceInitializer = (docs) => () => docs.init();
  var AppModule = class {};
  AppModule.\u0275mod = \u0275\u0275defineNgModule({type: AppModule, bootstrap: [AppComponent]});
  AppModule.\u0275inj = \u0275\u0275defineInjector({
    factory: function AppModule_Factory(t) {
      return new (t || AppModule)();
    },
    providers: [{
      provide: APP_INITIALIZER,
      multi: true,
      deps: [DocsService],
      useFactory: DocsServiceInitializer
    }],
    imports: [[
      CommonModule, BrowserModule.withServerTransition({appId: 'docs'}), HttpClientModule,
      AppRoutingModule, MarkdownModule.forRoot({loader: HttpClient, sanitize: SecurityContext.NONE})
    ]]
  });
  (function() {
    (typeof ngJitMode === 'undefined' || ngJitMode) && \u0275\u0275setNgModuleScope(AppModule, {
      declarations: [
        AppComponent, TitleBarComponent, SidenavComponent, DocRendererComponent, NotFoundComponent,
        TocComponent, SearchComponent
      ],
      imports: [CommonModule, BrowserModule, HttpClientModule, AppRoutingModule, MarkdownModule]
    });
  })();
  (function() {
    setClassMetadata(
        AppModule, [{
          type: NgModule,
          args: [{
            declarations: [
              AppComponent, TitleBarComponent, SidenavComponent, DocRendererComponent,
              NotFoundComponent, TocComponent, SearchComponent
            ],
            imports: [
              CommonModule, BrowserModule.withServerTransition({appId: 'docs'}), HttpClientModule,
              AppRoutingModule,
              MarkdownModule.forRoot({loader: HttpClient, sanitize: SecurityContext.NONE})
            ],
            providers: [{
              provide: APP_INITIALIZER,
              multi: true,
              deps: [DocsService],
              useFactory: DocsServiceInitializer
            }],
            bootstrap: [AppComponent]
          }]
        }],
        null, null);
  })();

  // bazel-out/darwin-fastbuild/bin/docs-site/src/main.mjs
  platformBrowser().bootstrapModule(AppModule).catch((err) => console.error(err));
})();
//# sourceMappingURL=bundle.js.map
