import * as fs from 'fs';
import * as path from 'path';

import {LinkerAliases, LinkerTreeElement} from '../link_node_modules';

// The linker is imported through it's checked-in file. We do this because the import to
// the runfile helpers from the linker file will always resolve to the checked-in file too.
const linker: typeof import('../link_node_modules') = require('../index.js');
// As seen above, the linker file always loads the checked-in runfile helpers. We don't want
// to have a mix of checked-in files and sources, so we import runfile helpers from the
// checked-in file too, but use the types provided by the `@bazel/runfiles` package.
const {Runfiles}: typeof import('@bazel/runfiles') = require('../../runfiles/index.js');

const BIN_DIR = `bazel-out/my-platform-fastbuild/bin`;

function mkdirp(p: string) {
  if (!fs.existsSync(p)) {
    mkdirp(path.dirname(p));
    fs.mkdirSync(p);
  }
}

// Mock out the creation of the modules manifest
function writeManifest(o: {}) {
  fs.writeFileSync('manifest.json', JSON.stringify(o, null, 2), 'utf-8');
}

function writeRunfiles(manifest: string[]) {
  fs.writeFileSync('runfiles.mf', manifest.join('\n'), 'utf-8');
}

describe('link_node_modules', () => {
  let workspace: string;
  let runfilesWorkspace: string;

  beforeEach(() => {
    process.chdir(process.env['TEST_TMPDIR']!);
    // Prevent test isolation failures: each spec gets its own workspace
    workspace = `wksp_${Date.now()}`;
    runfilesWorkspace = `${workspace}/${BIN_DIR}/runfiles/${workspace}`;
    // Create our local workspace where the build is running
    mkdirp(runfilesWorkspace);
  });

  function getWorkspaceModulePath(...parts: string[]): string {
    return path.join(process.env['TEST_TMPDIR']!, workspace, 'node_modules', ...parts);
  }

  function readWorkspaceNodeModules(...parts: string[]): string {
    return fs.readFileSync(getWorkspaceModulePath(...parts), 'utf-8')
  }

  function hasWorkspaceNodeModule(...parts: string[]): boolean {
    return fs.existsSync(getWorkspaceModulePath(...parts))
  }

  describe('reduceModules', () => {
    it('should support no links', () => {
      expect(linker.reduceModules({})).toEqual([]);
    });

    it('should pull aligned child paths up', () => {
      const IN: LinkerAliases = {
        '@foo/a': `${BIN_DIR}/root/sub/a`,
        '@foo/a/b': `${BIN_DIR}/root/sub/a/b`,
        '@foo/a/1': `${BIN_DIR}/root/sub/a/1`,
        '@foo/a/2': `${BIN_DIR}/root/sub/a/2`,
      };
      const OUT: LinkerTreeElement[] =
          [{name: '@foo', children: [{name: '@foo/a', link: `${BIN_DIR}/root/sub/a`}]}];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should pull deep aligned child paths up', () => {
      const IN: LinkerAliases = {
        '@foo/a': `${BIN_DIR}/root/sub/a`,
        '@foo/a/b': `${BIN_DIR}/root/sub/a/b`,
        '@foo/a/b/1': `${BIN_DIR}/root/sub/a/b/1`,
        '@foo/a/b/2': `${BIN_DIR}/root/sub/a/b/2`,
      };
      const OUT: LinkerTreeElement[] =
          [{name: '@foo', children: [{name: '@foo/a', link: `${BIN_DIR}/root/sub/a`}]}];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not change aligned paths with a misaligned parent', () => {
      const IN: LinkerAliases = {
        '@foo/a': `${BIN_DIR}/root/sub/a`,
        '@foo/a/b': `${BIN_DIR}/root/sub/a/b`,
        '@foo/a/b/1': `${BIN_DIR}/root/sub/other/a/b/1`,
        '@foo/a/b/2': `${BIN_DIR}/root/sub/a/b/2`,
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        children: [{
          name: '@foo/a',
          link: `${BIN_DIR}/root/sub/a`,
          children: [{
            name: '@foo/a/b',
            link: `${BIN_DIR}/root/sub/a/b`,
            children: [
              {name: '@foo/a/b/1', link: `${BIN_DIR}/root/sub/other/a/b/1`},
              {name: '@foo/a/b/2', link: `${BIN_DIR}/root/sub/a/b/2`}
            ]
          }]
        }]
      }];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce parent/child when parent linking to different path', () => {
      const IN: LinkerAliases = {
        '@foo/a': `${BIN_DIR}/root/foo`,
        '@foo/a/b': `${BIN_DIR}/root/sub/a/b`,
        '@foo/a/b/1': `${BIN_DIR}/root/sub/a/b/1`,
        '@foo/a/b/2': `${BIN_DIR}/root/sub/a/b/2`,
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        children: [{
          name: '@foo/a',
          link: `${BIN_DIR}/root/foo`,
          children: [{name: '@foo/a/b', link: `${BIN_DIR}/root/sub/a/b`}]
        }]
      }];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should reduce aligned parent+children aliases to single parent alias', () => {
      const IN: LinkerAliases = {
        '@foo/a': `${BIN_DIR}/root/sub/a`,
        '@foo/a/1': `${BIN_DIR}/root/sub/a/1`,
        '@foo/a/2': `${BIN_DIR}/root/sub/a/2`,
      };
      const OUT: LinkerTreeElement[] =
          [{name: '@foo', children: [{name: '@foo/a', link: `${BIN_DIR}/root/sub/a`}]}];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should reduce deeply-aligned siblings', () => {
      const IN: LinkerAliases = {
        '@foo/a': `${BIN_DIR}/root/sub/a`,
        '@foo/a/b': `${BIN_DIR}/root/sub/a/b`,
        '@foo/a/b/c': `${BIN_DIR}/root/sub/a/b/c`,
        '@foo/a/b/c/d1': `${BIN_DIR}/root/sub/a/b/c/d1`,
        '@foo/a/b/c/d2': `${BIN_DIR}/root/sub/a/b/c/d2`,
      };
      const OUT: LinkerTreeElement[] =
          [{name: '@foo', children: [{name: '@foo/a', link: `${BIN_DIR}/root/sub/a`}]}];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce parent/child with different ancestor link paths', () => {
      const IN: LinkerAliases = {
        'b/b': 'external/other_wksp/path/to/lib_bb',
        'b': 'external/other_wksp/path/to/lib_b',
      };
      const OUT: LinkerTreeElement[] = [{
        name: 'b',
        link: 'external/other_wksp/path/to/lib_b',
        children: [{
          name: 'b/b',
          link: 'external/other_wksp/path/to/lib_bb',
        }],
      }];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce aligned paths when link has extra dir', () => {
      const IN: LinkerAliases = {
        '@foo/lib': `${BIN_DIR}/path/to/lib`,
        '@foo/lib/a': `${BIN_DIR}/path/to/lib/noseeme/a`,
        '@foo/lib/b': `${BIN_DIR}/path/to/lib/noseeme/b`,
        '@foo/lib/c': `${BIN_DIR}/path/to/lib/noseeme/c`,
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        children: [{
          name: '@foo/lib',
          link: `${BIN_DIR}/path/to/lib`,
          children: [
            {name: '@foo/lib/a', link: `${BIN_DIR}/path/to/lib/noseeme/a`},
            {name: '@foo/lib/b', link: `${BIN_DIR}/path/to/lib/noseeme/b`},
            {name: '@foo/lib/c', link: `${BIN_DIR}/path/to/lib/noseeme/c`}
          ]
        }]
      }];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce sibling mappings with inconsistent paths', () => {
      const IN: LinkerAliases = {
        '@foo/lib': `${BIN_DIR}/path/to/lib`,
        '@foo/lib/a': `${BIN_DIR}/path/to/lib/x`,
        '@foo/lib/b': `${BIN_DIR}/path/to/lib/b`,
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        children: [{
          name: '@foo/lib',
          link: `${BIN_DIR}/path/to/lib`,
          children: [
            {name: '@foo/lib/a', link: `${BIN_DIR}/path/to/lib/x`},
            {name: '@foo/lib/b', link: `${BIN_DIR}/path/to/lib/b`},
          ]
        }]
      }];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce sibling mappings with inconsistent path parents', () => {
      const IN: LinkerAliases = {
        '@foo/lib': `${BIN_DIR}/path/to/lib`,
        '@foo/lib/a': `${BIN_DIR}/path/to/lib/x/a`,
        '@foo/lib/b': `${BIN_DIR}/path/to/lib/b`,
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        children: [{
          name: '@foo/lib',
          link: `${BIN_DIR}/path/to/lib`,
          children: [
            {name: '@foo/lib/a', link: `${BIN_DIR}/path/to/lib/x/a`},
            {name: '@foo/lib/b', link: `${BIN_DIR}/path/to/lib/b`}
          ]
        }]
      }];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce to parent mapping with inconcsisten parent link path', () => {
      const IN: LinkerAliases = {
        '@foo/lib': `${BIN_DIR}/path/to/other/lib`,
        '@foo/lib/a': `${BIN_DIR}/path/to/lib/a`,
        '@foo/lib/b': `${BIN_DIR}/path/to/lib/b`,
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        children: [{
          name: '@foo/lib',
          link: `${BIN_DIR}/path/to/other/lib`,
          children: [
            {
              name: '@foo/lib/a',
              link: `${BIN_DIR}/path/to/lib/a`,
            },
            {
              name: '@foo/lib/b',
              link: `${BIN_DIR}/path/to/lib/b`,
            }
          ]
        }]
      }];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should reduce complicated example', () => {
      const IN: LinkerAliases = {
        'a': `path/to/lib_a`,
        '@foo/c/c/c/c': `${BIN_DIR}/path/to/foo_cccc`,
        'b/b': 'external/other_wksp/path/to/lib_bb',
        'b': 'external/other_wksp/path/to/lib_b',
        '@foo/c': `${BIN_DIR}/path/to/foo_c`,
        '@foo/c/c': `${BIN_DIR}/path/to/foo_cc`,
        '@foo/d/bar/fum/far': `${BIN_DIR}/path/to/foo_d/bar/fum/far`,
        '@foo/d/bar': `${BIN_DIR}/path/to/foo_d/bar`,
        // don't include `@foo/d` as the linker should derive that symlink
        // from the lowest common denominator of the module name & module path
      };
      const OUT: LinkerTreeElement[] = [
        {
          name: '@foo',
          children: [
            {
              name: '@foo/c',
              link: `${BIN_DIR}/path/to/foo_c`,
              children: [{
                name: '@foo/c/c',
                link: `${BIN_DIR}/path/to/foo_cc`,
                children: [{
                  name: '@foo/c/c/c',
                  children: [{
                    name: '@foo/c/c/c/c',
                    link: `${BIN_DIR}/path/to/foo_cccc`,
                  }]
                }]
              }]
            },
            {
              name: '@foo/d',
              children: [{
                name: '@foo/d/bar',
                link: `${BIN_DIR}/path/to/foo_d/bar`,
                children: [{
                  name: '@foo/d/bar/fum',
                  children: [{
                    name: '@foo/d/bar/fum/far',
                    link: `${BIN_DIR}/path/to/foo_d/bar/fum/far`,
                  }]
                }]
              }]
            }
          ]
        },
        {name: 'a', link: 'path/to/lib_a'}, {
          name: 'b',
          link: 'external/other_wksp/path/to/lib_b',
          children: [{name: 'b/b', link: 'external/other_wksp/path/to/lib_bb'}]
        }
      ];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });
  });

  it('should report when modules manifest absent', async () => {
    try {
      await (linker as any).main();
    } catch (expected) {
      expect(expected.message).toContain('requires one argument');
    }
    try {
      await (linker as any).main([]);
    } catch (expected) {
      expect(expected.message).toContain('requires one argument');
    }
    try {
      await (linker as any).main(['bad_path']);
    } catch (expected) {
      expect(expected.message).toContain('ENOENT');
    }
  });

  it('should handle first-party packages in workspace', async () => {
    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);

    // Create a package in the user workspace
    mkdirp('path/to/lib_a');
    fs.writeFileSync('path/to/lib_a/index.js', '/*a*/exports = {}', 'utf-8');

    // Create a nested package in a different workspace
    mkdirp('external/other_wksp/path/to/lib_b');
    fs.writeFileSync('external/other_wksp/path/to/lib_b/index.js', '/*b*/exports = {}', 'utf-8');
    mkdirp('external/other_wksp/path/to/lib_bb');
    fs.writeFileSync('external/other_wksp/path/to/lib_bb/index.js', '/*b/b*/exports = {}', 'utf-8');

    // Create a nested package in bazel-bin where module names don't match directory structure
    mkdirp(`${BIN_DIR}/path/to/foo_c`);
    fs.writeFileSync(`${BIN_DIR}/path/to/foo_c/index.js`, '/*@foo/c*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_cc`);
    fs.writeFileSync(`${BIN_DIR}/path/to/foo_cc/index.js`, '/*@foo/c/c*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_cccc`);
    fs.writeFileSync(
        `${BIN_DIR}/path/to/foo_cccc/index.js`, '/*@foo/c/c/c/c*/exports = {}', 'utf-8');

    // Create a nested package in bazel-bin where module names match directory structure
    mkdirp(`${BIN_DIR}/path/to/foo_d`);
    fs.writeFileSync(`${BIN_DIR}/path/to/foo_d/index.js`, '/*@foo/d*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_d/bar`);
    fs.writeFileSync(
        `${BIN_DIR}/path/to/foo_d/bar/index.js`, '/*@foo/d/bar*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_d/bar/fum/far`);
    fs.writeFileSync(
        `${BIN_DIR}/path/to/foo_d/bar/fum/far/index.js`, '/*@foo/d/bar/fum/far*/exports = {}',
        'utf-8');

    writeManifest({
      bin: BIN_DIR,
      // intentionally out of order so that linker has to sort
      // and create nested modules in the correct order
      module_sets: {
        '': {
          'a': `path/to/lib_a`,
          '@foo/c/c/c/c': `${BIN_DIR}/path/to/foo_cccc`,
          'b/b': 'external/other_wksp/path/to/lib_bb',
          'b': 'external/other_wksp/path/to/lib_b',
          '@foo/c': `${BIN_DIR}/path/to/foo_c`,
          '@foo/c/c': `${BIN_DIR}/path/to/foo_cc`,
          '@foo/d/bar/fum/far': `${BIN_DIR}/path/to/foo_d/bar/fum/far`,
          '@foo/d/bar': `${BIN_DIR}/path/to/foo_d/bar`,
          '@foo/d': `${BIN_DIR}/path/to/foo_d`,
        },
      },
      workspace: workspace,
    });

    // TODO(alexeagle): test should control the environment, not just pass through
    await linker.main(['manifest.json'], new Runfiles(process.env));

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join());
    expect(readWorkspaceNodeModules('a', 'index.js')).toEqual('/*a*/exports = {}');
    expect(readWorkspaceNodeModules('b', 'index.js')).toEqual('/*b*/exports = {}');
    expect(readWorkspaceNodeModules('b', 'b', 'index.js')).toEqual('/*b/b*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'c', 'index.js')).toEqual('/*@foo/c*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'c', 'c', 'index.js'))
        .toEqual('/*@foo/c/c*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'c', 'c', 'c', 'c', 'index.js'))
        .toEqual('/*@foo/c/c/c/c*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'd', 'index.js')).toEqual('/*@foo/d*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'd', 'bar', 'index.js'))
        .toEqual('/*@foo/d/bar*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'd', 'bar', 'fum', 'far', 'index.js'))
        .toEqual('/*@foo/d/bar/fum/far*/exports = {}');
  });

  it('should create link at higher level if directory already exists from past run', async () => {
    const workspacePath = path.join(process.env['TEST_TMPDIR']!, workspace);
    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspacePath);

    // Create a package in the user workspace
    mkdirp(`${BIN_DIR}/src/cdk/bidi`);
    mkdirp(`${BIN_DIR}/src/other-core-folder`);
    fs.writeFileSync(`${BIN_DIR}/src/cdk/index.js`, '/*cdk/index*/exports = {}', 'utf-8');
    fs.writeFileSync(`${BIN_DIR}/src/cdk/bidi/index.js`, '/*cdk/bidi/index*/exports = {}', 'utf-8');
    fs.writeFileSync(`${BIN_DIR}/src/other-core-folder/index.js`, `/*other-core*/`, 'utf-8');

    writeRunfiles([]);
    writeManifest({
      bin: BIN_DIR,
      workspace: workspace,
      module_sets: {
        '': {
          '@angular/cdk/bidi': `${BIN_DIR}/src/cdk/bidi`,
          '@angular/cdk/core': `${BIN_DIR}/src/other-core-folder`,
        },
      },
    });

    await linker.main(['manifest.json'], new Runfiles({
      // This test assumes an environment where runfiles are not symlinked. Hence
      // we pass a runfile manifest file.
      'RUNFILES_MANIFEST_FILE': 'runfiles.mf',
    }));

    expect(readWorkspaceNodeModules('@angular', 'cdk', 'bidi', 'index.js'))
      .toEqual('/*cdk/bidi/index*/exports = {}');
    expect(readWorkspaceNodeModules('@angular', 'cdk', 'core', 'index.js'))
      .toEqual('/*other-core*/');
    expect(hasWorkspaceNodeModule('@angular', 'cdk', 'index.js')).toBe(false);

    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspacePath);

    writeManifest({
      bin: BIN_DIR,
      workspace: workspace,
      module_sets: {
        '': {
          '@angular/cdk': `${BIN_DIR}/src/cdk`,
          '@angular/cdk/bidi': `${BIN_DIR}/src/cdk/bidi`,
          '@angular/cdk/core': `${BIN_DIR}/src/other-core-folder`,
        },
      },
    });

    // In the second run, we added a mapping for `@angular/cdk`. This means
    // that the linker would need to clean up the previous `cdk/bidi` link
    // in order to be able to create a link for `@angular/cdk`.
    await linker.main(['manifest.json'], new Runfiles({
      // This test assumes an environment where runfiles are not symlinked. Hence
      // we pass a runfile manifest file.
      'RUNFILES_MANIFEST_FILE': 'runfiles.mf',
    }));

    expect(readWorkspaceNodeModules('@angular', 'cdk', 'bidi', 'index.js'))
      .toEqual('/*cdk/bidi/index*/exports = {}');
    expect(readWorkspaceNodeModules('@angular', 'cdk', 'core', 'index.js'))
      .toEqual('/*other-core*/');
    expect(readWorkspaceNodeModules('@angular', 'cdk', 'index.js'))
      .toEqual('/*cdk/index*/exports = {}');
  });

  it('should handle first-party packages with single parent link', async () => {
    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);

    // Create sub-packages to a lib in the user workspace
    mkdirp(`${BIN_DIR}/path/to/lib/a`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib/a/index.js`, '/*a*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/lib/b`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib/b/index.js`, '/*b*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/lib/c`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib/c/index.js`, '/*c*/exports = {}', 'utf-8');

    writeManifest({
      bin: BIN_DIR,
      module_sets: {
        '': {
          '@foo/lib/a': `${BIN_DIR}/path/to/lib/a`,
          '@foo/lib/b': `${BIN_DIR}/path/to/lib/b`,
          '@foo/lib/c': `${BIN_DIR}/path/to/lib/c`,
        },
      },
      workspace: workspace,
    });

    // TODO(alexeagle): test should control the environment, not just pass through
    await linker.main(['manifest.json'], new Runfiles(process.env));

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join());
    expect(readWorkspaceNodeModules('@foo', 'lib', 'a', 'index.js')).toEqual('/*a*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'b', 'index.js')).toEqual('/*b*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'c', 'index.js')).toEqual('/*c*/exports = {}');
  });

  it('should handle first-party packages with sibling links in shared parent', async () => {
    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);

    // Create sub-packages to a lib in the user workspace
    mkdirp(`${BIN_DIR}/path/to/lib/x`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib/x/index.js`, '/*a*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/lib/b`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib/b/index.js`, '/*b*/exports = {}', 'utf-8');
    mkdirp('path/to/lib/c');
    fs.writeFileSync('path/to/lib/c/index.js', '/*c*/exports = {}', 'utf-8');

    writeManifest({
      bin: BIN_DIR,
      module_sets: {
        '': {
          '@foo/lib/a': `${BIN_DIR}/path/to/lib/x`,
          '@foo/lib/b': `${BIN_DIR}/path/to/lib/b`,
          '@foo/lib/c': `path/to/lib/c`,
        },
      },
      workspace: workspace,
    });

    // TODO(alexeagle): test should control the environment, not just pass through
    await linker.main(['manifest.json'], new Runfiles(process.env));

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join());
    expect(readWorkspaceNodeModules('@foo', 'lib', 'a', 'index.js')).toEqual('/*a*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'b', 'index.js')).toEqual('/*b*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'c', 'index.js')).toEqual('/*c*/exports = {}');
  });

  it('should handle first-party packages with miss-aligned nested links', async () => {
    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);

    // Create sub-packages to a lib in the user workspace
    mkdirp(`${BIN_DIR}/path/to/other/lib`);
    fs.writeFileSync(`${BIN_DIR}/path/to/other/lib/index.js`, '/*root*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo/a`);
    fs.writeFileSync(`${BIN_DIR}/path/to/foo/a/index.js`, '/*a*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/bar/b`);
    fs.writeFileSync(`${BIN_DIR}/path/to/bar/b/index.js`, '/*ab*/exports = {}', 'utf-8');

    writeManifest({
      bin: BIN_DIR,
      module_sets: {
        '': {
          '@foo/lib': `${BIN_DIR}/path/to/other/lib`,
          '@foo/lib/a': `${BIN_DIR}/path/to/foo/a`,
          '@foo/lib/a/b': `${BIN_DIR}/path/to/bar/b`,
        },
      },
      workspace: workspace,
    });

    // TODO(alexeagle): test should control the environment, not just pass through
    await linker.main(['manifest.json'], new Runfiles(process.env));

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join());
    expect(readWorkspaceNodeModules('@foo', 'lib', 'index.js')).toEqual('/*root*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'a', 'index.js')).toEqual('/*a*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'a', 'b', 'index.js'))
        .toEqual('/*ab*/exports = {}');
  });

  it('should handle external npm packages in runfiles', async () => {
    mkdirp('npm/node_modules/some-package');
    const idx = 'npm/node_modules/some-package/index.js';
    fs.writeFileSync(idx, 'exports = {}', 'utf-8');
    const runfilesManifest = [`${idx} ${path.resolve(idx)}`];

    // Set the cwd() like Bazel would in the runfiles
    process.chdir(runfilesWorkspace);

    // No first-party packages
    writeManifest({
      bin: BIN_DIR,
      module_sets: {
        '': {
          'some-package': `external/npm/node_modules/some-package`,
        },
      },
      workspace: workspace,
    });
    writeRunfiles(runfilesManifest);

    await linker.main(['manifest.json'], new Runfiles({
      'RUNFILES_MANIFEST_FILE': 'runfiles.mf',
    }));

    // We expect the linker to symlink node_modules to `execroot/my_wksp/node_modules` when
    // under runfiles
    expect(fs.readdirSync(
               path.join(process.env['TEST_TMPDIR']!, workspace, 'node_modules', 'some-package')))
        .toContain('index.js');
  });
});
