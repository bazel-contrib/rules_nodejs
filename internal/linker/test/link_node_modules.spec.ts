import * as fs from 'fs';
import * as path from 'path';

import * as linker from '../link_node_modules';

const BIN_DIR = `bazel-out/my-platform-fastbuild/bin`;

function mkdirp(p: string) {
  if (!fs.existsSync(p)) {
    mkdirp(path.dirname(p));
    fs.mkdirSync(p);
  }
}

// Mock out the creation of the modules manifest
function writeManifest(o: {}) {
  fs.writeFileSync('manifest.json', JSON.stringify(o, null, 2), 'utf-8');
}

function writeRunfiles(manifest: string[]) {
  fs.writeFileSync('runfiles.mf', manifest.join('\n'), 'utf-8');
}

describe('link_node_modules', () => {
  let workspace: string;

  beforeEach(() => {
    process.chdir(process.env['TEST_TMPDIR']!);
    // Prevent test isolation failures: each spec gets its own workspace
    workspace = `wksp_${Date.now()}`;
    // Create our local workspace where the build is running
    mkdirp(workspace);
  });

  it('should group and reduce modules appropriate', () => {
    const modules = {
      'a': ['src', `${workspace}/path/to/lib_a`],
      '@foo/c/c/c/c': ['bin', `${workspace}/path/to/foo_cccc`],
      'b/b': ['src', 'other_wksp/path/to/lib_bb'],
      'b': ['src', 'other_wksp/path/to/lib_b'],
      '@foo/c': ['bin', `${workspace}/path/to/foo_c`],
      '@foo/c/c': ['bin', `${workspace}/path/to/foo_cc`],
      '@foo/d/bar/fum/far': ['bin', `${workspace}/path/to/foo_d/bar/fum/far`],
      '@foo/d/bar': ['bin', `${workspace}/path/to/foo_d/bar`],
      // don't include `@foo/d` as the group & reduce function  should derive that
      // from the lowest common denominator of the module name & module path
    };

    const result = linker.groupAndReduceModules(modules);

    const expected = [
      [
        // `@foo/c`, `@foo/c/c` and `@foo/c/c/c/c` should
        // be grouped but not reduced as their arrangement
        // on disk does not match the modules names
        {'name': '@foo/c', 'root': 'bin', 'modulePath': `${workspace}/path/to/foo_c`},
        {'name': '@foo/c/c', 'root': 'bin', 'modulePath': `${workspace}/path/to/foo_cc`},
        {'name': '@foo/c/c/c/c', 'root': 'bin', 'modulePath': `${workspace}/path/to/foo_cccc`}
      ],
      [
        // `@foo/d/bar/fum/far` and `@foo/d/bar` should
        // be grouped and reduced to `@foo/d`
        {'name': '@foo/d', 'root': 'bin', 'modulePath': `${workspace}/path/to/foo_d`},
      ],
      [{'name': 'a', 'root': 'src', 'modulePath': `${workspace}/path/to/lib_a`}],
      [
        // `b`, `b/b` should be grouped but not reduced as
        // their arrangement on disk does not match the modules names
        {'name': 'b', 'root': 'src', 'modulePath': 'other_wksp/path/to/lib_b'},
        {'name': 'b/b', 'root': 'src', 'modulePath': 'other_wksp/path/to/lib_bb'}
      ]
    ];

    expect(JSON.stringify(result)).toEqual(JSON.stringify(expected));
  })

  it('should report when modules manifest absent', async () => {
    try {
      await (linker as any).main();
    } catch (expected) {
      expect(expected.message).toContain('requires one argument');
    }
    try {
      await (linker as any).main([]);
    } catch (expected) {
      expect(expected.message).toContain('requires one argument');
    }
    try {
      await (linker as any).main(['bad_path']);
    } catch (expected) {
      expect(expected.message).toContain('ENOENT');
    }
  });

  it('should handle first-party packages in workspace', async () => {
    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);

    // Create a package in the user workspace
    mkdirp('path/to/lib_a');
    fs.writeFileSync('path/to/lib_a/index.js', '/*a*/exports = {}', 'utf-8');

    // Create a nested package in a different workspace
    mkdirp('external/other_wksp/path/to/lib_b');
    fs.writeFileSync('external/other_wksp/path/to/lib_b/index.js', '/*b*/exports = {}', 'utf-8');
    mkdirp('external/other_wksp/path/to/lib_bb');
    fs.writeFileSync('external/other_wksp/path/to/lib_bb/index.js', '/*b/b*/exports = {}', 'utf-8');

    // Create a nested package in bazel-bin where module names don't match directory structure
    mkdirp(`${BIN_DIR}/path/to/foo_c`);
    fs.writeFileSync(`${BIN_DIR}/path/to/foo_c/index.js`, '/*@foo/c*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_cc`);
    fs.writeFileSync(`${BIN_DIR}/path/to/foo_cc/index.js`, '/*@foo/c/c*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_cccc`);
    fs.writeFileSync(
        `${BIN_DIR}/path/to/foo_cccc/index.js`, '/*@foo/c/c/c/c*/exports = {}', 'utf-8');

    // Create a nested package in bazel-bin where module names match directory structure
    mkdirp(`${BIN_DIR}/path/to/foo_d`);
    fs.writeFileSync(`${BIN_DIR}/path/to/foo_d/index.js`, '/*@foo/d*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_d/bar`);
    fs.writeFileSync(
        `${BIN_DIR}/path/to/foo_d/bar/index.js`, '/*@foo/d/bar*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_d/bar/fum/far`);
    fs.writeFileSync(
        `${BIN_DIR}/path/to/foo_d/bar/fum/far/index.js`, '/*@foo/d/bar/fum/far*/exports = {}',
        'utf-8');

    writeManifest({
      'bin': BIN_DIR,
      // intentionally out of order so that linker has to sort
      // and create nested modules in the correct order
      'modules': {
        'a': ['src', `${workspace}/path/to/lib_a`],
        '@foo/c/c/c/c': ['bin', `${workspace}/path/to/foo_cccc`],
        'b/b': ['src', 'other_wksp/path/to/lib_bb'],
        'b': ['src', 'other_wksp/path/to/lib_b'],
        '@foo/c': ['bin', `${workspace}/path/to/foo_c`],
        '@foo/c/c': ['bin', `${workspace}/path/to/foo_cc`],
        '@foo/d/bar/fum/far': ['bin', `${workspace}/path/to/foo_d/bar/fum/far`],
        '@foo/d/bar': ['bin', `${workspace}/path/to/foo_d/bar`],
        // don't include `@foo/d` as the linker should derive that symlink
        // from the lowest common denominator of the module name & module path
      },
      'workspace': workspace,
    });

    // TODO(alexeagle): test should control the environment, not just pass through
    await linker.main(['manifest.json'], new linker.Runfiles(process.env));

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join());
    expect(fs.readFileSync(
               path.join(process.env['TEST_TMPDIR']!, workspace, 'node_modules', 'a', 'index.js'),
               'utf-8'))
        .toEqual('/*a*/exports = {}');
    expect(fs.readFileSync(
               path.join(process.env['TEST_TMPDIR']!, workspace, 'node_modules', 'b', 'index.js'),
               'utf-8'))
        .toEqual('/*b*/exports = {}');
    expect(
        fs.readFileSync(
            path.join(process.env['TEST_TMPDIR']!, workspace, 'node_modules', 'b', 'b', 'index.js'),
            'utf-8'))
        .toEqual('/*b/b*/exports = {}');
    expect(fs.readFileSync(
               path.join(
                   process.env['TEST_TMPDIR']!, workspace, 'node_modules', '@foo', 'c', 'index.js'),
               'utf-8'))
        .toEqual('/*@foo/c*/exports = {}');
    expect(fs.readFileSync(
               path.join(
                   process.env['TEST_TMPDIR']!, workspace, 'node_modules', '@foo', 'c', 'c',
                   'index.js'),
               'utf-8'))
        .toEqual('/*@foo/c/c*/exports = {}');
    expect(fs.readFileSync(
               path.join(
                   process.env['TEST_TMPDIR']!, workspace, 'node_modules', '@foo', 'c', 'c', 'c',
                   'c', 'index.js'),
               'utf-8'))
        .toEqual('/*@foo/c/c/c/c*/exports = {}');
    expect(fs.readFileSync(
               path.join(
                   process.env['TEST_TMPDIR']!, workspace, 'node_modules', '@foo', 'd', 'index.js'),
               'utf-8'))
        .toEqual('/*@foo/d*/exports = {}');
    expect(fs.readFileSync(
               path.join(
                   process.env['TEST_TMPDIR']!, workspace, 'node_modules', '@foo', 'd', 'bar',
                   'index.js'),
               'utf-8'))
        .toEqual('/*@foo/d/bar*/exports = {}');
    expect(fs.readFileSync(
               path.join(
                   process.env['TEST_TMPDIR']!, workspace, 'node_modules', '@foo', 'd', 'bar',
                   'fum', 'far', 'index.js'),
               'utf-8'))
        .toEqual('/*@foo/d/bar/fum/far*/exports = {}');
  });

  it('should handle third-party packages in runfiles', async () => {
    mkdirp('npm/node_modules/some-package');
    const idx = 'npm/node_modules/some-package/index.js';
    fs.writeFileSync(idx, 'exports = {}', 'utf-8');
    const runfilesManifest = [`${idx} ${path.resolve(idx)}`];

    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);
    // No first-party packages
    writeManifest({
      'bin': BIN_DIR,
      'root': 'npm/node_modules',
    });
    writeRunfiles(runfilesManifest);

    await linker.main(['manifest.json'], new linker.Runfiles({
      'RUNFILES_MANIFEST_FILE': 'runfiles.mf',
    }));

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join(process.env['TEST_TMPDIR']!, workspace));
    expect(fs.readdirSync(path.join('node_modules', 'some-package'))).toContain('index.js');
  });
});