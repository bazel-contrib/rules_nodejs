import * as fs from 'fs';
import * as path from 'path';

import * as linker from '../link_node_modules';
import {LinkerAliases, LinkerTreeElement} from '../link_node_modules';

const BIN_DIR = `bazel-out/my-platform-fastbuild/bin`;

function mkdirp(p: string) {
  if (!fs.existsSync(p)) {
    mkdirp(path.dirname(p));
    fs.mkdirSync(p);
  }
}

// Mock out the creation of the modules manifest
function writeManifest(o: {}) {
  fs.writeFileSync('manifest.json', JSON.stringify(o, null, 2), 'utf-8');
}

function writeRunfiles(manifest: string[]) {
  fs.writeFileSync('runfiles.mf', manifest.join('\n'), 'utf-8');
}

describe('link_node_modules', () => {
  let workspace: string;

  beforeEach(() => {
    process.chdir(process.env['TEST_TMPDIR']!);
    // Prevent test isolation failures: each spec gets its own workspace
    workspace = `wksp_${Date.now()}`;
    // Create our local workspace where the build is running
    mkdirp(workspace);
  });

  function readWorkspaceNodeModules(...parts: string[]) {
    const filePath = path.join(process.env['TEST_TMPDIR']!, workspace, 'node_modules', ...parts);
    return fs.readFileSync(filePath, 'utf-8')
  }

  describe('reduceModules', () => {
    it('should support no links', () => {
      expect(linker.reduceModules({})).toEqual([]);
    });

    it('should pull aligned child paths up', () => {
      const IN: LinkerAliases = {
        '@foo/a/1': ['bin', 'root/sub/a/1'],
        '@foo/a/2': ['bin', 'root/sub/a/2'],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        link: ['bin', 'root/sub'],
      }];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should pull deep aligned child paths up', () => {
      const IN: LinkerAliases = {
        '@foo/a/b/1': ['bin', 'root/sub/a/b/1'],
        '@foo/a/b/2': ['bin', 'root/sub/a/b/2'],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        link: ['bin', 'root/sub'],
      }];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not change aligned paths with a misaligned parent', () => {
      const IN: LinkerAliases = {
        '@foo/a/b/1': ['bin', 'root/sub/other/a/b/1'],
        '@foo/a/b/2': ['bin', 'root/sub/a/b/2'],
      };
      const OUT: LinkerTreeElement[] = [{
        'name': '@foo/a/b',
        'children': [
          {'name': '@foo/a/b/1', 'link': ['bin', 'root/sub/other/a/b/1']},
          {'name': '@foo/a/b/2', 'link': ['bin', 'root/sub/a/b/2']},
        ],
      }];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce parent/child when parent linking to different path', () => {
      const IN: LinkerAliases = {
        '@foo/a': ['bin', 'root/foo'],
        '@foo/a/b/1': ['bin', 'root/sub/a/b/1'],
        '@foo/a/b/2': ['bin', 'root/sub/a/b/2'],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo/a',
        link: ['bin', 'root/foo'],
        children: [{
          name: '@foo/a/b',
          link: ['bin', 'root/sub/a/b'],
        }],
      }];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should reduce aligned parent+children aliases to single parent alias', () => {
      const IN: LinkerAliases = {
        '@foo/a': ['bin', 'root/sub/a'],
        '@foo/a/1': ['bin', 'root/sub/a/1'],
        '@foo/a/2': ['bin', 'root/sub/a/2'],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        link: ['bin', 'root/sub'],
      }];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce parent+children aliases aligned to different link types', () => {
      const IN: LinkerAliases = {
        '@foo/a': ['bin', 'root/sub/a'],
        '@foo/a/1': ['runfiles', 'root/sub/a/1'],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo/a',
        link: ['bin', 'root/sub/a'],
        children: [
          {
            name: '@foo/a/1',
            link: ['runfiles', 'root/sub/a/1'],
          },
        ],
      }];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce sibling aliases with different link types', () => {
      const IN: LinkerAliases = {
        '@foo/a/1': ['runfiles', 'root/sub/a/1'],
        '@foo/a/2': ['bin', 'root/sub/a/2'],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo/a',
        children: [
          {
            name: '@foo/a/1',
            link: ['runfiles', 'root/sub/a/1'],
          },
          {
            name: '@foo/a/2',
            link: ['bin', 'root/sub/a/2'],
          },
        ],
      }];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should reduce deeply-aligned siblings', () => {
      const IN: LinkerAliases = {
        '@foo/a/b/c/d1': ['bin', 'root/sub/a/b/c/d1'],
        '@foo/a/b/c/d2': ['bin', 'root/sub/a/b/c/d2'],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        link: ['bin', 'root/sub'],
      }];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce parent/child with different ancestor link paths', () => {
      const IN: LinkerAliases = {
        'b/b': ['src', 'other_wksp/path/to/lib_bb'],
        'b': ['src', 'other_wksp/path/to/lib_b'],
      };
      const OUT: LinkerTreeElement[] = [{
        name: 'b',
        link: ['src', 'other_wksp/path/to/lib_b'],
        children: [{
          name: 'b/b',
          link: ['src', 'other_wksp/path/to/lib_bb'],
        }],
      }];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce aligned paths when link has extra dir', () => {
      const IN: LinkerAliases = {
        '@foo/lib/a': ['bin', 'path/to/lib/noseeme/a'],
        '@foo/lib/b': ['bin', 'path/to/lib/noseeme/b'],
        '@foo/lib/c': ['bin', 'path/to/lib/noseeme/c'],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo/lib',
        link: ['bin', 'path/to/lib/noseeme'],
      }];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce sibling mappings with inconsistent paths', () => {
      const IN: LinkerAliases = {
        '@foo/lib/a': ['bin', 'path/to/lib/x'],
        '@foo/lib/b': ['bin', 'path/to/lib/b'],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo/lib',
        children: [
          {
            name: '@foo/lib/a',
            link: ['bin', 'path/to/lib/x'],
          },
          {
            name: '@foo/lib/b',
            link: ['bin', 'path/to/lib/b'],
          },
        ],
      }];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce sibling mappins with inconsistent path parents', () => {
      const IN: LinkerAliases = {
        '@foo/lib/a': ['bin', 'path/to/lib/x/a'],
        '@foo/lib/b': ['bin', 'path/to/lib/b'],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo/lib',
        children: [
          {
            name: '@foo/lib/a',
            link: ['bin', 'path/to/lib/x/a'],
          },
          {
            name: '@foo/lib/b',
            link: ['bin', 'path/to/lib/b'],
          },
        ],
      }];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce to parent mapping with inconcsisten parent link path', () => {
      const IN: LinkerAliases = {
        '@foo/lib': ['bin', 'path/to/other/lib'],
        '@foo/lib/a': ['bin', 'path/to/lib/a'],
        '@foo/lib/b': ['bin', 'path/to/lib/b'],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo/lib',
        link: ['bin', 'path/to/other/lib'],
        children: [
          {
            name: '@foo/lib/a',
            link: ['bin', 'path/to/lib/a'],
          },
          {
            name: '@foo/lib/b',
            link: ['bin', 'path/to/lib/b'],
          },
        ],
      }];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should reduce complicated example', () => {
      const IN: LinkerAliases = {
        'a': ['src', `wksp/path/to/lib_a`],
        '@foo/c/c/c/c': ['bin', `wksp/path/to/foo_cccc`],
        'b/b': ['src', 'other_wksp/path/to/lib_bb'],
        'b': ['src', 'other_wksp/path/to/lib_b'],
        '@foo/c': ['bin', `wksp/path/to/foo_c`],
        '@foo/c/c': ['bin', `wksp/path/to/foo_cc`],
        '@foo/d/bar/fum/far': ['bin', `wksp/path/to/foo_d/bar/fum/far`],
        '@foo/d/bar': ['bin', `wksp/path/to/foo_d/bar`],
        // don't include `@foo/d` as the linker should derive that symlink
        // from the lowest common denominator of the module name & module path
      };
      const OUT: LinkerTreeElement[] = [
        {
          name: '@foo',
          children: [
            {
              name: '@foo/c',
              link: ['bin', `wksp/path/to/foo_c`],
              children: [{
                name: '@foo/c/c',
                link: ['bin', `wksp/path/to/foo_cc`],
                children: [{
                  name: '@foo/c/c/c/c',
                  link: ['bin', `wksp/path/to/foo_cccc`],
                }]
              }]
            },
            {
              name: '@foo/d',
              link: ['bin', `wksp/path/to/foo_d`],
            },
          ],
        },
        {
          name: 'a',
          link: ['src', `wksp/path/to/lib_a`],
        },
        {
          name: 'b',
          link: ['src', 'other_wksp/path/to/lib_b'],
          children: [{
            name: 'b/b',
            link: ['src', 'other_wksp/path/to/lib_bb'],
          }],
        }
      ];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });
  });

  it('should report when modules manifest absent', async () => {
    try {
      await (linker as any).main();
    } catch (expected) {
      expect(expected.message).toContain('requires one argument');
    }
    try {
      await (linker as any).main([]);
    } catch (expected) {
      expect(expected.message).toContain('requires one argument');
    }
    try {
      await (linker as any).main(['bad_path']);
    } catch (expected) {
      expect(expected.message).toContain('ENOENT');
    }
  });

  it('should handle first-party packages in workspace', async () => {
    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);

    // Create a package in the user workspace
    mkdirp('path/to/lib_a');
    fs.writeFileSync('path/to/lib_a/index.js', '/*a*/exports = {}', 'utf-8');

    // Create a nested package in a different workspace
    mkdirp('external/other_wksp/path/to/lib_b');
    fs.writeFileSync('external/other_wksp/path/to/lib_b/index.js', '/*b*/exports = {}', 'utf-8');
    mkdirp('external/other_wksp/path/to/lib_bb');
    fs.writeFileSync('external/other_wksp/path/to/lib_bb/index.js', '/*b/b*/exports = {}', 'utf-8');

    // Create a nested package in bazel-bin where module names don't match directory structure
    mkdirp(`${BIN_DIR}/path/to/foo_c`);
    fs.writeFileSync(`${BIN_DIR}/path/to/foo_c/index.js`, '/*@foo/c*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_cc`);
    fs.writeFileSync(`${BIN_DIR}/path/to/foo_cc/index.js`, '/*@foo/c/c*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_cccc`);
    fs.writeFileSync(
        `${BIN_DIR}/path/to/foo_cccc/index.js`, '/*@foo/c/c/c/c*/exports = {}', 'utf-8');

    // Create a nested package in bazel-bin where module names match directory structure
    mkdirp(`${BIN_DIR}/path/to/foo_d`);
    fs.writeFileSync(`${BIN_DIR}/path/to/foo_d/index.js`, '/*@foo/d*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_d/bar`);
    fs.writeFileSync(
        `${BIN_DIR}/path/to/foo_d/bar/index.js`, '/*@foo/d/bar*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_d/bar/fum/far`);
    fs.writeFileSync(
        `${BIN_DIR}/path/to/foo_d/bar/fum/far/index.js`, '/*@foo/d/bar/fum/far*/exports = {}',
        'utf-8');

    writeManifest({
      'bin': BIN_DIR,
      // intentionally out of order so that linker has to sort
      // and create nested modules in the correct order
      'modules': {
        'a': ['src', `${workspace}/path/to/lib_a`],
        '@foo/c/c/c/c': ['bin', `${workspace}/path/to/foo_cccc`],
        'b/b': ['src', 'other_wksp/path/to/lib_bb'],
        'b': ['src', 'other_wksp/path/to/lib_b'],
        '@foo/c': ['bin', `${workspace}/path/to/foo_c`],
        '@foo/c/c': ['bin', `${workspace}/path/to/foo_cc`],
        '@foo/d/bar/fum/far': ['bin', `${workspace}/path/to/foo_d/bar/fum/far`],
        '@foo/d/bar': ['bin', `${workspace}/path/to/foo_d/bar`],
        // don't include `@foo/d` as the linker should derive that symlink
        // from the lowest common denominator of the module name & module path
      },
      'workspace': workspace,
    });

    // TODO(alexeagle): test should control the environment, not just pass through
    await linker.main(['manifest.json'], new linker.Runfiles(process.env));

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join());
    expect(readWorkspaceNodeModules('a', 'index.js')).toEqual('/*a*/exports = {}');
    expect(readWorkspaceNodeModules('b', 'index.js')).toEqual('/*b*/exports = {}');
    expect(readWorkspaceNodeModules('b', 'b', 'index.js')).toEqual('/*b/b*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'c', 'index.js')).toEqual('/*@foo/c*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'c', 'c', 'index.js'))
        .toEqual('/*@foo/c/c*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'c', 'c', 'c', 'c', 'index.js'))
        .toEqual('/*@foo/c/c/c/c*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'd', 'index.js')).toEqual('/*@foo/d*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'd', 'bar', 'index.js'))
        .toEqual('/*@foo/d/bar*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'd', 'bar', 'fum', 'far', 'index.js'))
        .toEqual('/*@foo/d/bar/fum/far*/exports = {}');
  });

  it('should handle first-party packages with single parent link', async () => {
    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);

    // Create sub-packages to a lib in the user workspace
    mkdirp(`${BIN_DIR}/path/to/lib/a`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib/a/index.js`, '/*a*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/lib/b`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib/b/index.js`, '/*b*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/lib/c`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib/c/index.js`, '/*c*/exports = {}', 'utf-8');

    writeManifest({
      'bin': BIN_DIR,
      'modules': {
        '@foo/lib/a': ['bin', `${workspace}/path/to/lib/a`],
        '@foo/lib/b': ['bin', `${workspace}/path/to/lib/b`],
        '@foo/lib/c': ['bin', `${workspace}/path/to/lib/c`],
      },
      'workspace': workspace,
    });

    // TODO(alexeagle): test should control the environment, not just pass through
    await linker.main(['manifest.json'], new linker.Runfiles(process.env));

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join());
    expect(readWorkspaceNodeModules('@foo', 'lib', 'a', 'index.js')).toEqual('/*a*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'b', 'index.js')).toEqual('/*b*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'c', 'index.js')).toEqual('/*c*/exports = {}');
  });

  it('should handle first-party packages with sibling links in shared parent', async () => {
    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);

    // Create sub-packages to a lib in the user workspace
    mkdirp(`${BIN_DIR}/path/to/lib/x`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib/x/index.js`, '/*a*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/lib/b`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib/b/index.js`, '/*b*/exports = {}', 'utf-8');
    mkdirp('path/to/lib/c');
    fs.writeFileSync('path/to/lib/c/index.js', '/*c*/exports = {}', 'utf-8');

    writeManifest({
      'bin': BIN_DIR,
      'modules': {
        '@foo/lib/a': ['bin', `${workspace}/path/to/lib/x`],
        '@foo/lib/b': ['bin', `${workspace}/path/to/lib/b`],
        '@foo/lib/c': ['src', `${workspace}/path/to/lib/c`],
      },
      'workspace': workspace,
    });

    // TODO(alexeagle): test should control the environment, not just pass through
    await linker.main(['manifest.json'], new linker.Runfiles(process.env));

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join());
    expect(readWorkspaceNodeModules('@foo', 'lib', 'a', 'index.js')).toEqual('/*a*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'b', 'index.js')).toEqual('/*b*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'c', 'index.js')).toEqual('/*c*/exports = {}');
  });

  it('should handle first-party packages with miss-aligned nested links', async () => {
    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);

    // Create sub-packages to a lib in the user workspace
    mkdirp(`${BIN_DIR}/path/to/other/lib`);
    fs.writeFileSync(`${BIN_DIR}/path/to/other/lib/index.js`, '/*root*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo/a`);
    fs.writeFileSync(`${BIN_DIR}/path/to/foo/a/index.js`, '/*a*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/bar/b`);
    fs.writeFileSync(`${BIN_DIR}/path/to/bar/b/index.js`, '/*ab*/exports = {}', 'utf-8');

    writeManifest({
      'bin': BIN_DIR,
      'modules': {
        '@foo/lib': ['bin', `${workspace}/path/to/other/lib`],
        '@foo/lib/a': ['bin', `${workspace}/path/to/foo/a`],
        '@foo/lib/a/b': ['bin', `${workspace}/path/to/bar/b`],
      },
      'workspace': workspace,
    });

    // TODO(alexeagle): test should control the environment, not just pass through
    await linker.main(['manifest.json'], new linker.Runfiles(process.env));

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join());
    expect(readWorkspaceNodeModules('@foo', 'lib', 'index.js')).toEqual('/*root*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'a', 'index.js')).toEqual('/*a*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'a', 'b', 'index.js'))
        .toEqual('/*ab*/exports = {}');
  });

  it('should handle third-party packages in runfiles', async () => {
    mkdirp('npm/node_modules/some-package');
    const idx = 'npm/node_modules/some-package/index.js';
    fs.writeFileSync(idx, 'exports = {}', 'utf-8');
    const runfilesManifest = [`${idx} ${path.resolve(idx)}`];

    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);
    // No first-party packages
    writeManifest({
      'bin': BIN_DIR,
      'root': 'npm/node_modules',
    });
    writeRunfiles(runfilesManifest);

    await linker.main(['manifest.json'], new linker.Runfiles({
      'RUNFILES_MANIFEST_FILE': 'runfiles.mf',
    }));

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join(process.env['TEST_TMPDIR']!, workspace));
    expect(fs.readdirSync(path.join('node_modules', 'some-package'))).toContain('index.js');
  });
});