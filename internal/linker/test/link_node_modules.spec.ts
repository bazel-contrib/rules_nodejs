import * as fs from 'fs';
import * as path from 'path';

import * as linker from '../link_node_modules';
import {LinkerAliases, LinkerTreeElement} from '../link_node_modules';

const BIN_DIR = `bazel-out/my-platform-fastbuild/bin`;

function mkdirp(p: string) {
  if (!fs.existsSync(p)) {
    mkdirp(path.dirname(p));
    fs.mkdirSync(p);
  }
}

// Mock out the creation of the modules manifest
function writeManifest(o: {}) {
  fs.writeFileSync('manifest.json', JSON.stringify(o, null, 2), 'utf-8');
}

function writeRunfiles(manifest: string[]) {
  fs.writeFileSync('runfiles.mf', manifest.join('\n'), 'utf-8');
}

describe('link_node_modules', () => {
  let workspace: string;
  let runfilesWorkspace: string;

  beforeEach(() => {
    process.chdir(process.env['TEST_TMPDIR']!);
    // Prevent test isolation failures: each spec gets its own workspace
    workspace = `wksp_${Date.now()}`;
    runfilesWorkspace = `${workspace}/${BIN_DIR}/runfiles/${workspace}`;
    // Create our local workspace where the build is running
    mkdirp(runfilesWorkspace);
  });

  function readWorkspaceNodeModules(...parts: string[]) {
    const filePath = path.join(process.env['TEST_TMPDIR']!, workspace, 'node_modules', ...parts);
    return fs.readFileSync(filePath, 'utf-8')
  }

  describe('reduceModules', () => {
    it('should support no links', () => {
      expect(linker.reduceModules({})).toEqual([]);
    });

    it('should pull aligned child paths up', () => {
      const IN: LinkerAliases = {
        '@foo/a': ['execroot', `${BIN_DIR}/root/sub/a`],
        '@foo/a/b': ['execroot', `${BIN_DIR}/root/sub/a/b`],
        '@foo/a/1': ['execroot', `${BIN_DIR}/root/sub/a/1`],
        '@foo/a/2': ['execroot', `${BIN_DIR}/root/sub/a/2`],
      };
      const OUT: LinkerTreeElement[] = [
        {name: '@foo', children: [{name: '@foo/a', link: ['execroot', `${BIN_DIR}/root/sub/a`]}]}
      ];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should pull deep aligned child paths up', () => {
      const IN: LinkerAliases = {
        '@foo/a': ['execroot', `${BIN_DIR}/root/sub/a`],
        '@foo/a/b': ['execroot', `${BIN_DIR}/root/sub/a/b`],
        '@foo/a/b/1': ['execroot', `${BIN_DIR}/root/sub/a/b/1`],
        '@foo/a/b/2': ['execroot', `${BIN_DIR}/root/sub/a/b/2`],
      };
      const OUT: LinkerTreeElement[] = [
        {name: '@foo', children: [{name: '@foo/a', link: ['execroot', `${BIN_DIR}/root/sub/a`]}]}
      ];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not change aligned paths with a misaligned parent', () => {
      const IN: LinkerAliases = {
        '@foo/a': ['execroot', `${BIN_DIR}/root/sub/a`],
        '@foo/a/b': ['execroot', `${BIN_DIR}/root/sub/a/b`],
        '@foo/a/b/1': ['execroot', `${BIN_DIR}/root/sub/other/a/b/1`],
        '@foo/a/b/2': ['execroot', `${BIN_DIR}/root/sub/a/b/2`],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        children: [{
          name: '@foo/a',
          link: ['execroot', `${BIN_DIR}/root/sub/a`],
          children: [{
            name: '@foo/a/b',
            link: ['execroot', `${BIN_DIR}/root/sub/a/b`],
            children: [
              {name: '@foo/a/b/1', link: ['execroot', `${BIN_DIR}/root/sub/other/a/b/1`]},
              {name: '@foo/a/b/2', link: ['execroot', `${BIN_DIR}/root/sub/a/b/2`]}
            ]
          }]
        }]
      }];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce parent/child when parent linking to different path', () => {
      const IN: LinkerAliases = {
        '@foo/a': ['execroot', `${BIN_DIR}/root/foo`],
        '@foo/a/b': ['execroot', `${BIN_DIR}/root/sub/a/b`],
        '@foo/a/b/1': ['execroot', `${BIN_DIR}/root/sub/a/b/1`],
        '@foo/a/b/2': ['execroot', `${BIN_DIR}/root/sub/a/b/2`],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        children: [{
          name: '@foo/a',
          link: ['execroot', `${BIN_DIR}/root/foo`],
          children: [{name: '@foo/a/b', link: ['execroot', `${BIN_DIR}/root/sub/a/b`]}]
        }]
      }];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should reduce aligned parent+children aliases to single parent alias', () => {
      const IN: LinkerAliases = {
        '@foo/a': ['execroot', `${BIN_DIR}/root/sub/a`],
        '@foo/a/1': ['execroot', `${BIN_DIR}/root/sub/a/1`],
        '@foo/a/2': ['execroot', `${BIN_DIR}/root/sub/a/2`],
      };
      const OUT: LinkerTreeElement[] = [
        {name: '@foo', children: [{name: '@foo/a', link: ['execroot', `${BIN_DIR}/root/sub/a`]}]}
      ];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce parent+children aliases aligned to different link types', () => {
      const IN: LinkerAliases = {
        '@foo/a': ['execroot', `${BIN_DIR}/root/sub/a`],
        '@foo/a/1': ['runfiles', `${BIN_DIR}/root/sub/a/1`],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        children: [{
          name: '@foo/a',
          link: ['execroot', `${BIN_DIR}/root/sub/a`],
          children: [{name: '@foo/a/1', link: ['runfiles', `${BIN_DIR}/root/sub/a/1`]}]
        }]
      }];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce sibling aliases with different link types', () => {
      const IN: LinkerAliases = {
        '@foo/a': ['execroot', `${BIN_DIR}/root/sub/a`],
        '@foo/a/1': ['runfiles', `${BIN_DIR}/root/sub/a/1`],
        '@foo/a/2': ['execroot', `${BIN_DIR}/root/sub/a/2`],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        children: [{
          name: '@foo/a',
          link: ['execroot', `${BIN_DIR}/root/sub/a`],
          children: [
            {name: '@foo/a/1', link: ['runfiles', `${BIN_DIR}/root/sub/a/1`]},
            {name: '@foo/a/2', link: ['execroot', `${BIN_DIR}/root/sub/a/2`]}
          ]
        }]
      }];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should reduce deeply-aligned siblings', () => {
      const IN: LinkerAliases = {
        '@foo/a': ['execroot', `${BIN_DIR}/root/sub/a`],
        '@foo/a/b': ['execroot', `${BIN_DIR}/root/sub/a/b`],
        '@foo/a/b/c': ['execroot', `${BIN_DIR}/root/sub/a/b/c`],
        '@foo/a/b/c/d1': ['execroot', `${BIN_DIR}/root/sub/a/b/c/d1`],
        '@foo/a/b/c/d2': ['execroot', `${BIN_DIR}/root/sub/a/b/c/d2`],
      };
      const OUT: LinkerTreeElement[] = [
        {name: '@foo', children: [{name: '@foo/a', link: ['execroot', `${BIN_DIR}/root/sub/a`]}]}
      ];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce parent/child with different ancestor link paths', () => {
      const IN: LinkerAliases = {
        'b/b': ['execroot', 'external/other_wksp/path/to/lib_bb'],
        'b': ['execroot', 'external/other_wksp/path/to/lib_b'],
      };
      const OUT: LinkerTreeElement[] = [{
        name: 'b',
        link: ['execroot', 'external/other_wksp/path/to/lib_b'],
        children: [{
          name: 'b/b',
          link: ['execroot', 'external/other_wksp/path/to/lib_bb'],
        }],
      }];

      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce aligned paths when link has extra dir', () => {
      const IN: LinkerAliases = {
        '@foo/lib': ['execroot', `${BIN_DIR}/path/to/lib`],
        '@foo/lib/a': ['execroot', `${BIN_DIR}/path/to/lib/noseeme/a`],
        '@foo/lib/b': ['execroot', `${BIN_DIR}/path/to/lib/noseeme/b`],
        '@foo/lib/c': ['execroot', `${BIN_DIR}/path/to/lib/noseeme/c`],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        children: [{
          name: '@foo/lib',
          link: ['execroot', `${BIN_DIR}/path/to/lib`],
          children: [
            {name: '@foo/lib/a', link: ['execroot', `${BIN_DIR}/path/to/lib/noseeme/a`]},
            {name: '@foo/lib/b', link: ['execroot', `${BIN_DIR}/path/to/lib/noseeme/b`]},
            {name: '@foo/lib/c', link: ['execroot', `${BIN_DIR}/path/to/lib/noseeme/c`]}
          ]
        }]
      }];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce sibling mappings with inconsistent paths', () => {
      const IN: LinkerAliases = {
        '@foo/lib': ['execroot', `${BIN_DIR}/path/to/lib`],
        '@foo/lib/a': ['execroot', `${BIN_DIR}/path/to/lib/x`],
        '@foo/lib/b': ['execroot', `${BIN_DIR}/path/to/lib/b`],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        children: [{
          name: '@foo/lib',
          link: ['execroot', `${BIN_DIR}/path/to/lib`],
          children: [
            {name: '@foo/lib/a', link: ['execroot', `${BIN_DIR}/path/to/lib/x`]},
            {name: '@foo/lib/b', link: ['execroot', `${BIN_DIR}/path/to/lib/b`]}
          ]
        }]
      }];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce sibling mappings with inconsistent path parents', () => {
      const IN: LinkerAliases = {
        '@foo/lib': ['execroot', `${BIN_DIR}/path/to/lib`],
        '@foo/lib/a': ['execroot', `${BIN_DIR}/path/to/lib/x/a`],
        '@foo/lib/b': ['execroot', `${BIN_DIR}/path/to/lib/b`],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        children: [{
          name: '@foo/lib',
          link: ['execroot', `${BIN_DIR}/path/to/lib`],
          children: [
            {name: '@foo/lib/a', link: ['execroot', `${BIN_DIR}/path/to/lib/x/a`]},
            {name: '@foo/lib/b', link: ['execroot', `${BIN_DIR}/path/to/lib/b`]}
          ]
        }]
      }];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should not reduce to parent mapping with inconcsisten parent link path', () => {
      const IN: LinkerAliases = {
        '@foo/lib': ['execroot', `${BIN_DIR}/path/to/other/lib`],
        '@foo/lib/a': ['execroot', `${BIN_DIR}/path/to/lib/a`],
        '@foo/lib/b': ['execroot', `${BIN_DIR}/path/to/lib/b`],
      };
      const OUT: LinkerTreeElement[] = [{
        name: '@foo',
        children: [{
          name: '@foo/lib',
          link: [
            'execroot',
            `${BIN_DIR}/path/to/other/lib`,
          ],
          children: [
            {
              name: '@foo/lib/a',
              link: [
                'execroot',
                `${BIN_DIR}/path/to/lib/a`,
              ]
            },
            {
              name: '@foo/lib/b',
              link: [
                'execroot',
                `${BIN_DIR}/path/to/lib/b`,
              ]
            }
          ]
        }]
      }];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });

    it('should reduce complicated example', () => {
      const IN: LinkerAliases = {
        'a': ['execroot', `path/to/lib_a`],
        '@foo/c/c/c/c': ['execroot', `${BIN_DIR}/path/to/foo_cccc`],
        'b/b': ['execroot', 'external/other_wksp/path/to/lib_bb'],
        'b': ['execroot', 'external/other_wksp/path/to/lib_b'],
        '@foo/c': ['execroot', `${BIN_DIR}/path/to/foo_c`],
        '@foo/c/c': ['execroot', `${BIN_DIR}/path/to/foo_cc`],
        '@foo/d/bar/fum/far': ['execroot', `${BIN_DIR}/path/to/foo_d/bar/fum/far`],
        '@foo/d/bar': ['execroot', `${BIN_DIR}/path/to/foo_d/bar`],
        // don't include `@foo/d` as the linker should derive that symlink
        // from the lowest common denominator of the module name & module path
      };
      const OUT: LinkerTreeElement[] = [
        {
          name: '@foo',
          children: [
            {
              name: '@foo/c',
              link: ['execroot', `${BIN_DIR}/path/to/foo_c`],
              children: [{
                name: '@foo/c/c',
                link: ['execroot', `${BIN_DIR}/path/to/foo_cc`],
                children: [{
                  name: '@foo/c/c/c',
                  children: [
                    {name: '@foo/c/c/c/c', link: ['execroot', `${BIN_DIR}/path/to/foo_cccc`]}
                  ]
                }]
              }]
            },
            {
              name: '@foo/d',
              children: [{
                name: '@foo/d/bar',
                link: ['execroot', `${BIN_DIR}/path/to/foo_d/bar`],
                children: [{
                  name: '@foo/d/bar/fum',
                  children: [{
                    name: '@foo/d/bar/fum/far',
                    link: ['execroot', `${BIN_DIR}/path/to/foo_d/bar/fum/far`]
                  }]
                }]
              }]
            }
          ]
        },
        {name: 'a', link: ['execroot', 'path/to/lib_a']}, {
          name: 'b',
          link: ['execroot', 'external/other_wksp/path/to/lib_b'],
          children: [{name: 'b/b', link: ['execroot', 'external/other_wksp/path/to/lib_bb']}]
        }
      ];
      expect(linker.reduceModules(IN)).toEqual(OUT);
    });
  });

  it('should report when modules manifest absent', async () => {
    try {
      await (linker as any).main();
    } catch (expected) {
      expect(expected.message).toContain('requires one argument');
    }
    try {
      await (linker as any).main([]);
    } catch (expected) {
      expect(expected.message).toContain('requires one argument');
    }
    try {
      await (linker as any).main(['bad_path']);
    } catch (expected) {
      expect(expected.message).toContain('ENOENT');
    }
  });

  it('should handle first-party packages in workspace', async () => {
    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);

    // Create a package in the user workspace
    mkdirp('path/to/lib_a');
    fs.writeFileSync('path/to/lib_a/index.js', '/*a*/exports = {}', 'utf-8');

    // Create a nested package in a different workspace
    mkdirp('external/other_wksp/path/to/lib_b');
    fs.writeFileSync('external/other_wksp/path/to/lib_b/index.js', '/*b*/exports = {}', 'utf-8');
    mkdirp('external/other_wksp/path/to/lib_bb');
    fs.writeFileSync('external/other_wksp/path/to/lib_bb/index.js', '/*b/b*/exports = {}', 'utf-8');

    // Create a nested package in bazel-bin where module names don't match directory structure
    mkdirp(`${BIN_DIR}/path/to/foo_c`);
    fs.writeFileSync(`${BIN_DIR}/path/to/foo_c/index.js`, '/*@foo/c*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_cc`);
    fs.writeFileSync(`${BIN_DIR}/path/to/foo_cc/index.js`, '/*@foo/c/c*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_cccc`);
    fs.writeFileSync(
        `${BIN_DIR}/path/to/foo_cccc/index.js`, '/*@foo/c/c/c/c*/exports = {}', 'utf-8');

    // Create a nested package in bazel-bin where module names match directory structure
    mkdirp(`${BIN_DIR}/path/to/foo_d`);
    fs.writeFileSync(`${BIN_DIR}/path/to/foo_d/index.js`, '/*@foo/d*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_d/bar`);
    fs.writeFileSync(
        `${BIN_DIR}/path/to/foo_d/bar/index.js`, '/*@foo/d/bar*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo_d/bar/fum/far`);
    fs.writeFileSync(
        `${BIN_DIR}/path/to/foo_d/bar/fum/far/index.js`, '/*@foo/d/bar/fum/far*/exports = {}',
        'utf-8');

    writeManifest({
      'bin': BIN_DIR,
      // intentionally out of order so that linker has to sort
      // and create nested modules in the correct order
      'modules': {
        'a': ['execroot', `path/to/lib_a`],
        '@foo/c/c/c/c': ['execroot', `${BIN_DIR}/path/to/foo_cccc`],
        'b/b': ['execroot', 'external/other_wksp/path/to/lib_bb'],
        'b': ['execroot', 'external/other_wksp/path/to/lib_b'],
        '@foo/c': ['execroot', `${BIN_DIR}/path/to/foo_c`],
        '@foo/c/c': ['execroot', `${BIN_DIR}/path/to/foo_cc`],
        '@foo/d/bar/fum/far': ['execroot', `${BIN_DIR}/path/to/foo_d/bar/fum/far`],
        '@foo/d/bar': ['execroot', `${BIN_DIR}/path/to/foo_d/bar`],
        '@foo/d': ['execroot', `${BIN_DIR}/path/to/foo_d`],
      },
      'workspace': workspace,
    });

    // TODO(alexeagle): test should control the environment, not just pass through
    await linker.main(['manifest.json'], new linker.Runfiles(process.env));

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join());
    expect(readWorkspaceNodeModules('a', 'index.js')).toEqual('/*a*/exports = {}');
    expect(readWorkspaceNodeModules('b', 'index.js')).toEqual('/*b*/exports = {}');
    expect(readWorkspaceNodeModules('b', 'b', 'index.js')).toEqual('/*b/b*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'c', 'index.js')).toEqual('/*@foo/c*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'c', 'c', 'index.js'))
        .toEqual('/*@foo/c/c*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'c', 'c', 'c', 'c', 'index.js'))
        .toEqual('/*@foo/c/c/c/c*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'd', 'index.js')).toEqual('/*@foo/d*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'd', 'bar', 'index.js'))
        .toEqual('/*@foo/d/bar*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'd', 'bar', 'fum', 'far', 'index.js'))
        .toEqual('/*@foo/d/bar/fum/far*/exports = {}');
  });

  it('should handle first-party packages with single parent link', async () => {
    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);

    // Create sub-packages to a lib in the user workspace
    mkdirp(`${BIN_DIR}/path/to/lib/a`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib/a/index.js`, '/*a*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/lib/b`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib/b/index.js`, '/*b*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/lib/c`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib/c/index.js`, '/*c*/exports = {}', 'utf-8');

    writeManifest({
      'bin': BIN_DIR,
      'modules': {
        '@foo/lib/a': ['execroot', `${BIN_DIR}/path/to/lib/a`],
        '@foo/lib/b': ['execroot', `${BIN_DIR}/path/to/lib/b`],
        '@foo/lib/c': ['execroot', `${BIN_DIR}/path/to/lib/c`],
      },
      'workspace': workspace,
    });

    // TODO(alexeagle): test should control the environment, not just pass through
    await linker.main(['manifest.json'], new linker.Runfiles(process.env));

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join());
    expect(readWorkspaceNodeModules('@foo', 'lib', 'a', 'index.js')).toEqual('/*a*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'b', 'index.js')).toEqual('/*b*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'c', 'index.js')).toEqual('/*c*/exports = {}');
  });

  it('should handle first-party packages with sibling links in shared parent', async () => {
    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);

    // Create sub-packages to a lib in the user workspace
    mkdirp(`${BIN_DIR}/path/to/lib/x`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib/x/index.js`, '/*a*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/lib/b`);
    fs.writeFileSync(`${BIN_DIR}/path/to/lib/b/index.js`, '/*b*/exports = {}', 'utf-8');
    mkdirp('path/to/lib/c');
    fs.writeFileSync('path/to/lib/c/index.js', '/*c*/exports = {}', 'utf-8');

    writeManifest({
      'bin': BIN_DIR,
      'modules': {
        '@foo/lib/a': ['execroot', `${BIN_DIR}/path/to/lib/x`],
        '@foo/lib/b': ['execroot', `${BIN_DIR}/path/to/lib/b`],
        '@foo/lib/c': ['execroot', `path/to/lib/c`],
      },
      'workspace': workspace,
    });

    // TODO(alexeagle): test should control the environment, not just pass through
    await linker.main(['manifest.json'], new linker.Runfiles(process.env));

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join());
    expect(readWorkspaceNodeModules('@foo', 'lib', 'a', 'index.js')).toEqual('/*a*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'b', 'index.js')).toEqual('/*b*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'c', 'index.js')).toEqual('/*c*/exports = {}');
  });

  it('should handle first-party packages with miss-aligned nested links', async () => {
    // Set the cwd() like Bazel would in the execroot
    process.chdir(workspace);

    // Create sub-packages to a lib in the user workspace
    mkdirp(`${BIN_DIR}/path/to/other/lib`);
    fs.writeFileSync(`${BIN_DIR}/path/to/other/lib/index.js`, '/*root*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/foo/a`);
    fs.writeFileSync(`${BIN_DIR}/path/to/foo/a/index.js`, '/*a*/exports = {}', 'utf-8');
    mkdirp(`${BIN_DIR}/path/to/bar/b`);
    fs.writeFileSync(`${BIN_DIR}/path/to/bar/b/index.js`, '/*ab*/exports = {}', 'utf-8');

    writeManifest({
      'bin': BIN_DIR,
      'modules': {
        '@foo/lib': ['execroot', `${BIN_DIR}/path/to/other/lib`],
        '@foo/lib/a': ['execroot', `${BIN_DIR}/path/to/foo/a`],
        '@foo/lib/a/b': ['execroot', `${BIN_DIR}/path/to/bar/b`],
      },
      'workspace': workspace,
    });

    // TODO(alexeagle): test should control the environment, not just pass through
    await linker.main(['manifest.json'], new linker.Runfiles(process.env));

    // The linker expects to run as its own process, so it changes the wd
    process.chdir(path.join());
    expect(readWorkspaceNodeModules('@foo', 'lib', 'index.js')).toEqual('/*root*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'a', 'index.js')).toEqual('/*a*/exports = {}');
    expect(readWorkspaceNodeModules('@foo', 'lib', 'a', 'b', 'index.js'))
        .toEqual('/*ab*/exports = {}');
  });

  it('should handle third-party packages in runfiles', async () => {
    mkdirp('npm/node_modules/some-package');
    const idx = 'npm/node_modules/some-package/index.js';
    fs.writeFileSync(idx, 'exports = {}', 'utf-8');
    const runfilesManifest = [`${idx} ${path.resolve(idx)}`];

    // Set the cwd() like Bazel would in the runfiles
    process.chdir(runfilesWorkspace);

    // No first-party packages
    writeManifest({
      'bin': BIN_DIR,
      'root': 'npm/node_modules',
    });
    writeRunfiles(runfilesManifest);

    await linker.main(['manifest.json'], new linker.Runfiles({
      'RUNFILES_MANIFEST_FILE': 'runfiles.mf',
    }));

    // We expect the linker to symlink node_modules to `execroot/my_wksp/node_modules` when
    // under runfiles
    expect(fs.readdirSync(
               path.join(process.env['TEST_TMPDIR']!, workspace, 'node_modules', 'some-package')))
        .toContain('index.js');
  });
});