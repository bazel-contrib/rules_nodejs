/**
 * @license
 * Copyright 2019 The Bazel Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview This script generates BUILD.bazel files for vendored third_party
 * npm packages used by build_bazel_rules_nodejs.
 */
'use strict';

const fs = require('fs');
const path = require('path');

const BUILD_FILE_HEADER = `# Generated by third_party/npm/generate_build_files.js
# DO NOT EDIT

# To regenerate all third_party npm dependencies and re-generate this BUILD file
# run /scripts/update_third_party_npm_deps.sh

# All rules in other repositories can use these targets
package(default_visibility = ["//visibility:public"])

licenses(["notice"])
`;

const PACKAGE_ROOT = '//third_party/npm';

/**
 * Main entrypoint.
 * Write BUILD and .bzl files.
 */
function main() {
  // find all packages (including packages in nested node_modules)
  const pkgs = findPackages();

  // flatten dependencies
  const pkgsMap = new Map();
  pkgs.forEach(pkg => pkgsMap.set(pkg._dir, pkg));
  pkgs.forEach(pkg => flattenDependencies(pkg, pkg, pkgsMap));

  // delete all the Bazel files from fetched packages
  // so that filegroups do not cross Bazel package boundaries
  pkgs.forEach(pkg => deleteBazelFiles(pkg));

  // generate BUILD files
  generateRootBuildFile(pkgs)
  pkgs.filter(pkg => !pkg._isNested).forEach(pkg => generatePackageBuildFiles(pkg));
}

/**
 * Generates the root BUILD file.
 */
function generateRootBuildFile(pkgs) {
  const srcs = pkgs.filter(pkg => !pkg._isNested);

  const buildFile =
      BUILD_FILE_HEADER +
      `
load("@build_bazel_rules_nodejs//internal/npm_install:node_module_library.bzl", "node_module_library")

# package_contents target used for generating npm package
filegroup(
    name = "package_contents",
    srcs = [
        ":BUILD.bazel",
        ${
          srcs.map(
                  pkg =>
                      `"${PACKAGE_ROOT}/node_modules/${pkg._dir}:${pkg._name}__package_contents",`)
              .join('\n        ')}
    ],
    visibility = ["//:__pkg__"],
)

node_module_library(
    name = "node_modules",
    srcs = [
        ${
          srcs.map(pkg => `"${PACKAGE_ROOT}/node_modules/${pkg._dir}:${pkg._name}__files",`)
              .join('\n        ')}
    ],
)
`;

  fs.writeFileSync('BUILD.bazel', buildFile);
}

/**
 * Generates all BUILD files for a package.
 */
function generatePackageBuildFiles(pkg) {
  const buildFile = BUILD_FILE_HEADER + printPackage(pkg);
  fs.writeFileSync(path.posix.join('node_modules', pkg._dir, 'BUILD.bazel'), buildFile);
}

/**
 * Given a pkg, return the skylark `node_module_library` targets for the package.
 */
function printPackage(pkg) {
  const sources = filterFiles(pkg._files, []);
  const pkgDeps = pkg._dependencies.filter(dep => dep !== pkg && !dep._isNested);

  let pkgDepsStarlark = '';
  let contentsDepsStarlark = '';
  if (pkgDeps.length) {
    pkgDepsStarlark = `
    # flattened list of direct and transitive dependencies hoisted to root by the package manager
    deps = [
        ${
        pkgDeps.map(dep => `"${PACKAGE_ROOT}/node_modules/${dep._dir}:${dep._name}__files",`)
            .join('\n        ')}
    ],`;

    contentsDepsStarlark = ` + [
        # flattened list of direct and transitive dependencies hoisted to root by the package manager
        ${
        pkgDeps.map(dep => `"${PACKAGE_ROOT}/node_modules/${dep._dir}:${dep._name}__sources",`)
            .join('\n        ')}
    ]`;
  }

  return `
load("@build_bazel_rules_nodejs//internal/npm_install:node_module_library.bzl", "node_module_library")

# Generated targets for npm package "${pkg._dir}"
${printJson(pkg)}

_SOURCES = [
    ${sources.map(f => `":${f}",`).join('\n    ')}
]

node_module_library(
    name = "${pkg._name}__pkg",
    # ${pkg._dir} package contents (and contents of nested node_modules)
    srcs = [
        ":${pkg._name}__files",
    ],${pkgDepsStarlark}
)

# ${pkg._name}__files target is used as dep for other __pkg targets to prevent
# circular dependencies errors
node_module_library(
    name = "${pkg._name}__files",
    srcs = _SOURCES,
)

filegroup(
    name = "${pkg._name}__contents",
    srcs = _SOURCES${contentsDepsStarlark},
)

# ${pkg._name}__sources target is used as dep for other __contents targets to prevent
# circular dependencies errors
filegroup(
    name = "${pkg._name}__sources",
    srcs = _SOURCES,
)

# ${pkg._name}__package_contents target used for generating npm package
filegroup(
    name = "${pkg._name}__package_contents",
    srcs = glob(["**"]),
    visibility = ["${PACKAGE_ROOT}:__pkg__"],
)
`;
}

/**
 * Checks if a path is a file.
 */
function isFile(p) {
  return fs.existsSync(p) && fs.statSync(p).isFile();
}

/**
 * Checks if a path is an npm package which is is a directory with a package.json file.
 */
function isDirectory(p) {
  return fs.existsSync(p) && fs.statSync(p).isDirectory();
}

/**
 * Returns an array of all the files under a directory as relative
 * paths to the directory.
 */
function listFiles(rootDir, subDir = '') {
  const dir = path.posix.join(rootDir, subDir);
  if (!isDirectory(dir)) {
    return [];
  }
  return fs.readdirSync(dir)
      .reduce(
          (files, file) => {
            const fullPath = path.posix.join(dir, file);
            const relPath = path.posix.join(subDir, file);
            const isSymbolicLink = fs.lstatSync(fullPath).isSymbolicLink();
            let stat;
            try {
              stat = fs.statSync(fullPath);
            } catch (e) {
              if (isSymbolicLink) {
                // Filter out broken symbolic links. These cause fs.statSync(fullPath)
                // to fail with `ENOENT: no such file or directory ...`
                return files;
              }
              throw e;
            }
            const isDirectory = stat.isDirectory();
            if (isDirectory && isSymbolicLink) {
              // Filter out symbolic links to directories. An issue in yarn versions
              // older than 1.12.1 creates symbolic links to folders in the .bin folder
              // which leads to Bazel targets that cross package boundaries.
              // See https://github.com/bazelbuild/rules_nodejs/issues/428 and
              // https://github.com/bazelbuild/rules_nodejs/issues/438.
              // This is tested in internal/e2e/fine_grained_symlinks.
              return files;
            }
            return isDirectory ? files.concat(listFiles(rootDir, relPath)) : files.concat(relPath);
          },
          [])
      // We return a sorted array so that the order of files
      // is the same regardless of platform
      .sort();
}

/**
 * Finds and returns an array of all packages under a given path.
 */
function findPackages(p = 'node_modules') {
  if (!isDirectory(p)) {
    return [];
  }

  const result = [];

  const listing = fs.readdirSync(p);

  const packages = listing.filter(f => !f.startsWith('@'))
                       .map(f => path.posix.join(p, f))
                       .filter(f => isDirectory(f));
  packages.forEach(
      f => result.push(parsePackage(f), ...findPackages(path.posix.join(f, 'node_modules'))));

  const scopes = listing.filter(f => f.startsWith('@'))
                     .map(f => path.posix.join(p, f))
                     .filter(f => fs.statSync(f).isDirectory());
  scopes.forEach(f => result.push(...findPackages(f)));

  return result;
}

/**
 * Given the name of a top-level folder in node_modules, parse the
 * package json and return it as an object along with
 * some additional internal attributes prefixed with '_'.
 */
function parsePackage(p) {
  // Parse the package.json file of this package
  const packageJson = path.posix.join(p, 'package.json');
  const pkg = isFile(packageJson) ?
      JSON.parse(fs.readFileSync(`${p}/package.json`, {encoding: 'utf8'})) :
      {version: '0.0.0'};

  // Trim the leading node_modules from the path and
  // assign to _dir for future use
  pkg._dir = p.replace(/^node_modules\//, '');

  // Stash the package directory name for future use
  pkg._name = pkg._dir.split('/').pop();

  // Keep track of whether or not this is a nested package
  pkg._isNested = !!p.match(/\/node_modules\//);

  // List all the files in the npm package for later use
  pkg._files = listFiles(p);

  // Initialize _dependencies to an empty array
  // which is later filled with the flattened dependency list
  pkg._dependencies = [];

  return pkg;
}

/**
 * Flattens all transitive dependencies of a package
 * into a _dependencies array.
 */
function flattenDependencies(pkg, dep, pkgsMap) {
  if (pkg._dependencies.indexOf(dep) !== -1) {
    // circular dependency
    return;
  }
  pkg._dependencies.push(dep);
  const findDeps = function(targetDeps, required, depType) {
    Object.keys(targetDeps || {})
        .map(targetDep => {
          // look for matching nested package
          const dirSegments = dep._dir.split('/');
          while (dirSegments.length) {
            const maybe = path.posix.join(...dirSegments, 'node_modules', targetDep);
            if (pkgsMap.has(maybe)) {
              return pkgsMap.get(maybe);
            }
            dirSegments.pop();
          }
          // look for matching root package
          if (pkgsMap.has(targetDep)) {
            return pkgsMap.get(targetDep);
          }
          // dependency not found
          if (required) {
            console.error(`Could not find ${depType} '${targetDep}' of '${dep._dir}'`);
            process.exit(1);
          }
          return null;
        })
        .filter(dep => !!dep)
        .map(dep => flattenDependencies(pkg, dep, pkgsMap));
  };
  // npm will in some cases add optionalDependencies to the list
  // of dependencies to the package.json it writes to node_modules.
  // We delete these here if they exist as they may result
  // in expected dependencies that are not found.
  if (dep.dependencies && dep.optionalDependencies) {
    Object.keys(dep.optionalDependencies).forEach(optionalDep => {
      delete dep.dependencies[optionalDep];
    });
  }

  findDeps(dep.dependencies, true, 'dependency');
  findDeps(dep.peerDependencies, true, 'peer dependency');
  // `optionalDependencies` that are missing should be silently
  // ignored since the npm/yarn will not fail if these dependencies
  // fail to install. Packages should handle the cases where these
  // dependencies are missing gracefully at runtime.
  // An example of this is the `chokidar` package which specifies
  // `fsevents` as an optionalDependency. On OSX, `fsevents`
  // is installed successfully, but on Windows & Linux, `fsevents`
  // fails to install and the package will not be present when
  // checking the dependencies of `chokidar`.
  findDeps(dep.optionalDependencies, false, 'optional dependency');
}

/**
 * Reformat/pretty-print a json object as a skylark comment (each line
 * starts with '# ').
 */
function printJson(pkg) {
  // Clone and modify _dependencies to avoid circular issues when JSONifying
  // & delete _files array
  const cloned = {...pkg};
  cloned._dependencies = cloned._dependencies.map(dep => dep._dir);
  delete cloned._files;
  return JSON.stringify(cloned, null, 2).split('\n').map(line => `# ${line}`).join('\n');
}

/**
 * A filter function for files in an npm package. Comparison is case-insensitive.
 * @param files array of files to filter
 * @param exts list of white listed case-insensitive extensions; if empty, no filter is
 *             done on extensions; '' empty string denotes to allow files with no extensions,
 *             other extensions are listed with '.ext' notation such as '.d.ts'.
 */
function filterFiles(files, exts = []) {
  // Files with spaces (\x20) or unicode characters (<\x20 && >\x7E) are not allowed in
  // Bazel runfiles. See https://github.com/bazelbuild/bazel/issues/4327
  files = files.filter(f => !f.match(/[^\x21-\x7E]/));
  if (exts.length) {
    const allowNoExts = exts.includes('');
    files = files.filter(f => {
      // include files with no extensions if noExt is true
      if (allowNoExts && !path.extname(f)) return true;
      // filter files in exts
      const lc = f.toLowerCase();
      for (const e of exts) {
        if (e && lc.endsWith(e.toLowerCase())) {
          return true;
        }
      }
      return false;
    })
  }
  return files;
}

/**
 * Delete all WORKSPACE, BUILD and .bzl files from an npm package.
 */
function deleteBazelFiles(pkg) {
  pkg._files = pkg._files.filter(file => {
    const basename = path.basename(file);
    if (/^WORKSPACE$/i.test(basename) || /^BUILD$/i.test(basename) ||
        /^BUILD\.bazel$/i.test(basename) || /\.bzl$/i.test(basename)) {
      // Delete Bazel files so that so that files do not cross Bazel packages
      // boundaries
      const fullPath = path.posix.join('node_modules', pkg._dir, file);
      if (!fs.existsSync(fullPath)) {
        // It is possible that the file no longer exists as reported in
        // https://github.com/bazelbuild/rules_nodejs/issues/522
        return false;
      }
      fs.unlinkSync(fullPath);
      return false;
    }
    return true;
  });
}

if (require.main === module) {
  main();
}

module.exports = {
  main,
};
